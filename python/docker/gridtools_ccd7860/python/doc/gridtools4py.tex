\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\begin{document}

\section{Abstract}
???
 We plan to extend the class of applications for which SteLLa has been designed. This will require the development of a DESL with some fundamental differences from SteLLa. The reason is not only that SteLLa embeds some jargon that is COSMO specific, but also that some limitations, such as the vertical dimension being un-partitioned, represent an impediment to the development of some of the latest meteorological and climate modeling codes. We list below the main features of the new envisaged redesign.
???



\section{Introduction}
The development of future software for new computer architectures is expected to make significant demands on compiler technologies.
In order to support the use of new hardware features, rewriting of applications aims to a greater or lesser extent at preserving the current software investment.
Since existing compilers provide limited support for the broad range of challenges HPC programming faces, e.g., parallelism, locality and power efficiency, automated mechanisms are emerging to transform existing software and take advantage of future machines.
This approach should lessen the cost and effort of moving to new, and possibly radically different, future architectures.

In this context, GridTools provides an answer to such exigency by providing a set of tools for solving partial differential equations (PDE) on multigrids, such as those typically used in atmospheric and geo sciences.
Indeed, multigrid is known to be an efficient method to this end.
Still, the concrete algorithm and its implementation are highly dependent on the problem definition and the target hardware architecture.
For this reason, usually different code versions are needed to cover all relevant cases.

The GridTools ecosystem features three abstraction layers providing the user with a mathematical idiom to describe the problem (DSL), a hybrid environment to support rapid prototyping and research (Python), and a domain performant language (DPL) as the lower layer which abstracts most architecture details while exploiting domain concepts to improve performance (C++).

???
Indeed, the performance gain provided by most HPC architectures comes at the cost of increased complexity, and programming these new architectures is usually just the first hurdle.
To design programs that are portable across the growing landscape of computer architectures is the real challenge.

One way of tackling this increased complexity is the design of specialized tools targeting specific problem domains, PDE solvers on grids in this case.
That is, libraries and frameworks would sacrifice generality in order to lower the complexity of implementations and improve their performance.
However, experience shows that this process alone is often not sufficient. 
Generally, when developing new applications or supporting new hardware architectures, libraries and frameworks have to be extended or even reimplemented to accomodate new requirements.

During the past few years, a new trend emerged proposing a solution to this problem. Domain specific languages (DSL) enable a high-level description of problems and algorithms which can then be transformed into low-level, high-performance code using different code-generation techniques.
???


\subsection{Related work}
We may find several examples of DSLs that generate low-level code using automatic tuning and optimization, e.g., FEniCS [ref!] for finite elements, FFTW [ref!].

The ROSE source-to-source compiler infrastructure ...???

PATUS ...???

POCHOIR ...???

HOPE ...???

EXASTENCIL ...???

PHYSIS ...???

FeNiCs [ref!] exposes its functionality to Python using the same API available in C++ interface using SWIG.
In this sense, the exposed interface is exactly the same as in C++, with only certain added functionality from the Python side, e.g., run-time compilation of UFL form language.
Indeed, there is no source-to-source translation, since the user is directly accessing the C++ backend, not taking advantage of the extra level of abstraction provided by Python.
We take this concept a step further to provide a source-to-source translation between Python and C++ in order fot the user to take advantage of an easier transition between the domain-specific problem and the implementation of its solution.
The generated C++ code is seamlessly integrated whitin the Python runtim and its made available to the end user in a human-readable fashion that also inludes various comments pointers and references to the documentation for the advanced user that wishes to dig dipper in the C++ backend.


\section{The GridTools ecosystem}
As shown in Figure ???, the GridTools ecosystem includes a low-level library in C++ and an abstraction layer on top of it implemented in Python.
The topmost layer implements a DSL that enables the description of ...??? in a mathematical idiom.
The Python layer provides a hybrid context in which the descriptive and imperative paradigms mix to provide the user with an environment rich of tools for research, development and prototyping in the field of PDE solvers on grids.
The lower-most layer is implemented in C++ and provides ...???

The goal of the three-layered approach is to provide different levels of abstraction over the target problem. 
This way, we aim at providing the right environment and tool set for the widest public and problem spectrum possible.
GridTools also allow the user to start working in the most suitable layer, while the built-in transformations enable moving to a lower layer automatically.
Source-to-source compilers assembled at each level provide the automatic transformations that enable this progress.
They supply several transformations that enable a natural transition from a descriptive to an imperative representation of the problem.
This means that architecture-specific DPL featuring different levels of optimizations can be generated from the same DSL.

The first one involves a short and descriptive DSL, which was inspired by the ICON DSL???, that enables the user to provide a description that is closer to the mathematical formulation.

The DSL is then translated to the second layer of abstraction of our approach, i.e., the Python interface.
By mixing the descriptive and and the imperative approaches, the Python interface provides a hybrid which is simple enough for the non-expert to work with yet powerful.
It provides an ideal environment for reasearch and prototyping of new stencils by taking advange of the myariad of tools provided by the Python scientific computing.
The Python environment provides a non-expert and friendly access to the C++ library implementing the actual functionality.

The C++ library (...)???

In this sense, GridTools provides a framework for creating high-performance implementations starting from a simple declarative specification. 
Moreover, Gridtools4Py includes an interactive environment that allows experimentation through a wide palette of visualization and debuging tools.
The user can easily choose among different backends on how the kernel is optimized and parallelized.

\subsection*{Rationale}
The GridTools framework attempts to address issues related to high-level optimizations and the diversity in target platforms by applying abstraction and domain-specific transformations to the user's source code.

Source-to-source compilers provide a practical way of supporting research, development, and deployment of performance-demanding applications on HPC systems.
The transformations ocurring in each of the abstraction layers gradually incorporate knowledge from the problem domain and the target architecture.
This way, the framework is able to automatically optimize the generated code to a level that is beyond the capabilities of modern compilers.
Indeed, existing low-level compilers for languages such as C, C++ or Fortran are not able to provide high-level optimizations to the generated code. 

In a source-to-source approach, and internal representation (IR) is generated by the compiler based on the input source code.
This IR provides the basis of analysis that guides the transformations applied.
The newly generated source code is then compiled by a backend compiler of the subsequent layer, allowing the code to move from one layer of abstraction to the next.

From the software engineering point of view, it is important for complex codes to show a clear separation of concerns.
This is essential in the area of HPC, where the diversity and distinguishing characteristics of different architectures, each imposing its performance constraints, add an additional tier of complexity to the process.
In practical terms, it allows to improve readability and robustness, while increasing productivity by reducing maintainance costs.


\subsection{DSL}
Tackling the ease of development of numerial algorithms, the DSL makes the process of developing a program simpler and more understandable than a DPL.
In resembling a mathematical formulation, it seeks to be a reasonable and easy language for modelers to use.

Its simple implementation, using parsing rules and templates, is mainly possible due to its reduced functionality set.
It also allows the language to evolve separately from the low-level DPL, making it more reliable and maintainable.


\subsection{Python}
Over the past few years, Python has proven to be an attractive choice for the rapid development of simulation codes for scientific computing [ref!].
It combines a high-level scripting language with the strength of object-oriented programming.
One may attribute its popularity to the great number of available libraries available.
In particular, Python has a rich set of libraries for numerical computation, out of which NumPy [ref] and SciPy [ref] emerge as the strongest and most widely used examples.

Also, since Python is intertrepted, it is easier to quickly try various ideas in an interactive manner.
In this sense, tool integration for data IO, visualization and debugging become indispensable during the research and development phases of new algorithms.

Further, the scripting language becomes the common layer between heterogenous libraries.
For instance, different underlying structures of the same concept are presented to the user as a unique structure in this layer, while the implementing functionalities are actually coming from different libraries (e.g., intra-node halo exhanges on GPU and extra-node over MPI???).

\subsection{C++}

\section{Future work}
Let the user experiment and/or create custom execution strategies to investigate different hardware mappings for the target hardware.

\section{TODO}
* What about boundary conditions? How are they implemented/exposed by the C++ API?

\end{document}
