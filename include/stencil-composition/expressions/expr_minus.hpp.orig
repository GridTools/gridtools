namespace gridtools{

    struct tokens{
    static char constexpr par_o[]="(";
    static char constexpr par_c[]=")";
    using  open_par = string_c<print, par_o>;
    using  closed_par = string_c<print, par_c>;
};
    /** \section expressions Expressions Definition
        @{
        This is the base class of a binary expression, containing the instances of the two arguments.
        The expression should be a static constexpr object, instantiated once for all at the beginning of the run.
    */
    template <typename ... Operands>
    struct expr{

        static const ushort_t size=sizeof...(Operands);

        /**@brief generic expression constructor*/
        GT_FUNCTION
        constexpr expr(Operands ... const& operands_)
            :
            m_operands{operands_ ...}
        {}

        template<typename ... Args>
        GT_FUNCTION
        constexpr expr(expr < Args ... > const& other) : m_operands(other.m_operands){}

        boost::fusion::vector<Operands ...> const m_operands;

#ifndef __CUDACC__
    private:
#endif
        /**@brief default empty constructor*/
        GT_FUNCTION
        constexpr expr(){}
    };

    template <typename Arg>
    struct is_binary_expr : boost::mpl::bool_ < Arg::size == 2 > {};


//     template <typename ArgType1>
//     struct unary_expr{
//     /**@brief generic expression constructor*/
//     GT_FUNCTION
//     constexpr unary_expr(ArgType1 const& first_operand)
//         :
//         first_operand{first_operand}
//     {}

//     template<typename Arg1>
//     GT_FUNCTION
//     constexpr unary_expr( unary_expr<Arg1> const& other): first_operand(other.first_operand){}

//     ArgType1 const first_operand;

// #ifndef __CUDACC__
// private:
// #endif
//     /**@brief default empty constructor*/
//     GT_FUNCTION
//     constexpr unary_expr(){}
// };

//     template <typename ArgType1, typename ArgType2, typename ArgType3>
//     struct ternary_expr{

//     /**@brief generic expression constructor*/
//     GT_FUNCTION
//     constexpr ternary_expr(ArgType1 const& first_operand, ArgType2 const& second_operand, ArgType3 const& third_operand)
//         :
//         first_operand{first_operand},
//         second_operand{second_operand},
//         third_operand{third_operand}
//     {}

//         template<typename Arg1, typename Arg2, typename Arg3>
//         GT_FUNCTION
//         constexpr ternary_expr(ternary_expr<Arg1, Arg2, Arg3> const& other) :
//             first_operand(other.first_operand),
//             second_operand(other.second_operand),
//             third_operand(other.third_operand){}

//             ArgType1 const first_operand;
//     ArgType2 const second_operand;
//     ArgType3 const third_operand;
// #ifndef __CUDACC__
// private:
// #endif
//     /**@brief default empty constructor*/
//     GT_FUNCTION
//     constexpr ternary_expr(){}
// };

    template < typename Arg>
    struct is_unary_expr : boost::mpl::bool_ < Arg::size == 1 > {};

    template <typename Arg>
    struct is_expr : boost::mpl::false_ {};

    template <typename ... Args>
    struct is_expr<expr <Args ...> > : boost::mpl::true_ {};


    template <typename Arg>
    struct is_accessor;

    /**
       @namespace expressions
       @brief Overloaded operators
       The algebraic operators are overloaded in order to deal with expressions. To enable these operators the user has to use the namespace expressions.*/
    namespace expressions{

    template<typename Arg1, typename Arg2 >
    using both_arithmetic_types = typename boost::mpl::and_<boost::is_arithmetic<Arg1>, boost::is_arithmetic<Arg2> >::type;

    template<typename Arg1, typename Arg2 >
    using no_expr_types = typename boost::mpl::not_<typename boost::mpl::or_<is_expr<Arg1>, is_expr<Arg2> >::type>::type ;

    template<typename Arg1, typename Arg2 >
    using no_accessor_types = typename boost::mpl::not_<typename boost::mpl::or_<is_accessor<Arg1>, is_accessor<Arg2> >::type>::type ;

    template<typename Arg1, typename Arg2 >
    using no_expr_nor_accessor_types = typename boost::mpl::and_<no_accessor_types<Arg1, Arg2>, no_expr_types<Arg1, Arg2> >::type ;

}//namespace expressions

    /**fwd declaration*/
    template<typename Arg>
    struct expr_derivative;

} //namespace gridtools
#pragma once
/**
   @file
   @brief Definition of the quantities needed for performing computations on the boundary
*/

// [includes]
#include "assembly.hpp"
#include "../functors/bd_assembly_functors.hpp"
// #include "../functors/dg_fluxes.hpp"

/**
   @brief Definition of the quantities needed for performing computations on the boundary

   The following class holds the discretization containers spanning the whole iteration domain, as opposed to
   \ref intrepid.hpp which holds the local elemental quantities.
   NOTE: underlying 3D assumption

*/
template <typename Boundary>
struct bd_assembly {

    // static const int_t n_faces=geo_map::hypercube_t::template n_boundary_w_dim<Boundary::spaceDim>::value;
    using boundary_t = Boundary;
    using bd_cub=typename Boundary::cub;
    // using super = assembly_base<Geometry>;

    using face_normals_type_info=storage_info< layout_tt<3,4,5>, __COUNTER__ >;
    using face_normals_type=storage_t< face_normals_type_info >;
    using storage_type_info=storage_info< layout_tt<3,4>, __COUNTER__ >;
    using storage_type=storage_t< storage_type_info >;
    using jacobian_type_info=storage_info<layout_tt<3,4,5,6>, __COUNTER__ >;
    using jacobian_type=storage_t< jacobian_type_info >;
    using bd_matrix_storage_info_t=storage_info< layout_tt<3,4,5>,  __COUNTER__ >;
    using bd_matrix_type=storage_t< bd_matrix_storage_info_t >;
    using bd_vector_storage_info_t=storage_info< layout_tt<3>,  __COUNTER__ >;//TODO change: iterate on faces
    using bd_vector_type=storage_t< bd_vector_storage_info_t >;

private:
    boundary_t & m_bd_backend;
    jacobian_type_info m_jac_info;
    face_normals_type_info m_normals_info;
    storage_type_info m_bd_measure_info;
    /**overdimensioned. Reduce*/
    bd_matrix_storage_info_t m_bd_storage_info;
    bd_vector_storage_info_t m_flux_info;

    jacobian_type m_bd_jac;
    face_normals_type m_normals;
    storage_type m_bd_measure;
    bd_matrix_type m_bd_mass;
    bd_vector_type m_flux;//flux (not necessary actually...)

public:

    Boundary & bd_backend()  { return m_bd_backend;}
    jacobian_type & bd_jac()  {return m_bd_jac;}
    face_normals_type & normals()  {return m_normals;}
    storage_type & bd_measure()  { return m_bd_measure;}
    bd_matrix_type & bd_mass()  { return m_bd_mass;}
    bd_vector_type & flux()  { return m_flux;}

    typename Boundary::tangent_storage_t const& get_ref_normals() const {return m_bd_backend.ref_normals();}

    bd_assembly( Boundary& bd_backend_,
             // Geometry& fe_backend_,
              uint_t d1, uint_t d2, uint_t d3) :
        m_bd_backend(bd_backend_)
        , m_jac_info(d1, d2, d3, bd_cub::numCubPoints(), 3, 3, bd_backend_.n_boundaries())
        , m_normals_info(d1, d2, d3, bd_cub::numCubPoints(), 3, bd_backend_.n_boundaries())
        , m_bd_measure_info(d1, d2, d3, bd_cub::numCubPoints(), bd_backend_.n_boundaries())
        , m_bd_storage_info(d1,d2,d3,boundary_t::/*bd_*/geo_map::basisCardinality,boundary_t::/*bd_*/geo_map::basisCardinality, 6/*faces*/)//TODO: should be smaller!
        , m_flux_info(d1,d2,d3,boundary_t::/*bd_*/geo_map::basisCardinality)//TODO: should be smaller!
        , m_bd_jac(m_jac_info, 0., "bd jac")
        , m_normals(m_normals_info, 0., "normals")
        , m_bd_measure(m_bd_measure_info, 0., "bd measure")
        , m_bd_mass(m_bd_storage_info, 0., "boundary mass")
        , m_flux(m_flux_info, 0., "flux")
    {}

};


template <typename Boundary, typename ... Rest>
struct domain_type_tuple<bd_assembly<Boundary>,  Rest ... > : domain_type_tuple< Rest ...> {

private:
    using super = domain_type_tuple< Rest ...>;
    using as_t = bd_assembly<Boundary>;
    as_t & m_as;

public:
    template<typename ... Args>
    domain_type_tuple(as_t & as_, Args & ... args_) : super(args_ ...), m_as(as_) {}

    typedef arg<super::size+0, typename as_t::jacobian_type >       p_bd_jac;
    typedef arg<super::size+1, typename as_t::face_normals_type >                   p_normals;
    typedef arg<super::size+2, typename as_t::storage_type >        p_bd_measure;
    typedef arg<super::size+3, typename as_t::boundary_t::weights_storage_t> p_bd_weights;
    typedef arg<super::size+4, typename as_t::boundary_t::tangent_storage_t> p_ref_normals;
    typedef arg<super::size+5, typename as_t::bd_matrix_type> p_bd_mass;
    typedef arg<super::size+6, typename as_t::boundary_t::basis_function_storage_t> p_bd_phi;
    typedef arg<super::size+7, typename as_t::boundary_t::grad_storage_t> p_bd_dphi;
    typedef arg<super::size+8, typename as_t::bd_vector_type> p_flux;
    static const ushort_t size=super::size+9;

    // template <typename ... MPLList>
    // int domain( typename MPLList::storage_type & ...  storages_ )
    // {
    //     typedef typename boost::mpl::vector<MPLList ...>::fuck fuck;
    //     return 0;
    // }


    /**
       @brief adds few extra placeholders<->storages items to the domain_type
    */
    template <typename ... MPLList>
    auto domain(typename boost::remove_reference
                <typename boost::remove_pointer<
                typename MPLList::storage_type>::type>::type & ...  storages_ )
        -> decltype(super::template domain<
                    p_bd_jac
                    , p_normals
                    , p_bd_measure
                    , p_bd_weights
                    , p_ref_normals
                    , p_bd_mass
                    , p_bd_phi
                    , p_bd_dphi
                    , p_flux
                    , typename boost::remove_reference
                    <typename boost::remove_pointer<
                    MPLList>::type>::type ...
                    >( m_as.bd_jac()
                       , m_as.normals()
                       , m_as.bd_measure()
                       , m_as.bd_backend().bd_cub_weights()
                       , m_as.bd_backend().ref_normals()
                       , m_as.bd_mass()
                       , m_as.bd_backend().val()
                       , m_as.bd_backend().grad()
                       , m_as.flux()
                       , storages_ ...
                        ))
    {
        return super::template domain<  p_bd_jac
                                        , p_normals
                                        , p_bd_measure
                                        , p_bd_weights
                                        , p_ref_normals
                                        , p_bd_mass
                                        , p_bd_phi
                                        , p_bd_dphi
                                        , p_flux
                                        , typename boost::remove_reference
                                        <typename boost::remove_pointer<
                                             MPLList>::type>::type ...
                                        >
            ( m_as.bd_jac()
              , m_as.normals()
              , m_as.bd_measure()
              , m_as.bd_backend().bd_cub_weights()
              , m_as.bd_backend().ref_normals()
              , m_as.bd_mass()
              , m_as.bd_backend().val()
              , m_as.bd_backend().grad()
              , m_as.flux()
              , storages_ ...
                );
    }

    template<enumtype::Shape S>
    struct update_bd_jac{
            auto static esf() ->
                decltype(make_esf<functors::update_bd_jac<typename as_t::boundary_t , S> >(typename super::p_grid_points(), p_bd_dphi(), p_bd_jac()))
        {
            return make_esf<functors::update_bd_jac<typename as_t::boundary_t , S> >(typename super::p_grid_points(), p_bd_dphi(), p_bd_jac());
        }
    };

    template<ushort_t Codimension>
    struct measure{
            auto static esf() ->
            decltype(make_esf<functors::measure<typename as_t::boundary_t , Codimension> >(p_bd_jac(), p_bd_measure()))
        {
            return make_esf<functors::measure<typename as_t::boundary_t, Codimension> >(p_bd_jac(),  p_bd_measure());
        }
    };

    struct bd_mass{
            auto static esf() ->
                decltype(make_esf<functors::bd_mass<typename as_t::boundary_t, typename as_t::bd_cub> >(p_bd_measure(), p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass()))
        {
            return make_esf<functors::bd_mass<typename as_t::boundary_t, typename as_t::bd_cub> >(p_bd_measure(), p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass()); //mass
        }
    };

    template<typename Flux >
    struct lax_friedrich {

        template<typename Sol, typename Result>
        auto static esf(Sol, Result) ->
            decltype(make_esf<functors::lax_friedrich<typename as_t::boundary_t, Flux> >(Sol(), Result()))
        {
            return make_esf<functors::lax_friedrich<typename as_t::boundary_t, Flux> >(Sol(), Result()); //mass
        }
    };

};
#pragma once

namespace functors{

    typedef gridtools::interval<gridtools::level<0,-1>, gridtools::level<1,-1> > x_interval;
    typedef gridtools::interval<gridtools::level<0,-2>, gridtools::level<1,1> > axis;

    template <typename FE, typename Cubature>
    struct stiffness {
        using fe=FE;
        using cub=Cubature;

        //![accessors]
        using jac_det =accessor<0, range<0,0,0,0> , 4> const;
        using jac_inv =accessor<1, range<0,0,0,0> , 6> const;
        using weights =accessor<2, range<0,0,0,0> , 3> const;
        using stiff   =accessor<3, range<0,0,0,0> , 5> ;
        using dphi    =accessor<4, range<0,0,0,0> , 3> const;
        using dpsi    =accessor<5, range<0,0,0,0> , 3> const;
        using arg_list= boost::mpl::vector<jac_det, jac_inv, weights, stiff, dphi,dpsi> ;
        //![accessors]

        //![Do_stiffness]
        template <typename Evaluation>
        GT_FUNCTION
        static void Do(Evaluation const & eval, x_interval) {

            uint_t const num_cub_points=eval.get().get_storage_dims(dphi())[1];
            uint_t const basis_cardinality=eval.get().get_storage_dims(dphi())[0];

            //quadrature points dimension
            dimension<4>::Index qp;
            //dimension 'i' in the stiffness matrix
            dimension<5>::Index dimx;
            //dimension 'j' in the stiffness matrix
            dimension<6>::Index dimy;

            //loop on the basis functions
            for(short_t P_i=0; P_i<basis_cardinality; ++P_i) // current dof
            {
                //loop on the test functions
                for(short_t Q_i=0; Q_i<basis_cardinality; ++Q_i)
                {
                    //loop on the cub points
                    for(short_t q=0; q<num_cub_points; ++q){
                        //inner product of the gradients
                        double gradients_inner_product=0.;
                        for(short_t icoor=0; icoor< fe::fe::spaceDim; ++icoor)
                        {
                            gradients_inner_product +=
                                eval((jac_inv(qp+q, dimx+0, dimy+icoor)*!dphi(P_i,q,(uint_t)0)+
                                      jac_inv(qp+q, dimx+1, dimy+icoor)*!dphi(P_i,q,(uint_t)1)+
                                      jac_inv(qp+q, dimx+2, dimy+icoor)*!dphi(P_i,q,(uint_t)2))
                                     *
                                     (jac_inv(qp+q, dimx+0, dimy+icoor)*!dpsi(Q_i,q,(uint_t)0)+
                                      jac_inv(qp+q, dimx+1, dimy+icoor)*!dpsi(Q_i,q,(uint_t)1)+
                                      jac_inv(qp+q, dimx+2, dimy+icoor)*!dpsi(Q_i,q,(uint_t)2)));
                        }
                        //summing up contributions (times the measure and quad weight)
                        eval(stiff(0,0,0,P_i,Q_i)) += gradients_inner_product * eval(jac_det(qp+q)*!weights(q,0,0));
                    }
                }
            }
        }
        //![Do_stiffness]
    };
} //namepsace functors
#pragma once

namespace functors{

    typedef gridtools::interval<gridtools::level<0,-1>, gridtools::level<1,-1> > x_interval;
    typedef gridtools::interval<gridtools::level<0,-2>, gridtools::level<1,1> > axis;

// [integration]
    template <typename FE, typename Cubature>
    struct mass {
        using jac_det =accessor<0, range<0,0,0,0> , 4> const;
        using weights =accessor<1, range<0,0,0,0> , 3> const;
        using phi     =accessor<2, range<0,0,0,0> , 3> const;
        using psi     =accessor<3, range<0,0,0,0> , 3> const;
        using mass_t    =accessor<4, range<0,0,0,0> , 5> ;
        using arg_list= boost::mpl::vector<jac_det, weights, mass_t, phi, psi> ;
        using quad=dimension<4>;

        using fe=FE;
        using cub=Cubature;

        template <typename Evaluation>
        GT_FUNCTION
        static void Do(Evaluation const & eval, x_interval) {

            uint_t const num_cub_points=eval.get().get_storage_dims(phi())[1];
            uint_t const basis_cardinality=eval.get().get_storage_dims(phi())[0];

            quad::Index qp;
            dimension<5>::Index dimx;
            dimension<6>::Index dimy;
            // static int_t dd=fe::hypercube_t::boundary_w_codim<2>::n_points::value;

            //projection of f on a (e.g.) P1 FE space ReferenceFESpace1:
            //loop on quadrature nodes, and on nodes of the P1 element (i,j,k) with i,j,k\in {0,1}
            for(short_t P_i=0; P_i<basis_cardinality; ++P_i) // current dof
            {
                for(short_t Q_i=0; Q_i<basis_cardinality; ++Q_i)
                {//other dofs whose basis function has nonzero support on the element
                    for(short_t q=0; q<num_cub_points; ++q){
                        eval(mass_t(0,0,0,P_i,Q_i))  +=
                            eval(!phi(P_i,q,0)*(!psi(Q_i,q,0))*jac_det(qp+q)*!weights(q,0,0));
                    }
                }
            }
        }
    };
// [integration]
}//namespace functors
#pragma once

namespace functors{

    typedef gridtools::interval<gridtools::level<0,-1>, gridtools::level<1,-1> > x_interval;
    typedef gridtools::interval<gridtools::level<0,-2>, gridtools::level<1,1> > axis;

    template <typename FE, typename Cubature, typename Vec>
    struct advection {
        using fe=FE;
        using cub=Cubature;

        //![accessors]
        using jac_det =accessor<0, range<0,0,0,0> , 4> const;
        using jac_inv =accessor<1, range<0,0,0,0> , 6> const;
        using weights =accessor<2, range<0,0,0,0> , 3> const;
        using dphi    =accessor<3, range<0,0,0,0> , 3> const;
        using psi     =accessor<4, range<0,0,0,0> , 3> const;
        using adv     =accessor<5, range<0,0,0,0> , 5> ;
        using arg_list= boost::mpl::vector<jac_det, jac_inv, weights, adv, dphi, psi> ;
        //![accessors]

        //![Do_advection]
        template <typename Evaluation>
        GT_FUNCTION
        static void Do(Evaluation const & eval, x_interval) {

            uint_t const num_cub_points=eval.get().get_storage_dims(psi())[1];
            uint_t const basis_cardinality=eval.get().get_storage_dims(psi())[0];

            //quadrature points dimension
            dimension<4>::Index qp;
            //dimension 'i' in the advection matrix
            dimension<5>::Index dimx;
            //dimension 'j' in the advection matrix
            dimension<6>::Index dimy;

            //loop on the basis functions
            for(short_t P_i=0; P_i<basis_cardinality; ++P_i) // current dof
            {
                //loop on the test functions
                for(short_t Q_i=0; Q_i<basis_cardinality; ++Q_i)
                {
                    //loop on the cub points
                    for(short_t q=0; q<num_cub_points; ++q){
                        //inner product of the gradients
                        double inner_product=0.;
                        for(short_t icoor=0; icoor< fe::fe::spaceDim; ++icoor)
                        {
                            inner_product +=
                                eval((jac_inv(qp+q, dimx+0, dimy+icoor)*!dphi(P_i,q,(uint_t)0)+
                                      jac_inv(qp+q, dimx+1, dimy+icoor)*!dphi(P_i,q,(uint_t)1)+
                                      jac_inv(qp+q, dimx+2, dimy+icoor)*!dphi(P_i,q,(uint_t)2))
                                     *
                                     (!psi(Q_i,q,(uint_t)2)*Vec::value[icoor]));
                        }
                        //summing up contributions (times the measure and quad weight)
                        eval(adv(0,0,0,P_i,Q_i)) += inner_product * eval(jac_det(qp+q)*!weights(q,0,0));
                    }
                }
            }
        }
        //![Do_advection]
    };
}//namespace functors
/**@file vector of accessors

   used in order to implement vector algebra
*/

namepace gridtools{

    template <typename ... Accessors>
        struct expr_vec() : public expr<Accessors ... > {

    }

}
namespace gridtools{


    /**@brief Expression subrtracting two arguments*/
    template <typename ArgType1, typename ArgType2>
    struct expr_minus : public expr<ArgType1, ArgType2 >{
        typedef expr<ArgType1, ArgType2> super;

        GT_FUNCTION
        constexpr expr_minus(ArgType1 const& first_operand, ArgType2 const& second_operand):super(first_operand, second_operand){}

        template<typename Arg1, typename Arg2>
        GT_FUNCTION
        constexpr expr_minus(expr_minus<Arg1, Arg2> const& other):super(other){}

#ifndef __CUDACC__
    private:
#endif
        GT_FUNCTION
        constexpr expr_minus(){}

#ifndef __CUDACC__
        static char constexpr op[]=" - ";
       using  operation = string_c<Print, op>;
    public:
        //currying and recursion (this gets inherited)
        using to_string = concatenate<tokens::open_par, ArgType1, operation, ArgType2, tokens::closed_par >;
#endif
    };

    namespace expressions{
        /** minus expression*/
        template<typename ArgType1, typename ArgType2,
                 typename boost::disable_if<
                     no_expr_nor_accessor_types< ArgType1, ArgType2 >
                     , int >::type=0 >
        GT_FUNCTION
        constexpr expr_minus<ArgType1, ArgType2 > operator - (ArgType1 arg1, ArgType2 arg2){
            return expr_minus<ArgType1, ArgType2 >(arg1, arg2);}

    namespace evaluation{

        /** minus evaluation*/
        template <typename IterateDomain, typename ArgType1, typename ArgType2>
        GT_FUNCTION
        auto static constexpr value(IterateDomain const& it_domain
                                    , expr_minus<ArgType1, ArgType2> const& arg)
            -> decltype(it_domain(boost::fusion::at_c<0>(arg.m_operands)) - it_domain(boost::fusion::at_c<1>(arg.m_operands))) {
            return it_domain(boost::fusion::at_c<0>(arg.m_operands)) - it_domain(boost::fusion::at_c<1>(arg.m_operands));}


        /** subtract with scalar evaluation*/
        template <typename IterateDomain, typename ArgType1, typename FloatType
                  , typename boost::enable_if<
                        typename boost::is_floating_point<FloatType>::type
                        , int >::type=0
                  >
        GT_FUNCTION
        auto static constexpr value_scalar(IterateDomain const& it_domain
                                           , expr_minus<ArgType1, FloatType> const& arg)
            -> decltype(it_domain(boost::fusion::at_c<0>(arg.m_operands)) - boost::fusion::at_c<1>(arg.m_operands)) {
            return it_domain(boost::fusion::at_c<0>(arg.m_operands)) - boost::fusion::at_c<1>(arg.m_operands);}


        //automatic differentiation
        /** plus derivative evaluation*/
        template <typename IterateDomain, typename ArgType1, typename ArgType2>
        GT_FUNCTION
        auto static constexpr value(IterateDomain const& it_domain
                                    , expr_derivative<expr_minus<ArgType1, ArgType2> > const& arg)
            -> decltype(it_domain(expr_derivative<ArgType1>(boost::fusion::at_c<0>(arg.m_operands))) - it_domain( expr_derivative<ArgType2>(boost::fusion::at_c<1>(arg.m_operands)) ) ) {
            return it_domain(expr_derivative<ArgType1>(boost::fusion::at_c<0>(arg.m_operands))) - it_domain( expr_derivative<ArgType2>(boost::fusion::at_c<1>(arg.m_operands)) );}

        /** sum with scalar evaluation*/
        template <typename IterateDomain, typename ArgType1, typename FloatType
                  , typename boost::enable_if<
                        typename boost::is_floating_point<FloatType>::type
                        , int >::type=0
                  >
        GT_FUNCTION
        auto static constexpr value_scalar(IterateDomain const& it_domain
                                           , expr_derivative<expr_minus<ArgType1, FloatType> > const& arg)
            -> decltype(it_domain(expr_derivative<ArgType1>(boost::fusion::at_c<0>(arg.m_operands)) ) ) {
            return it_domain(expr_derivative<ArgType1>(boost::fusion::at_c<0>(arg.m_operands)) ) ;}

    }//namespace evaluation
    }//namespace expressions

} //namespace gridtools
