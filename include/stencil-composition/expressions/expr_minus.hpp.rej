--- /dev/null
+++ /dev/null
@@ -78,7 +78,4 @@ target_link_libraries(mass_IGA_cuda  ${exe_LIBS} ${INTREPID_LIB} ${TEUCHOS_LIB}
 endif(CUDA_FOUND)

 add_subdirectory( IGA )
-add_subdirectory( numerics )
-add_subdirectory( functors )
-add_subdirectory( examples )
 add_subdirectory( doc )
--- /dev/null
+++ /dev/null
@@ -1,79 +1,47 @@
+
+//this MUST be included before any boost include
+#define FUSION_MAX_VECTOR_SIZE 40
+#define FUSION_MAX_MAP_SIZE FUSION_MAX_VECTOR_SIZE
+#define BOOST_MPL_LIMIT_VECTOR_SIZE FUSION_MAX_VECTOR_SIZE
+#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+
+
 /**
 \file
 */
 #define PEDANTIC_DISABLED
 #define HAVE_INTREPID_DEBUG
 //! [assembly]
-#include "../functors/bd_assembly.hpp"
+#include "../numerics/bd_assembly.hpp"
 //! [assembly]
 // #include "test_dg_flux.hpp"
 #include "../functors/dg_fluxes.hpp"
 #include "../functors/matvec.hpp"

-
-// [boundary integration]
 /**
-   This functor computes an integran over a boundary face
-*/
-
-using namespace expressions;
-template <typename FE, typename BoundaryCubature>
-struct integration {
-    using fe=FE;
-    using bd_cub=BoundaryCubature;
-
-    using jac_det=accessor< 0, range<0,0,0,0>, 5 >;
-    using weights=accessor< 1, range<0,0,0,0>, 3 >;
-    using phi_trace=accessor< 2, range<0,0,0,0>, 3 >;
-    using psi_trace=accessor< 3, range<0,0,0,0>, 3 >;
-    using out=accessor< 4, range<0,0,0,0>, 6 >;
+@brief flux F(u)

-    using arg_list=boost::mpl::vector<jac_det, weights, phi_trace, psi_trace, out> ;
-
-    /** @brief compute the integral on the boundary of a field times the normals
-
-        note that we use here the traces of the basis functions, i.e. the basis functions
-        evaluated on the quadrature points of the boundary faces.
-    */
-    template <typename Evaluation>
-    GT_FUNCTION
-    static void Do(Evaluation const & eval, x_interval) {
-        dimension<4>::Index quad;
-        dimension<4>::Index dofI;
-        dimension<5>::Index dofJ;
-
-        uint_t const num_cub_points=eval.get().get_storage_dims(jac_det())[3];
-        uint_t const basis_cardinality = eval.get().get_storage_dims(phi_trace())[0];
-        uint_t const n_faces = eval.get().get_storage_dims(jac_det())[4];
-
-
-        for(short_t face_=0; face_<n_faces; ++face_) // current dof
-        {
-            //loop on the basis functions (interpolation in the quadrature point)
-            //over the whole basis TODO: can be reduced
-            for(short_t P_i=0; P_i<basis_cardinality; ++P_i) // current dof
-            {
-                for(short_t P_j=0; P_j<basis_cardinality; ++P_j) // current dof
-                {
-                    float_type partial_sum=0.;
-                    for(ushort_t q_=0; q_<num_cub_points; ++q_){
-                        partial_sum += eval(!phi_trace(P_i,q_,face_)*!psi_trace(P_j, q_, face_)*jac_det(quad+q_, dimension<5>(face_)) * !weights(q_));
-                    }
-                    eval(out(dofI+P_i, dofJ+P_j, dimension<6>(face_)))=partial_sum;
-                }
-            }
-        }
-    }
-};
-// [boundary integration]
-
-struct flux{
+in the equation \f$ \frac{\partial u}{\partial t}=F(u) \f$
+*/
+struct flux {
     template<typename Arg>
+    GT_FUNCTION
     constexpr auto operator()(Arg const& arg_) -> decltype((Arg()+Arg())/2.){
+        array<double, 3> v;
         return (arg_+arg_)/2.;
     }
 };

+/**
+@brief advection vector v
+
+*/
+struct advection_vector {
+    static constexpr array<double, 3> value={1.,1.,1.};
+};
+
+constexpr array<double, 3> advection_vector::value;
+
 int main(){
     //![definitions]
     using namespace enumtype;
@@ -91,8 +59,6 @@ int main(){
     fe_.compute(Intrepid::OPERATOR_VALUE);

     //boundary
-    using bd_matrix_storage_info_t=storage_info< layout_tt<3,4,5>,  __COUNTER__ >;
-    using bd_matrix_type=storage_t< bd_matrix_storage_info_t >;
     using bd_cub_t = intrepid::boundary_cub<geo_map, cub::cubDegree>;
     using bd_discr_t = intrepid::boundary_discr<bd_cub_t>;
     bd_cub_t bd_cub_;
@@ -115,6 +81,8 @@ int main(){
     auto d3=1;

     geo_t geo_;
+    geo_.compute(Intrepid::OPERATOR_GRAD);
+    geo_.compute(Intrepid::OPERATOR_VALUE);
     //![as_instantiation]
     //constructing the integration tools on the boundary

@@ -144,31 +112,33 @@ int main(){
     //defining the advection matrix: d1xd2xd3 elements
     matrix_storage_info_t meta_(d1,d2,d3,geo_map::basisCardinality,geo_map::basisCardinality);
     matrix_type advection_(meta_, 0., "advection");
+    matrix_type mass_(meta_, 0., "mass");

-    /**overdimensioned. Reduce*/
-    bd_matrix_storage_info_t bd_meta_(d1,d2,d3,geo_map::basisCardinality,geo_map::basisCardinality, 6/*faces*/);
-    bd_matrix_type bd_mass_(bd_meta_, 0., "mass");
-
-    using vector_storage_info_t=storage_info< layout_tt<3>,  __COUNTER__ >;
+    using vector_storage_info_t=storage_info< layout_tt<3>,  __COUNTER__ >;//TODO change: iterate on faces
     using vector_type=storage_t< vector_storage_info_t >;
+
     vector_storage_info_t vec_meta_(d1,d2,d3,geo_map::basisCardinality);
     vector_type u_(vec_meta_, 2., "u");//initial solution
-    vector_type flux_(vec_meta_, 0., "flux");
-    vector_type result_(vec_meta_, 0., "result");
+    vector_type result_(vec_meta_, 0., "result");//new solution

     //![placeholders]
     // defining the placeholder for the mass
-    typedef arg<domain_tuple_t::size, bd_matrix_type> p_bd_mass;
+    // typedef arg<domain_tuple_t::size, bd_matrix_type> p_bd_mass;
     // defining the placeholder for the local gradient of the element boundary face
-    typedef arg<domain_tuple_t::size+1, bd_discr_t::grad_storage_t> p_bd_dphi;
+    // typedef arg<domain_tuple_t::size+1, bd_discr_t::grad_storage_t> p_bd_dphi;

-    typedef arg<domain_tuple_t::size+2, bd_discr_t::basis_function_storage_t> p_bd_phi;
-    typedef arg<domain_tuple_t::size+3, vector_type> p_u;
-    typedef arg<domain_tuple_t::size+4, vector_type> p_flux;
-    typedef arg<domain_tuple_t::size+5, vector_type> p_result;
+    // typedef arg<domain_tuple_t::size+2, bd_discr_t::basis_function_storage_t> p_bd_phi;
+    typedef arg<domain_tuple_t::size, vector_type> p_u;
+    typedef arg<domain_tuple_t::size+1, vector_type> p_result;
+    typedef arg<domain_tuple_t::size+2, matrix_type> p_mass;
+    typedef arg<domain_tuple_t::size+3, matrix_type> p_advection;
+    typedef arg<domain_tuple_t::size+4, typename geo_t::basis_function_storage_t> p_phi;
+    typedef arg<domain_tuple_t::size+5,  typename geo_t::grad_storage_t> p_dphi;

     // appending the placeholders to the list of placeholders already in place
-    auto domain=domain_tuple_.template domain<p_bd_mass, p_bd_dphi, p_bd_phi, p_u, p_flux, p_result>(bd_mass_, bd_discr_.grad(), bd_discr_.val(), u_,  flux_, result_);
+    auto domain=domain_tuple_.template domain
+        <p_u, p_result , p_mass, p_advection, p_phi, p_dphi>
+        ( u_, result_, mass_, advection_, geo_.val(), geo_.grad());
     //![placeholders]


@@ -185,20 +155,37 @@ int main(){
         make_mss
         (
             execute<forward>()
+
             // boundary fluxes
-            , make_esf<functors::update_bd_jac<bd_discr_t , enumtype::Hexa> >(dt::p_grid_points(), p_bd_dphi(), dt::p_bd_jac())
-            , make_esf<functors::measure<bd_discr_t, 2> >(dt::p_bd_jac(),
-                                                          dt::p_bd_measure())
-            , make_esf<integration<geo_map, bd_cub_t::bd_cub> >(dt::p_bd_measure(), dt::p_bd_weights(), p_bd_phi(), p_bd_phi(), p_bd_mass()) //mass
-            //, make_esf<functors::bassi_rebay<bd_discr_t> >(p_u(), p_u(), p_flux())
-            , make_esf<functors::lax_friedrich<bd_discr_t, flux > >(p_u(), p_u(), p_flux())
-
-            // // Internal element
-            // , make_esf<functors::update_jac<geo_t , enumtype::Hexa> >(as::p_grid_points(), p_dphi(), as::p_jac())
-            // , make_esf<functors::det<geo_t> >(as::p_jac(), as::p_jac_det())
-            // , make_esf<advection<fe> >(as::p_jac_det(), as::p_weight(), p_phi(), p_dphi(), p_advection()) //advection
-            // // integrate the two contributions
-            // , make_esf< integrate >( p_u(), p_flux(), p_bd_mass(), p_advection(), p_result() )
+
+            //computes the jacobian in the boundary points of each element
+            , dt::update_bd_jac<enumtype::Hexa>::esf()
+            //computes the measure of the boundaries with codimension 1 (ok, faces)
+            , dt::measure<1>::esf()
+            //computes the mass on the element boundaries
+            , dt::bd_mass::esf()
+
+            // Internal element
+
+            //compute the Jacobian matrix
+            , dt::update_jac<enumtype::Hexa>::esf()
+            // compute the measure (det(J))
+            , make_esf<functors::det<geo_t> >(dt::p_jac(), dt::p_jac_det())
+            // compute the mass matrix
+            , dt::mass< geo_t, cub >::esf(p_phi(), p_mass()) //mass
+            // compute the advection matrix
+            , dt::advection< geo_t, cub, advection_vector >::esf(p_phi(), p_dphi(), p_advection()) //advection
+
+            // computing flux/discretize
+
+            // compute Lax-Friedrich flux (communication-gather) result=flux;
+            , dt::lax_friedrich<flux>::esf(p_u(), p_result())
+            // result+=M*u
+            , make_esf< functors::matvec >( p_u(), p_mass(), p_result() )
+            // result+=A*u
+            , make_esf< functors::matvec >( p_u(), p_advection(), p_result() )
+            // Optional: assemble the result vector by summing the values on the element boundaries
+            , make_esf< functors::assemble<geo_t, add_functor> >( p_result(), p_result(), p_result() )
             // , make_esf< time_advance >(p_u(), p_result())
             ), domain, coords);

--- /dev/null
+++ /dev/null
@@ -4,7 +4,7 @@
 #define PEDANTIC_DISABLED
 #define HAVE_INTREPID_DEBUG
 //! [assembly]
-#include "../functors/bd_assembly.hpp"
+#include "../numerics/bd_assembly.hpp"
 //! [assembly]
 #include "test_dg_flux.hpp"
 #include "../functors/dg_fluxes.hpp"
@@ -83,8 +83,8 @@ int main(){
     //![boundary]


-    using as=assembly<bd_discr_t, geo_t>;
-
+    using as_base=assembly_base<geo_t>;
+    using as=bd_assembly<bd_discr_t>;

     //![definitions]

@@ -96,7 +96,11 @@ int main(){
     geo_t geo;
     //![as_instantiation]
     //constructing the integration tools on the boundary
+    as_base assembler_base(d1,d2,d3);
     as assembler(bd_discr_,d1,d2,d3);
+
+    using domain_tuple_t=domain_type_tuple<geo_t, bd_discr_t>
+    domain_tuple_t domain_tuple(assembler_base, assembler);
     //![as_instantiation]

     //![grid]
@@ -106,9 +110,9 @@ int main(){
             for (uint_t k=0; k<d3; k++)
                 for (uint_t point=0; point<fe::basisCardinality; point++)
                 {
-                    assembler.grid()( i,  j,  k,  point,  0)= (i + geo.grid()(point, 0));
-                    assembler.grid()( i,  j,  k,  point,  1)= (j + geo.grid()(point, 1));
-                    assembler.grid()( i,  j,  k,  point,  2)= (k + geo.grid()(point, 2));
+                    assembler_base.grid()( i,  j,  k,  point,  0)= (i + geo.grid()(point, 0));
+                    assembler_base.grid()( i,  j,  k,  point,  1)= (j + geo.grid()(point, 1));
+                    assembler_base.grid()( i,  j,  k,  point,  2)= (k + geo.grid()(point, 2));
                 }
     //![grid]

@@ -138,7 +142,7 @@ int main(){
     typedef arg<as::size+6, vector_type> p_integrated_flux;

     // appending the placeholders to the list of placeholders already in place
-    auto domain=assembler.template domain<p_mass, p_bd_dphi, p_bd_phi, p_u, p_jump, p_flux, p_integrated_flux>(mass_, bd_discr_.grad(), bd_discr_.val(), u_, jump_, flux_, integrated_flux_);
+    auto domain=domain_tuple.template domain<p_mass, p_bd_dphi, p_bd_phi, p_u, p_jump, p_flux, p_integrated_flux>(mass_, bd_discr_.grad(), bd_discr_.val(), u_, jump_, flux_, integrated_flux_);
     //![placeholders]


@@ -153,7 +157,7 @@ int main(){
         (
             execute<forward>()
             // evaluate the cell Jacobian matrix on the boundary (given the basis functions derivatives in those points)
-            , make_esf<functors::update_jac<bd_discr_t , enumtype::Hexa> >(as::p_grid_points(), p_bd_dphi(), as::p_bd_jac())
+            , make_esf<functors::update_bd_jac<bd_discr_t , enumtype::Hexa> >(as::p_grid_points(), p_bd_dphi(), as::p_bd_jac())
             // compute the normals on the quad points from the jacobian above (first 2 columns), unnecessary
             , make_esf<functors::compute_face_normals<bd_discr_t> >(as::p_bd_jac(), as::p_ref_normals(), as::p_normals())
             // surface integral:
--- /dev/null
+++ /dev/null
@@ -4,7 +4,7 @@
 #define PEDANTIC_DISABLED
 #define HAVE_INTREPID_DEBUG
 //! [assembly]
-#include "../functors/assembly.hpp"
+#include "../numerics/assembly.hpp"
 //! [assembly]
 #include "gather_reference.hpp"
 #include <tools/verifier.hpp>
--- /dev/null
+++ /dev/null
@@ -3,7 +3,7 @@
 */
 #pragma once
 #define PEDANTIC_DISABLED
-#include "../functors/assembly.hpp"
+#include "../numerics/assembly.hpp"

 // [integration]
 template <typename FE, typename Cubature>
--- /dev/null
+++ /dev/null
@@ -2,7 +2,7 @@
 \file
 */
 #define PEDANTIC_DISABLED
-#include "../functors/assembly.hpp"
+#include "../numerics/assembly.hpp"
 #include "../functors/matvec.hpp"

 namespace functors{
--- /dev/null
+++ /dev/null
@@ -4,7 +4,7 @@
 #pragma once
 #define PEDANTIC_DISABLED
 //! [assembly]
-#include "../functors/assembly.hpp"
+#include "../numerics/assembly.hpp"
 //! [assembly]
 #include "test_assembly.hpp"

--- /dev/null
+++ /dev/null
@@ -1,5 +1,5 @@
 #pragma once
-#include "../functors/assembly.hpp"
+#include "../numerics/assembly.hpp"

 namespace gridtools{
 namespace intrepid{
--- /dev/null
+++ /dev/null
@@ -2,7 +2,7 @@
 \file
 */
 #pragma once
-#include "../functors/bd_assembly.hpp"
+#include "../numerics/bd_assembly.hpp"
 #include <Intrepid_CellTools.hpp>

 namespace gridtools{
--- /dev/null
+++ /dev/null
@@ -48,7 +48,8 @@ namespace functors{
                         eval( jac(dimx+icoor, dimy+jcoor, qp+iter_quad) )=0.;
                                 for (int_t iterNode=0; iterNode < basis_cardinality ; ++iterNode)
                                 {//reduction/gather
-                                    eval( jac(dimx+icoor, dimy+jcoor, qp+iter_quad) ) += eval(grid_points(dimension<4>(iterNode), dimension<5>(icoor)) * !dphi(i+iterNode, j+iter_quad, k+jcoor) );
+                                    eval( jac(dimx+icoor, dimy+jcoor, qp+iter_quad) ) +=
+                                        eval(grid_points(dimension<4>(iterNode), dimension<5>(icoor)) * !dphi(i+iterNode, j+iter_quad, k+jcoor));
                                 }
                     }
                 }
@@ -208,7 +209,7 @@ namespace functors{
             dimension<4>::Index row;


-            //hypothesis here: the cardinaxlity is order^3 (isotropic 3D tensor product element)
+            //hypothesis here: the cardinality is order^3 (isotropic 3D tensor product element)
 #ifdef __CUDACC__
             constexpr meta_storage_base<__COUNTER__,layout_map<0,1,2>,false> indexing{static_int<3>(), static_int<3>(), static_int<3>()};
 #else
--- /dev/null
+++ /dev/null
@@ -1,123 +0,0 @@
-#pragma once
-/**
-   @file
-   @brief Definition of the quantities needed for performing computations on the boundary
-*/
-
-// [includes]
-#include "assembly.hpp"
-#include "bd_assembly_functors.hpp"
-
-/**
-   @brief Definition of the quantities needed for performing computations on the boundary
-
-   The following class holds the discretization containers spanning the whole iteration domain, as opposed to
-   \ref intrepid.hpp which holds the local elemental quantities.
-   NOTE: underlying 3D assumption
-
-*/
-template <typename Boundary>
-struct bd_assembly {
-
-    // static const int_t n_faces=geo_map::hypercube_t::template n_boundary_w_dim<Boundary::spaceDim>::value;
-    using boundary_t = Boundary;
-    using bd_cub=typename Boundary::cub;
-    // using super = assembly_base<Geometry>;
-
-    using face_normals_type_info=storage_info< layout_tt<3,4,5>, __COUNTER__ >;
-    using face_normals_type=storage_t< face_normals_type_info >;
-    using storage_type_info=storage_info< layout_tt<3,4>, __COUNTER__ >;
-    using storage_type=storage_t< storage_type_info >;
-    using jacobian_type_info=storage_info<layout_tt<3,4,5,6>, __COUNTER__ >;
-    using jacobian_type=storage_t< jacobian_type_info >;
-
-private:
-    boundary_t & m_bd_backend;
-    jacobian_type_info m_jac_info;
-    face_normals_type_info m_normals_info;
-    storage_type_info m_bd_measure_info;
-
-    jacobian_type m_bd_jac;
-    face_normals_type m_normals;
-    storage_type m_bd_measure;
-
-public:
-
-    jacobian_type & bd_jac()  {return m_bd_jac;}
-    face_normals_type & normals()  {return m_normals;}
-    storage_type & bd_measure()  { return m_bd_measure;}
-    Boundary & bd_backend()  { return m_bd_backend;}
-
-    typename Boundary::tangent_storage_t const& get_ref_normals() const {return m_bd_backend.ref_normals();}
-
-    bd_assembly( Boundary& bd_backend_,
-             // Geometry& fe_backend_,
-              uint_t d1, uint_t d2, uint_t d3) :
-        m_bd_backend(bd_backend_)
-        , m_jac_info(d1, d2, d3, bd_cub::numCubPoints(), 3, 3, bd_backend_.n_boundaries())
-        , m_normals_info(d1, d2, d3, bd_cub::numCubPoints(), 3, bd_backend_.n_boundaries())
-        , m_bd_measure_info(d1, d2, d3, bd_cub::numCubPoints(), bd_backend_.n_boundaries())
-        , m_bd_jac(m_jac_info, 0., "bd jac")
-        , m_normals(m_normals_info, 0., "normals")
-        , m_bd_measure(m_bd_measure_info, 0., "bd measure")
-        {}
-};
-
-
-template <typename Boundary, typename ... Rest>
-struct domain_type_tuple<bd_assembly<Boundary>,  Rest ... > : domain_type_tuple< Rest ...> {
-
-private:
-    using super = domain_type_tuple< Rest ...>;
-    using as_t = bd_assembly<Boundary>;
-    as_t & m_as;
-
-public:
-    template<typename ... Args>
-    domain_type_tuple(as_t & as_, Args & ... args_) : super(args_ ...), m_as(as_) {}
-
-    typedef arg<super::size+0, typename as_t::jacobian_type >       p_bd_jac;
-    typedef arg<super::size+1, typename as_t::face_normals_type >                   p_normals;
-    typedef arg<super::size+2, typename as_t::storage_type >        p_bd_measure;
-    typedef arg<super::size+3, typename as_t::boundary_t::weights_storage_t> p_bd_weights;
-    typedef arg<super::size+4, typename as_t::boundary_t::tangent_storage_t> p_ref_normals;
-    static const ushort_t size=super::size+5;
-
-
-    /**
-       @brief adds few extra placeholders<->storages items to the domain_type
-     */
-    template <typename ... MPLList>
-    auto domain(typename MPLList::storage_type& ...  storages_ )
-        -> decltype(super::template domain<
-                    p_bd_jac
-                    , p_normals
-                    , p_bd_measure
-                    , p_bd_weights
-                    , p_ref_normals
-                    , MPLList ...
-                    >( m_as.bd_jac()
-                       ,  m_as.normals()
-                       , m_as.bd_measure()
-                       , m_as.bd_backend().bd_cub_weights()
-                       , m_as.bd_backend().ref_normals()
-                       , storages_ ...
-                        ))
-        {
-            return super::template domain<  p_bd_jac
-                                               , p_normals
-                                               , p_bd_measure
-                                               , p_bd_weights
-                                               , p_ref_normals
-                                               ,MPLList ...
-                                               >
-                ( m_as.bd_jac()
-                  , m_as.normals()
-                  , m_as.bd_measure()
-                  , m_as.bd_backend().bd_cub_weights()
-                  , m_as.bd_backend().ref_normals()
-                  , storages_ ...
-                    );
-        }
-
-};
--- /dev/null
+++ /dev/null
@@ -113,6 +113,64 @@ namespace functors{
     // };


+
+// [boundary integration]
+/**
+   This functor computes an integran over a boundary face
+*/
+
+    using namespace expressions;
+    template <typename FE, typename BoundaryCubature>
+    struct bd_mass {
+        using fe=FE;
+        using bd_cub=BoundaryCubature;
+
+        using jac_det=accessor< 0, range<0,0,0,0>, 5 >;
+        using weights=accessor< 1, range<0,0,0,0>, 3 >;
+        using phi_trace=accessor< 2, range<0,0,0,0>, 3 >;
+        using psi_trace=accessor< 3, range<0,0,0,0>, 3 >;
+        using out=accessor< 4, range<0,0,0,0>, 6 >;
+
+        using arg_list=boost::mpl::vector<jac_det, weights, phi_trace, psi_trace, out> ;
+
+        /** @brief compute the integral on the boundary of a field times the normals
+
+            note that we use here the traces of the basis functions, i.e. the basis functions
+            evaluated on the quadrature points of the boundary faces.
+        */
+        template <typename Evaluation>
+        GT_FUNCTION
+        static void Do(Evaluation const & eval, x_interval) {
+            dimension<4>::Index quad;
+            dimension<4>::Index dofI;
+            dimension<5>::Index dofJ;
+
+            uint_t const num_cub_points=eval.get().get_storage_dims(jac_det())[3];
+            uint_t const basis_cardinality = eval.get().get_storage_dims(phi_trace())[0];
+            uint_t const n_faces = eval.get().get_storage_dims(jac_det())[4];
+
+
+            for(short_t face_=0; face_<n_faces; ++face_) // current dof
+            {
+                //loop on the basis functions (interpolation in the quadrature point)
+                //over the whole basis TODO: can be reduced
+                for(short_t P_i=0; P_i<basis_cardinality; ++P_i) // current dof
+                {
+                    for(short_t P_j=0; P_j<basis_cardinality; ++P_j) // current dof
+                    {
+                        float_type partial_sum=0.;
+                        for(ushort_t q_=0; q_<num_cub_points; ++q_){
+                            partial_sum += eval(!phi_trace(P_i,q_,face_)*!psi_trace(P_j, q_, face_)*jac_det(quad+q_, dimension<5>(face_)) * !weights(q_));
+                        }
+                        eval(out(dofI+P_i, dofJ+P_j, dimension<6>(face_)))=partial_sum;
+                    }
+                }
+            }
+        }
+    };
+// [boundary integration]
+
+
     // //! [det]

     template<typename Geometry, ushort_t Codimensoin>
@@ -120,7 +178,7 @@ namespace functors{

     //! [measure]
     template<typename Geometry>
-    struct measure<Geometry, 2>{
+    struct measure<Geometry, 1>{
         using cub=typename Geometry::cub;

         using jac = accessor<0, range<0,0,0,0> , 7> const;
--- /dev/null
+++ /dev/null
@@ -70,10 +70,9 @@ namespace functors{

         using geo_map=typename Geometry::geo_map;

-        using in1=accessor<0, range<> , 4>;
-        using in2=accessor<1, range<> , 4>;
-        using out=accessor<2, range<> , 4> ;
-        using arg_list=boost::mpl::vector<in1, in2, out> ;
+        using in=accessor<0, range<> , 4>;
+        using out=accessor<1, range<> , 4> ;
+        using arg_list=boost::mpl::vector<in, out> ;

         template <typename Evaluation>
         GT_FUNCTION
@@ -105,23 +104,23 @@ namespace functors{
                     auto dof_z=indexing.index(I, J, 0);
                     auto dof_zz=indexing.index(I, J, indexing.template dims<2>()-1);

-                    const auto N=eval.get().get_storage_dims(in1())[3];
+                    const auto N=eval.get().get_storage_dims(in())[3];

                     //initial value
-                    auto c=eval(D(Flux()(in1())));
+                    auto c=eval(D(Flux()(in())));

                     //find the maximum
                     for(ushort_t it_=1; it_<N; ++it_)
-                        c=(c>eval(expressions::D(Flux()(in1(row+it_))))) ? c : eval(D(Flux()(in1(row+it_))));
+                        c=(c>eval(expressions::D(Flux()(in(row+it_))))) ? c : eval(D(Flux()(in(row+it_))));

                     //average the contribution from elem i-1 on the opposite face
-                    eval(out(row+dof_x)) += (eval(Flux()(in1(row+dof_x))+Flux()(in2(i-1, row+dof_xx)))/2. - c*(eval(in1(row+dof_x)) - eval(in2(i-1, row+dof_xx))))/2.;
+                    eval(out(row+dof_x)) += (eval(Flux()(in(row+dof_x))+Flux()(in(i-1, row+dof_xx)))/2. - c*(eval(in(row+dof_x)) - eval(in(i-1, row+dof_xx))))/2.;

                     //average the contribution from elem j-1 on the opposite face
-                    eval(out(row+dof_x)) += (eval(Flux()(in1(row+dof_y))+Flux()(in2(i-1, row+dof_yy))) - c*eval(in1(row+dof_y)) - eval(in2(i-1, row+dof_yy)))/2.;
+                    eval(out(row+dof_x)) += (eval(Flux()(in(row+dof_y))+Flux()(in(i-1, row+dof_yy))) - c*eval(in(row+dof_y)) - eval(in(i-1, row+dof_yy)))/2.;

                     //average the contribution from elem k-1 on the opposite face
-                    eval(out(row+dof_x)) += (eval(Flux()(in1(row+dof_z))+Flux()(in2(i-1, row+dof_zz))) - c*(eval(in1(row+dof_z)) - eval(in2(i-1, row+dof_zz))))/2.;
+                    eval(out(row+dof_x)) += (eval(Flux()(in(row+dof_z))+Flux()(in(i-1, row+dof_zz))) - c*(eval(in(row+dof_z)) - eval(in(i-1, row+dof_zz))))/2.;

                 }
         }
--- /dev/null
+++ /dev/null
@@ -2,7 +2,10 @@

 // [includes]
 #include "assembly_base.hpp"
-#include "assembly_functors.hpp"
+// #include "assembly_functors.hpp"
+// #include "mass.hpp"
+// #include "advection.hpp"
+// #include "stiffness.hpp"
 // [includes]
 #ifdef CXX11_ENABLED

@@ -78,7 +81,7 @@ public:
     jacobian_type & jac_inv() {return m_jac_inv;}
     typename Geometry::weights_storage_t & cub_weights() {return m_fe_backend.cub_weights();}

-// [private members]
+    // [private members]

 }; //struct assembly

@@ -105,39 +108,97 @@ public:
     typedef arg<super::size+1, typename as_t::geometry_t::weights_storage_t >   p_weights;
     typedef arg<super::size+2, typename as_t::storage_type >    p_jac_det;
     typedef arg<super::size+3, typename as_t::jacobian_type >   p_jac_inv;
-    static const uint_t size=super::size+4;
+    typedef arg<super::size+4, typename as_t::geometry_t::basis_function_storage_t> p_phi;
+    typedef arg<super::size+5, typename as_t::geometry_t::grad_storage_t> p_dphi;
+    static const uint_t size=super::size+6;

     /**
        @brief adds few extra placeholders<->storages items to the domain_type
      */
     template <typename ... MPLList>
-    auto domain( typename MPLList::storage_type& ...  storages_
+    auto domain( typename boost::remove_reference
+                <typename boost::remove_pointer<
+                 typename MPLList::storage_type>::type>::type& ...  storages_
         )
         -> decltype(super::template domain<
                      p_jac
                     , p_weights
                     , p_jac_det
-                    , p_jac_inv,
-                    MPLList ...>
+                    , p_jac_inv
+                    , p_phi
+                    , p_dphi
+                    , typename boost::remove_reference
+                    <typename boost::remove_pointer<
+                    MPLList>::type>::type ...
+                    >
                     ( m_as.jac()
                       , m_as.fe_backend().cub_weights()
                       , m_as.jac_det()
                       , m_as.jac_inv()
+                      , m_as.fe_backend().val()
+                      , m_as.fe_backend().grad()
                       , storages_ ...))
         {
             return super::template domain<    p_jac
                                               , p_weights
                                               , p_jac_det
                                               , p_jac_inv
-                                              , MPLList ...
+                                              , p_phi
+                                              , p_dphi
+                                              , typename boost::remove_reference
+                                              <typename boost::remove_pointer<
+                                                   MPLList>::type>::type ...
                                               >
                 ( m_as.jac()
                   , m_as.fe_backend().cub_weights()
                   , m_as.jac_det()
                   , m_as.jac_inv()
+                  , m_as.fe_backend().val()
+                  , m_as.fe_backend().grad()
                   , storages_ ...);
         }

+
+    template<enumtype::Shape S>
+    struct update_jac{
+        auto static esf() ->
+            decltype(make_esf<functors::update_jac<typename as_t::geometry_t , S> >(typename super::p_grid_points(), p_dphi(), p_jac()))
+        {
+            return make_esf<functors::update_jac<typename as_t::geometry_t , S> >(typename super::p_grid_points(), p_dphi(), p_jac());
+        }
+    };
+
+    //TODO: generalize the foillowing functors
+    template <typename FE, typename Cubature>
+    struct mass{
+        template <typename Phi, typename Mass>
+        auto static esf(Phi, Mass) ->
+            decltype(make_esf<functors::mass<FE , Cubature> >(p_jac_det(), p_weights(), Phi(), Phi(), Mass()))
+        {
+            return make_esf<functors::mass<FE , Cubature> >(p_jac_det(), p_weights(), Phi(), Phi(), Mass());
+        }
+    };
+
+    template <typename FE, typename Cubature>
+    struct stiffness{
+        template<typename DPhi, typename Stiff>
+        auto static esf(DPhi, Stiff) ->
+            decltype(make_esf<functors::stiffness<FE , Cubature> >(p_jac_det(), p_jac_inv(), p_weights(), DPhi(), DPhi(), Stiff()))
+        {
+            return make_esf<functors::stiffness<FE , Cubature> >(typename super::p_jac_det(), p_jac_inv(), p_weights(), DPhi(), DPhi(), Stiff());
+        }
+    };
+
+    template <typename FE, typename Cubature, typename Vector>
+    struct advection{
+        template<typename Phi, typename DPhi, typename Adv>
+        auto static esf(Phi, DPhi, Adv) ->
+            decltype(make_esf<functors::advection<FE , Cubature, Vector> >(p_jac_det(), p_jac_inv(), p_weights(), DPhi(), Phi(), Adv()))
+        {
+            return make_esf<functors::advection<FE , Cubature, Vector> >(p_jac_det(), p_jac_inv(), p_weights(), DPhi(), Phi(), Adv());
+        }
+    };
+
 };

 #endif //CXX11_ENABLED
--- /dev/null
+++ /dev/null
@@ -2,8 +2,8 @@

 #include <stencil-composition/make_computation.hpp>
 // [includes]
-#include "../numerics/basis_functions.hpp"
-#include "../numerics/intrepid.hpp"
+#include "basis_functions.hpp"
+#include "intrepid.hpp"
 // [includes]
 #ifdef CXX11_ENABLED

@@ -40,14 +40,32 @@ public:

 }; //struct assembly

-
+//struct definition
 template < typename ... Types >
 struct domain_type_tuple;

-template < typename Geometry >
-struct domain_type_tuple<assembly_base<Geometry> >{
+/**
+    default case: just forwarding the args
+    necessary in order to allow arbitrary order of the template arguments
+ */
+template <>
+struct domain_type_tuple<>{
+
+    static const ushort_t size=0;
+
+    template <typename ... MPLList>
+    gridtools::domain_type< boost::mpl::vector<MPLList ...> >
+    domain(typename MPLList::storage_type& ...  storages_ ){
+        return domain_type<boost::mpl::vector< MPLList ...> >(boost::fusion::make_vector(&storages_ ...));
+    }
+
+};
+
+template < typename Geometry, typename ... Rest >
+struct domain_type_tuple<assembly_base<Geometry>, Rest ... > : domain_type_tuple<Rest ...> {

 private:
+    using super = domain_type_tuple< Rest ...>;
     using as_t = assembly_base<Geometry>;
     as_t & m_as;

@@ -62,9 +80,19 @@ public:
     static const ushort_t size=1;

     template <typename ... MPLList>
-    gridtools::domain_type< boost::mpl::vector<p_grid_points, MPLList ...> >
-    domain(typename MPLList::storage_type& ...  storages_ ){
-        return domain_type<boost::mpl::vector<p_grid_points, MPLList ...> >(boost::fusion::make_vector(&m_as.grid(), &storages_ ...));
+    gridtools::domain_type< boost::mpl::vector<p_grid_points
+                                               , typename boost::remove_reference
+                                               <typename boost::remove_pointer<
+                                                    MPLList>::type>::type ...> >
+    domain(typename boost::remove_reference
+               <typename boost::remove_pointer<
+               typename MPLList::storage_type>::type>::type& ...  storages_ ){
+        return super::template domain<p_grid_points
+                                      , typename boost::remove_reference
+                                      <typename boost::remove_pointer<
+                                           MPLList>::type>::type ...
+                                      >
+            (m_as.grid(), storages_ ...);
     }

 };
--- /dev/null
+++ /dev/null
@@ -15,8 +15,6 @@

 #define REORDER

-// #include "assembly.h"
-
 namespace gridtools{
 namespace intrepid{

@@ -58,28 +56,36 @@ namespace intrepid{
         std::unique_ptr<basis_function_storage_t> m_phi_at_cub_points_s;

         cub_points_storage_t // const
-        & cub_points()// const
-            {return m_cub_points_s;}
-        weights_storage_t // const
-        & cub_weights()// const
+        & cub_points()
+        {return m_cub_points_s;}
+
+        weights_storage_t& cub_weights()// const
             {return m_cub_weights_s;}
-        grad_storage_t // const
-        & grad()// const
-            {return *m_grad_at_cub_points_s;}
+        grad_storage_t& grad()// const
+            {
+                //If this assertion fails most probably you have not called
+                //compute with te OPERATOR_GRAD flag
+                assert(m_grad_at_cub_points_s.get());
+                return *m_grad_at_cub_points_s;
+            }

-        basis_function_storage_t // const
-        & val()// const
-            {return *m_phi_at_cub_points_s;}
+        basis_function_storage_t & val()// const
+            {
+                //If this assertion fails most probably you have not called
+                //compute with te OPERATOR_VALUE flag
+                assert(m_phi_at_cub_points_s.get());
+                return *m_phi_at_cub_points_s;
+            }

         discretization() :
             m_cub_points_s_info(cub::numCubPoints(), fe::spaceDim,1)
             , m_cub_weights_s_info(cub::numCubPoints(),1,1)
-            , m_grad_at_cub_points_s_info()
-            , m_phi_at_cub_points_s_info()
+            , m_grad_at_cub_points_s_info(new grad_storage_t_info())//construct empty
+            , m_phi_at_cub_points_s_info(new basis_function_storage_t_info())//construct empty
             , m_cub_points_s(m_cub_points_s_info, "cub points")
             , m_cub_weights_s(m_cub_weights_s_info, "cub weights")
-            , m_grad_at_cub_points_s()
-            , m_phi_at_cub_points_s()
+            , m_grad_at_cub_points_s(new grad_storage_t(*m_grad_at_cub_points_s_info))//construct empty
+            , m_phi_at_cub_points_s(new basis_function_storage_t(*m_phi_at_cub_points_s_info))//construct empty
             {
             }

--- /dev/null
+++ /dev/null
@@ -10,6 +10,14 @@
 #define CXX11_DISABLED
 #endif

+//this MUST be included before any boost include
+#ifndef FUSION_MAX_VECTOR_SIZE
+    #define FUSION_MAX_VECTOR_SIZE 60
+    #define FUSION_MAX_MAP_SIZE 60
+    #define BOOST_MPL_LIMIT_VECTOR_SIZE FUSION_MAX_VECTOR_SIZE
+    #define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif
+
 //defines how many threads participate to the (shared) memory initialization
 //TODOCOSUNA This IS VERY VERY VERY DANGEROUS HERE
 #define BLOCK_SIZE 32
@@ -28,11 +36,6 @@
 #include <boost/mpl/logical.hpp>
 #include <boost/type_traits.hpp>

-#ifndef FUSION_MAX_VECTOR_SIZE
-    #define FUSION_MAX_VECTOR_SIZE 20
-    #define FUSION_MAX_MAP_SIZE 20
-#endif
-
 #define GT_MAX_ARGS 20
 #define GT_MAX_INDEPENDENT 3
 #define GT_MAX_MSS 10
--- /dev/null
+++ /dev/null
@@ -1,130 +0,0 @@
-namespace gridtools{
-
-    struct tokens{
-    static char constexpr par_o[]="(";
-    static char constexpr par_c[]=")";
-    using  open_par = string_c<print, par_o>;
-    using  closed_par = string_c<print, par_c>;
-};
-    /** \section expressions Expressions Definition
-        @{
-        This is the base class of a binary expression, containing the instances of the two arguments.
-        The expression should be a static constexpr object, instantiated once for all at the beginning of the run.
-    */
-    template <typename ArgType1, typename ArgType2>
-    struct expr{
-
-    /**@brief generic expression constructor*/
-    GT_FUNCTION
-    constexpr expr(ArgType1 boost::fusion::at_c<0>(const&mts)_operand, ArgType2 const& second_operand)
-        :
-        first_operand{first_operand},
-        second_operand{second_operand}
-    {}
-
-        template<typename Arg1, typename Arg2>
-        GT_FUNCTION
-        constexpr expr(expr<Arg1, Arg2> const& other):first_operand(other.first_operand),second_operand(other.second_operand){}
-
-            ArgType1 const first_operand;
-    ArgType2 const second_operand;
-#ifndef __CUDACC__
-private:
-#endif
-    /**@brief default empty constructor*/
-    GT_FUNCTION
-    constexpr expr(){}
-};
-
-    template <typename Arg>
-    struct is_binary_expr : boost::mpl::false_ {};
-
-
-    template <typename ArgType1>
-    struct unary_expr{
-    /**@brief generic expression constructor*/
-    GT_FUNCTION
-    constexpr unary_expr(ArgType1 const& first_operand)
-        :
-        first_operand{first_operand}
-    {}
-
-    template<typename Arg1>
-    GT_FUNCTION
-    constexpr unary_expr( unary_expr<Arg1> const& other): first_operand(other.first_operand){}
-
-    ArgType1 const first_operand;
-
-#ifndef __CUDACC__
-private:
-#endif
-    /**@brief default empty constructor*/
-    GT_FUNCTION
-    constexpr unary_expr(){}
-};
-
-    template <typename ArgType1, typename ArgType2, typename ArgType3>
-    struct ternary_expr{
-
-    /**@brief generic expression constructor*/
-    GT_FUNCTION
-    constexpr ternary_expr(ArgType1 const& first_operand, ArgType2 const& second_operand, ArgType3 const& third_operand)
-        :
-        first_operand{first_operand},
-        second_operand{second_operand},
-        third_operand{third_operand}
-    {}
-
-        template<typename Arg1, typename Arg2, typename Arg3>
-        GT_FUNCTION
-        constexpr ternary_expr(ternary_expr<Arg1, Arg2, Arg3> const& other) :
-            first_operand(other.first_operand),
-            second_operand(other.second_operand),
-            third_operand(other.third_operand){}
-
-            ArgType1 const first_operand;
-    ArgType2 const second_operand;
-    ArgType3 const third_operand;
-#ifndef __CUDACC__
-private:
-#endif
-    /**@brief default empty constructor*/
-    GT_FUNCTION
-    constexpr ternary_expr(){}
-};
-
-    template <typename Arg>
-    struct is_unary_expr : boost::mpl::false_ {};
-
-    template <typename Arg>
-    using is_expr=typename boost::mpl::or_<is_binary_expr<Arg>, is_unary_expr<Arg> >::type;
-
-
-    template <typename Arg>
-    struct is_accessor;
-
-    /**
-       @namespace expressions
-       @brief Overloaded operators
-       The algebraic operators are overloaded in order to deal with expressions. To enable these operators the user has to use the namespace expressions.*/
-    namespace expressions{
-
-    template<typename Arg1, typename Arg2 >
-    using both_arithmetic_types = typename boost::mpl::and_<boost::is_arithmetic<Arg1>, boost::is_arithmetic<Arg2> >::type;
-
-    template<typename Arg1, typename Arg2 >
-    using no_expr_types = typename boost::mpl::not_<typename boost::mpl::or_<is_expr<Arg1>, is_expr<Arg2> >::type>::type ;
-
-    template<typename Arg1, typename Arg2 >
-    using no_accessor_types = typename boost::mpl::not_<typename boost::mpl::or_<is_accessor<Arg1>, is_accessor<Arg2> >::type>::type ;
-
-    template<typename Arg1, typename Arg2 >
-    using no_expr_nor_accessor_types = typename boost::mpl::and_<no_accessor_types<Arg1, Arg2>, no_expr_types<Arg1, Arg2> >::type ;
-
-}//namespace expressions
-
-    /**fwd declaration*/
-    template<typename Arg>
-    struct expr_derivative;
-
-} //namespace gridtools
--- /dev/null
+++ /dev/null
@@ -27,9 +27,6 @@ namespace gridtools{
 #endif
     };

-    template <typename ArgType1, typename ArgType2>
-    struct is_binary_expr<expr_exp<ArgType1, ArgType2> > : boost::mpl::true_ {};
-
     namespace expressions{

         /** power expression*/
--- /dev/null
+++ /dev/null
@@ -17,17 +17,15 @@ namespace gridtools{
         GT_FUNCTION
         constexpr expr_larger(){}
 #ifndef __CUDACC__
+
         static char constexpr op[]=" > ";
-        typedef string_c<print, op> operation;
+        using operation = string_c<Print, op>;
     public:
         //currying and recursion (this gets inherited)
         using to_string = concatenate<tokens::open_par, ArgType1, operation, ArgType2, tokens::closed_par >;
 #endif
     };

-    template <typename ArgType1, typename ArgType2>
-    struct is_binary_expr<expr_larger<ArgType1, ArgType2> > : boost::mpl::true_ {};
-
     namespace expressions{

         /** larger expression*/
--- /dev/null
+++ /dev/null
@@ -25,6 +25,8 @@ namespace gridtools{
 #endif
     };

+
+
     template <typename ArgType1, typename ArgType2>
     struct is_binary_expr<expr_larger_equal<ArgType1, ArgType2> > : boost::mpl::true_ {};

--- /dev/null
+++ /dev/null
@@ -21,17 +21,13 @@ namespace gridtools{

 #ifndef __CUDACC__
         static char constexpr op[]=" - ";
-        typedef string_c<print, op> operation;
+       using  operation = string_c<Print, op>;
     public:
         //currying and recursion (this gets inherited)
         using to_string = concatenate<tokens::open_par, ArgType1, operation, ArgType2, tokens::closed_par >;
 #endif
     };

-    template < typename ArgType1, typename ArgType2>
-    struct is_binary_expr<expr_minus<ArgType1, ArgType2> > : boost::mpl::true_ {
-    };
-
     namespace expressions{
         /** minus expression*/
         template<typename ArgType1, typename ArgType2,
--- /dev/null
+++ /dev/null
@@ -17,16 +17,14 @@ namespace gridtools{
         constexpr expr_or(){}
 #ifndef __CUDACC__
         static char constexpr op[]=" || ";
-        typedef string_c<print, op> operation;
+>
+        using operation=string_c<Print, op>;
     public:
         //currying and recursion (this gets inherited)
         using to_string = concatenate<tokens::open_par, ArgType1, operation, ArgType2, tokens::closed_par >;
 #endif
     };

-    template <typename ArgType1, typename ArgType2>
-    struct is_binary_expr<expr_or<ArgType1, ArgType2> > : boost::mpl::true_ {};
-
     namespace expressions{

         /** and expression*/
--- /dev/null
+++ /dev/null
@@ -105,7 +105,7 @@ namespace gridtools {
             struct apply {
                 typedef typename boost::remove_reference<
                     typename boost::fusion::result_of::at<StorageList, typename ElemType::index_type>::type
-                                                         >::type type;
+                    >::type type;
             };
         };

--- /dev/null
+++ /dev/null
@@ -66,7 +66,7 @@ struct meta_storage_derived : public BaseStorage, clonable_to_gpu<meta_storage_d
         : super(initial_offset_i, initial_offset_j, dim3, n_i_threads, n_j_threads){}
 #endif

-private:
+// private:
     /** @brief empty ctor

         should never be called
--- /dev/null
+++ /dev/null
@@ -333,6 +333,7 @@ namespace gridtools {
         template <typename OffsetTuple, typename StridesVector, typename boost::enable_if<is_arg_tuple<OffsetTuple >, int>::type=0>
         GT_FUNCTION
         static constexpr int_t _index(StridesVector const& RESTRICT strides_, OffsetTuple  const& tuple) {
+            GRIDTOOLS_STATIC_ASSERT(OffsetTuple::n_dim >0 , "The placeholder is most probably not present in the domain_type you are using. Double check that you passed all the placeholders in the domain_type construction");
             GRIDTOOLS_STATIC_ASSERT(is_arg_tuple<OffsetTuple>::type::value, "wrong type");
             return _impl::compute_offset<space_dimensions, layout>::apply(strides_, tuple);
         }
