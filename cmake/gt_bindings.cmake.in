# Create a library with c- and Fortran-bindings
#
# Usage of this module:
#
#  gt_add_bindings_library(<library-name> SOURCES <sources>[...] [FORTRAN_OUTPUT_DIR fortran_dir] [C_OUTPUT_DIR c_dir] [FORTRAN_MODULE_NAME name])
#
#  Arguments:
#   SOURCES: sources of the library
#   FORTRAN_OUTPUT_DIR: destination for generated Fortran files (default: ${CMAKE_CURRENT_LIST_DIR})
#   C_OUTPUT_DIR: destination for generated C files (default: ${CMAKE_CURRENT_LIST_DIR})
#   FORTRAN_MODULE_NAME: name for the Fortran module (default: <library-name>)
#
# Variables used by this module:
#
#  GT_ENABLE_BINDINGS_GENERATION:
#  If GT_ENABLE_BINDINGS_GENERATION=OFF, bindings will not be generated, but expected to be provided,
#  as part of the user source code, e.g. by updating bindings with the bindings generator during development.
#  If GT_ENABLE_BINDINGS_GENERATION is not defined already it will be made available after including this file.
#
# In the default case (GT_ENABLE_BINDINGS_GENERATION=ON), the bindings files are generated in the directory
# where the CMakeLists.txt with the call to gt_add_bindings_library() is located.
#
# Targets generated by gt_add_bindings_library(<library-name> ...):
#  - <library_name> library build from <Sources...> without bindings (ususally this target is not used)
#  - <library_name>_declarations will run the generator for this library
#  - <library_name>_c the C-bindings with <library_name> linked to it
#  - <library_name>_fortran the Fortran-bindings with <library_name> linked to it


option(GT_ENABLE_BINDINGS_GENERATION "If turned off, bindings will not be generated." ON)

set(BINDINGS_SOURCE_DIR @BINDINGS_SOURCE_DIR@)
set(BINDINGS_CMAKE_DIR @BINDINGS_CMAKE_DIR@)

add_library(c_bindings_generator ${BINDINGS_SOURCE_DIR}/c_bindings/generator.cpp)
target_link_libraries(c_bindings_generator GridTools::gridtools)

add_library(c_bindings_handle ${BINDINGS_SOURCE_DIR}/c_bindings/handle.cpp)
target_link_libraries(c_bindings_handle GridTools::gridtools)

# gt_enable_bindings_library_fortran()
#
# Create a target to compile the generated Fortran module.
# In the default case, when Fortran is enabled on the call to gt_add_bindings_library(), this target is automatically created.
# In case when the Fortran language was not enabled, we cannot create a library (add_library()) with Fortran files.
# However if the user wants to use the target at a later stage, e.g. in testing (with Fortran enabled), the target can
# be created by a call to gt_enable_bindings_library_fortran().
macro(gt_enable_bindings_library_fortran target_name)
    if(CMAKE_Fortran_COMPILER_LOADED)
        if(NOT TARGET fortran_bindings_handle)
            add_library(fortran_bindings_handle ${BINDINGS_SOURCE_DIR}/c_bindings/array_descriptor.f90 ${BINDINGS_SOURCE_DIR}/c_bindings/handle.f90)
            target_link_libraries(fortran_bindings_handle PUBLIC c_bindings_handle)
            target_include_directories(fortran_bindings_handle PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
        endif()
        if(NOT TARGET ${target_name}_fortran)
            set_source_files_properties(GT_${${target_name}_fortran_bindings_path} PROPERTIES GENERATED TRUE)
            add_library(${target_name}_fortran EXCLUDE_FROM_ALL ${GT_${target_name}_fortran_bindings_path})
            target_link_libraries(${target_name}_fortran PUBLIC ${target_name})
            target_link_libraries(${target_name}_fortran PUBLIC fortran_bindings_handle)
            target_include_directories(${target_name}_fortran PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
            add_dependencies(${target_name}_fortran ${target_name}_declarations)
        endif()
    elseif(NOT ${ARGN}) # internal: the second (optional) parameter can be used to surpress this fatal error
        message(FATAL_ERROR "Please enable_language(Fortran) to compile the Fortran bindings.")
    endif()
endmacro()

macro(gt_add_bindings_library target_name)
    set(options)
    set(one_value_args FORTRAN_OUTPUT_DIR C_OUTPUT_DIR FORTRAN_MODULE_NAME)
    set(multi_value_args SOURCES)
    cmake_parse_arguments(ARG "${options}" "${one_value_args};" "${multi_value_args}" ${ARGN})

    if(NOT DEFINED ARG_FORTRAN_MODULE_NAME)
        set(ARG_FORTRAN_MODULE_NAME ${target_name}) # default value
    endif()

    if(ARG_C_OUTPUT_DIR)
        set(bindings_c_decl_filename ${ARG_C_OUTPUT_DIR}/${target_name}.h)
    else()
        set(bindings_c_decl_filename ${CMAKE_CURRENT_LIST_DIR}/${target_name}.h) # default value
    endif()
    if(ARG_FORTRAN_OUTPUT_DIR)
        set(bindings_fortran_decl_filename ${ARG_FORTRAN_OUTPUT_DIR}/${target_name}.f90)
    else()
        set(bindings_fortran_decl_filename ${CMAKE_CURRENT_LIST_DIR}/${target_name}.f90) # default value
    endif()

    add_library(${target_name} ${ARG_SOURCES})
    target_link_libraries(${target_name} PRIVATE c_bindings_generator)

    if(GT_ENABLE_BINDINGS_GENERATION)
        # generator
        add_executable(${target_name}_decl_generator
            ${BINDINGS_SOURCE_DIR}/c_bindings/generator_main.cpp)
        set_target_properties(${target_name}_decl_generator PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/decl_generator")
        target_link_libraries(${target_name}_decl_generator c_bindings_generator)

        if (${APPLE})
            target_link_libraries(${target_name}_decl_generator
                -Wl,-force_load ${target_name})
        else()
            target_link_libraries(${target_name}_decl_generator
                -Xlinker --whole-archive ${target_name}
                -Xlinker --no-whole-archive)
        endif()

        add_custom_target(${target_name}_declarations
            ALL
            COMMAND ${CMAKE_COMMAND}
                -DGENERATOR=${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/decl_generator/${target_name}_decl_generator
                -DBINDINGS_C_DECL_FILENAME=${bindings_c_decl_filename}
                -DBINDINGS_FORTRAN_DECL_FILENAME=${bindings_fortran_decl_filename}
                -DFORTRAN_MODULE_NAME=${ARG_FORTRAN_MODULE_NAME}
                -P ${BINDINGS_CMAKE_DIR}/gt_bindings_generate.cmake
            BYPRODUCTS ${bindings_c_decl_filename} ${bindings_fortran_decl_filename}
            DEPENDS $<TARGET_FILE:${target_name}_decl_generator>)
    else()
        if(EXISTS ${bindings_c_decl_filename} AND (EXISTS ${bindings_fortran_decl_filename}))
            add_custom_target(${target_name}_declarations) # noop, the dependencies are satisfied if the files exist
        else()
            message(FATAL_ERROR "Cross-compilation for bindings is enabled: no bindings will be generated, but "
                "${bindings_c_decl_filename} and/or "
                "${bindings_fortran_decl_filename} "
                "are missing. Generate the bindings and consider making them part of your repository.") 
        endif()
    endif()

    # bindings c library
    add_library(${target_name}_c INTERFACE)
    target_link_libraries(${target_name}_c INTERFACE ${target_name})
    target_link_libraries(${target_name}_c INTERFACE c_bindings_handle)
    add_dependencies(${target_name}_c ${target_name}_declarations)

    # bindings Fortran library
    # Export the name of the generated file. The variable needs to exist in the whole cmake!
    # Reason: see description of gt_enable_bindings_library_fortran().
    set(GT_${target_name}_fortran_bindings_path ${bindings_fortran_decl_filename}
        CACHE INTERNAL "Path to the generated Fortran file for ${target_name}")
    gt_enable_bindings_library_fortran(${target_name} TRUE)
endmacro()
