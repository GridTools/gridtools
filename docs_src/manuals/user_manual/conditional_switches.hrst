.. _conditionals:

------------
Conditionals
------------

Conditionals introduce two new syntactic elements in the computation grammar,
namely `if_` and `switch_`.  These implement run-time branches in the
computation tree, i.e. one computation or another can be chosen based on the
value of a runtime variable.  Note that this is just syntactic sugar, as you
could instantiate all the possible combinations of the computation tree and
then choose which one to execute by querying the value of a runtime condition.
This would work in the same way as the solution we will describe next, but it
would create a code of an unmanageable size most of the time: suppose that
inside a computation with 10 stages you want to choose among 5 possible
versions of the last stage. You would have to create 5 different computations,
in which the only difference is in the last stage, while the rest is repeated.
This would be tedious and error-prone.

The syntax we expose for `if_` statements is reported in the following example:

.. code-block:: gridtools

 auto comp = make_computation<backend_t>(
     grid,
     if_([&flag] { return flag; },
         make_multistage(
             execute::forward(),
             make_stage<functor0>(p())
         ),
         make_multistage(
             execute::forward(),
             make_stage<functor1>(p())
         )
     )
 );

The correct way to interpret this syntax is that the call to `if_` returns one
multistage o the other based on the return value of the predicate attached to
`flag`.

The value of the condition is evaluated at every execution of ``comp.run()``.

The conditionals can also be nested:

.. code-block:: gridtools

 auto cond = ...;
 auto cond2 = ...;
 auto comp = make_computation<backend_t>(
     grid,
     if_(cond,
         make_multistage(
             execute::forward(),
             make_stage<functor0>(p())
         ),
         if_(cond2,
             make_multistage(
                 execute::forward(),
                 make_stage<functor1>(p())
             ),
             make_multistage(
                 execute::forward(),
                 make_stage<functor2>(p())
             )
         )
     )
 );


The other syntactic element we introduce is a `switch_`, and its use is
exemplified in the following snippet

.. code-block:: gridtools

 auto cond = [&p]() {
     assert(p >= 0 && p < 3);
     return p;
 };
 auto comp_ = make_computation<backend_t>(
     grid,
     make_multistage(
         execute::parallel(),
         make_stage<functor0>(p_tmp(), p_in()),
     ),
     switch_(cond,
         case_(0,
             make_multistage(execute::forward(),
                 make_stage<functor1>(p_out(), p_tmp()),
             )
         ),
         case_(1,
             make_multistage(execute::forward(),
                 make_stage<functor2>(p_out(), p_tmp())
             )
         ),
         case_(2,
             make_multistage(execute::forward(),
                 make_stage<functor3>(p_out(), p_tmp())
             )
         )
     )
 )

As for the `if_` statement, the condition function is evaluated at every call
to ``comp.run()``, and the multistage executed in calls depends on the value of
the condition.

.. note::

 Also `switch_` can be nested, as the `if_`.

.. note::

 The effect of having different branches is that all the possibilities get
 compiled, and only one gets chosen at each run. Therefore having lot of
 branches can increase dramatically the compilation times, you should not abuse
 of this feature.

.. note::

 Currently there is a limitation. The different branches in the computation
 must use the same placeholders.
