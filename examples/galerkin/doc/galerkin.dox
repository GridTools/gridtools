/*!
\page Galerkin  Galerking Discretization

This and the following examples shows how GridTools implements several flavours of the Galerkin Finite Elements discretization, using tensor product brick elements.

The goal of these examples is to show as a proof of concept the possibility of using a third party library
(in this case the Intrepid packege in Trilinos) with the numerical tools and basic  definitions already in place, in order to build a custom
finite elements assembly of a differential operator using gridtools, thus taking advantage of all the advanced multi-platform
optimizations of the library.

The Intrepid TPL provides the definition of several basis functions, quadrature rules, elemantal operations (e.g. scalar/vector products, curl, gradient, divergence, ...).

\section sec_fe_pb_description Problem Description

Let us describe in detail the problem that we want to solve. We aim at solving integrals of the following type, which come from the variational formulation of a partial differential equation:

\f[
    \int_{\Omega}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega
\f]

where \f$\psi\f$ and \f$\phi\f$ are known functions on the domain \f$\Omega\f$.
In the classical Galerkin methods the domain is split into mesh "elements", and the integral above is computed elementwise, as sum of all the contributions
\f[
    \sum_e\int_{\Omega_e}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega
\f]

The next step of the discretization is the finite elements map to the reference element (an hypercube with coordinates \f$\{(\pm1,0,0...), (0,\pm1,0,...), (0,0,\pm1,...) ...\}\f$): to solve the integral we build a map \f[ x:\mathbb R^n \rightarrow \mathbb R^n \f]
such that \f[ \hat\Omega_e\mapsto\Omega_e, \f] and use this map to perform a change of varialbe in the integral.

The integral above after the change of coordinates becomes

\f[
    \int_{\hat\Omega_e}{\phi(\hat{\mathbf x})\psi(\hat{\mathbf x})J(\hat{\mathbf x})}d\hat\Omega
\f]

where \f[J=\frac{\partial x}{\partial\hat x}\f] is the jacobian of the transformation (a constant in the case in which \f$x\f$ is an affine map).

One main difference between the usual finite-difference stencil-like computations is that we do not iterate over points in the global domain, while now we want to iterate over elements.
To this end we generalize the concept of iteration point to an element by extending the storage dimensionality:
if for the finite difference case we had a 3D storage and we were iterating on i, j, and k, now each (i,j,k) point identifies an element, and the points inside the element will be
accessed using 6 indices (i,j,k,pi,pj,pk) for the point (pi,pj,pk) whithin element (i,j,k).

Alternativey we can address the storage by using only one dimension for all the degrees of freedom inside the element, as it is usually done
in finite elements codes. However using the former layout might allow us in some cases to exploit the hypercubes structure in order to reduce the algorithm complexity, as will become clear later on.

We have, as input, the grid (i.e. the location of the dicretization points in the actual domain), the evaluation of the basis functions computed in the quadrature points in the reference element,
and the evaluation of the geometric map in the same quadrature points.
The integration can be carried out in the following steps (stages)
- compute the jacobian in the quadrature points
- compute the value of the integral locally to each element
- assembly the contribution of the different elements (i.e. sum up the contributions in the nodes which are overlapping between several elements)

Notice that the last point is not necessary if the discrete finite elements space is discontinuous between the elements, since in the latter case there is no overlap between elements.
On the other hand when the finite elements space is piecewise linear across the elements, we have to sum up the contributions on the boundary of the element, and if the continuity degree increases
(\f$\mathcal C^k\f$ continuity across element boundary) the overlap spans several elements.

In the simplistic case of 4 linear quadrilateral elements, as shown in the picture below, we have to merge the 4 quadrilaterals into the one on the right:
\f[
  \fbox{
  \begin{tikzpicture}[shorten >=1pt,auto,node distance=1.5cm,
    thick,main node/.style={circle,fill=blue!40,draw,font=\sffamily\small\bfseries},
    thick,main node2/.style={circle,fill=green!40,draw,font=\sffamily\small\bfseries},
    thick,main node3/.style={circle,fill=cyan!40,draw,font=\sffamily\small\bfseries},
    thick,other node/.style={circle,fill=yellow!40,draw,font=\sffamily\small\bfseries},
    thick,white node/.style={circle,draw,font=\sffamily\small\bfseries}
    ]
  \node[main node] (21) {$e_1$};
  \node[main node] (22) [left of=21] {$e_1$};
  \node[main node] (23) [below of=22] {$e_1$};
  \node[main node] (24) [right of=23] {$e_1$};
  \node[main node2] (2) [right of=21] {$e_2$};
  \node[main node2] (1) [right of=2] {$e_2$};
  \node[main node2] (3) [below of=2] {$e_2$};
  \node[main node2] (4) [right of=3] {$e_2$};
  \node[other node] (5) [below of=4] {$e_4$};
  \node[other node] (6) [left of=5] {$e_4$};
  \node[other node] (7) [below of=6] {$e_4$};
  \node[other node] (8) [right of=7] {$e_4$};
  \node[main node3] (31) [left of=6] {$e_3$};
  \node[main node3] (32) [left of=31] {$e_3$};
  \node[main node3] (33) [below of=32] {$e_3$};
  \node[main node3] (34) [right of=33] {$e_3$};
  \node[main node3] (9) [below right of=4] {$e_{13}$};
  \node[other node] (10) [right of=9] {$e_{1234}$};
  \node[main node] (11) [below right of=1] {$e_{1}$};
  \node[white node] (12) [below right of=5] {$e_{3}$};
  \node[main node2] (13) [right of=11] {$e_{12}$};
  \node[white node] (14) [right of=12] {$e_{34}$};
  \node[white node] (15) [right of=14] {$e_{4}$};
  \node[white node] (16) [right of=10] {$e_{24}$};
  \node[white node] (17) [right of=13] {$e_2$};
  \path[every node/.style={font=\sffamily\small}]
  (1) edge node [left] {} (4)
  (2) edge node [right] {} (1)
  (3) edge node [right] {} (2)
  (4) edge node [left] {} (3)
  (5) edge node [left] {} (8)
  (6) edge node [right] {} (5)
  (7) edge node [right] {} (6)
  (8) edge node [left] {} (7)
  (22) edge node {} (21)
  (22) edge node {} (23)
  (23) edge node {} (24)
  (24) edge node {} (21)
  (32) edge node {} (31)
  (32) edge node {} (33)
  (33) edge node {} (34)
  (34) edge node {} (31)
  (17) edge node {} (13)
  (16) edge node {} (10)
  (17) edge node {} (16)
  (16) edge node {} (15);
  \path[every node/.style={font=\sffamily\small}]
  (11) edge node {} (9)
  (12) edge node {} (9)
  (10) edge  node {} (13)
  (10) edge node {} (14)
  (9) edge  node {} (10)
  (11) edge node {} (13)
  (12) edge  node {} (14)
  (14) edge  node {} (15) ;
\end{tikzpicture}
}\f]
where the pedix index represents the elements which contributed to the value on the node.

The operation performed is a reduction of k values, where k is the number of elements sharing the same point, as shown schematically in the next picture
\f[
\fbox{
\newcommand\crule[3][black]{\textcolor{#1}{\rule{#2}{#3}}}
  \begin{tikzpicture}[shorten >=1pt,auto,node distance=1.5cm,
    thick,main node/.style={font=\sffamily\small\bfseries}
    ]
  \node[main node] (1) {\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (2) [right of=1] {\crule{10pt}{10pt}};
  \node[main node] (3) [below of=1]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (4) [right of=3] {\crule{10pt}{10pt}};
  \node[main node] (5) [below of=3]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (6) [right of=5] {\crule{10pt}{10pt}};
  \node[main node] (7) [below of=5]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (8) [right of=7] {\crule{10pt}{10pt}};
  \draw[in=90, out=90] ([xshift=-15pt]1.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=-5pt]3.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=5pt]5.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=15pt]7.north) to node [below] {} (2) ;
  \end{tikzpicture} }
\f]


\section sec_structure Structure of the code

The Galerkin discretization infrastructure is implemented in several files:
- \ref element_traits.hpp "element_traits.hpp" defines the mapping between the GridTools and Intrepid interfaces.
- \ref basis_functions.hpp "basis_functions.hpp" contains the definition of a reference element, which is univocally
  determined by three template arguments:
  - the order of the basis defined on this element
  - the type of the basis (e.g. Lagrange, Raviart-Thomas, Nedelec, BDM, ...)
  - the shape of the element (e.g. Hexahedron, Quadrilateral, Line, ...)

  This structure is used to define the discretization of both the geometric map
  (reference to current configuration) and of the solution. So we can in principle
  use arbitrary elements types with arbitrary geometric maps, as long as the element shape is
  the same.
- \ref cubature.hpp contains the definition of the cubature rule, i.e. the points and weights
  which are used for the numerical computation on an integral on the reference element. The
  cubature rule is univocally defined by specifying its order and \ref gridtools::reference_element::shape "shape" as template arguments.
- \ref intrepid.hpp is responsible for computing the elemental quantities used in the assembly.
  It defines two structure:
  - the \ref gridtools::intrepid::discretization "discretization", which contains the basis
    function and local information concerning the finite elements discretization of the solution
  - the \ref gridtools::intrepid::geometry "geometry", which derives from the discretization,
    contains basis functions and local information used for the interpolation of the grid points in
    the current configuration, and additionally it contains the coordinates of the
    element nodes in the reference domain (the "local grid").

- \ref assembly.hpp contains the part of the assembly which is common to all the Galerkin
  discretizations, and thus hidden from the user code. This part is responsible for computing all the
  quanties needed for performing an integral on the current domain configuration, namely the
  jacobian of the geometric map (i.e. the map of an element from the reference configuration to the
  current one), its determinant, and its inverse. This structure thus depends exclusively on the
  geometric map, and not on the finite elements used for the discretization of the fields.


  \subpage Laplace

  \subpage Gather

  \subpage DG

*/
