/*!
\page Galerkin  Galerking Discretization of a Laplace Operator

This example shows how GridTools implements the Galerkin Finite Elements discretization, using tensor product brick elements.

The goal of this example is to show as a proof of concept the possibility of using a third party library
(in this case the Intrepid packege in Trilinos) with the numerical tools and basic  definitions already in place, in order to build a custom
finite elements assembly of a differential operator using gridtools, thus taking advantage of all the advanced multi-platform
optimizations of the library.

The Intrepid TPL provides the definition of several basis functions, quadrature rules, elemantal operations (e.g. scalar/vector products, curl, gradient, divergence, ...).

\section sec_fe_pb_description Problem Description

Let us describe in detail the problem that we want to solve. We aim at solving integrals of the following type, which come from the variational formulation of a partial differential equation:

\f[
    \int_{\Omega}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega
\f]

where \f$\psi\f$ and \f$\phi\f$ are known functions on the domain \f$\Omega\f$.
In the classical Galerkin methods the domain is split into mesh "elements", and the integral above is computed elementwise, as sum of all the contributions
\f[
    \sum_e\int_{\Omega_e}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega
\f]

The next step of the discretization is the finite elements map to the reference element (an hypercube with coordinates \f$\{(\pm1,0,0...), (0,\pm1,0,...), (0,0,\pm1,...) ...\}\f$): to solve the integral we build a map \f[ x:\mathbb R^n \rightarrow \mathbb R^n \f]
such that \f[ \hat\Omega_e\mapsto\Omega_e, \f] and use this map to perform a change of varialbe in the integral.

The integral above after the change of coordinates becomes

\f[
    \int_{\hat\Omega_e}{\phi(\hat{\mathbf x})\psi(\hat{\mathbf x})J(\hat{\mathbf x})}d\hat\Omega
\f]

where \f[J=\frac{\partial x}{\partial\hat x}\f] is the jacobian of the transformation (a constant in the case in which \f$x\f$ is an affine map).

One main difference between the usual finite-difference stencil-like computations is that we do not iterate over points in the global domain, while now we want to iterate over elements.
To this end we generalize the concept of iteration point to an element by extending the storage dimensionality:
if for the finite difference case we had a 3D storage and we were iterating on i, j, and k, now each (i,j,k) point identifies an element, and the points inside the element will be
accessed using 6 indices (i,j,k,pi,pj,pk) for the point (pi,pj,pk) whithin element (i,j,k).

Notice that we could have extended the storage by only one dimension containing all the degrees of freedom inside the element, as it is usually done
in finite elements codes. However using this layout allows us to exploit the hypercubes structure in order to reduce the algorithm complexity, as will become clear later on.

We have, as input, the grid (i.e. the location of the dicretization points in the actual domain), the evaluation of the basis functions computed in the quadrature points in the reference element,
and the evaluation of the geometric map in the same quadrature points.
The integration can be carried out in the following steps (stages)
- compute the jacobian in the quadrature points
- compute the value of the integral locally to each element
- assembly the contribution of the different elements (i.e. sum up the contributions in the nodes which are overlapping between several elements)

Notice that the last point is not necessary if the discrete finite elements space is discontinuous between the elements, since in the latter case there is no overlap between elements.
On the other hand when the finite elements space is piecewise linear across the elements, we have to sum up the contributions on the boundary of the element, and if the continuity degree increases
(\f$\mathcal C^k\f$ continuity across element boundary) the overlap spans several elements.

In the simplistic case of 4 linear quadrilateral elements, as shown in the picture below, we have to merge the 4 quadrilaterals into the one on the right:
\f[
  \fbox{
  \begin{tikzpicture}[shorten >=1pt,auto,node distance=1.5cm,
    thick,main node/.style={circle,fill=blue!40,draw,font=\sffamily\small\bfseries},
    thick,main node2/.style={circle,fill=green!40,draw,font=\sffamily\small\bfseries},
    thick,main node3/.style={circle,fill=cyan!40,draw,font=\sffamily\small\bfseries},
    thick,other node/.style={circle,fill=yellow!40,draw,font=\sffamily\small\bfseries},
    thick,white node/.style={circle,draw,font=\sffamily\small\bfseries}
    ]
  \node[main node] (21) {$e_1$};
  \node[main node] (22) [left of=21] {$e_1$};
  \node[main node] (23) [below of=22] {$e_1$};
  \node[main node] (24) [right of=23] {$e_1$};
  \node[main node2] (2) [right of=21] {$e_2$};
  \node[main node2] (1) [right of=2] {$e_2$};
  \node[main node2] (3) [below of=2] {$e_2$};
  \node[main node2] (4) [right of=3] {$e_2$};
  \node[other node] (5) [below of=4] {$e_4$};
  \node[other node] (6) [left of=5] {$e_4$};
  \node[other node] (7) [below of=6] {$e_4$};
  \node[other node] (8) [right of=7] {$e_4$};
  \node[main node3] (31) [left of=6] {$e_3$};
  \node[main node3] (32) [left of=31] {$e_3$};
  \node[main node3] (33) [below of=32] {$e_3$};
  \node[main node3] (34) [right of=33] {$e_3$};
  \node[main node3] (9) [below right of=4] {$e_{13}$};
  \node[other node] (10) [right of=9] {$e_{1234}$};
  \node[main node] (11) [below right of=1] {$e_{1}$};
  \node[white node] (12) [below right of=5] {$e_{3}$};
  \node[main node2] (13) [right of=11] {$e_{12}$};
  \node[white node] (14) [right of=12] {$e_{34}$};
  \node[white node] (15) [right of=14] {$e_{4}$};
  \node[white node] (16) [right of=10] {$e_{24}$};
  \node[white node] (17) [right of=13] {$e_2$};
  \path[every node/.style={font=\sffamily\small}]
  (1) edge node [left] {} (4)
  (2) edge node [right] {} (1)
  (3) edge node [right] {} (2)
  (4) edge node [left] {} (3)
  (5) edge node [left] {} (8)
  (6) edge node [right] {} (5)
  (7) edge node [right] {} (6)
  (8) edge node [left] {} (7)
  (22) edge node {} (21)
  (22) edge node {} (23)
  (23) edge node {} (24)
  (24) edge node {} (21)
  (32) edge node {} (31)
  (32) edge node {} (33)
  (33) edge node {} (34)
  (34) edge node {} (31)
  (17) edge node {} (13)
  (16) edge node {} (10)
  (17) edge node {} (16)
  (16) edge node {} (15);
  \path[every node/.style={font=\sffamily\small}]
  (11) edge node {} (9)
  (12) edge node {} (9)
  (10) edge  node {} (13)
  (10) edge node {} (14)
  (9) edge  node {} (10)
  (11) edge node {} (13)
  (12) edge  node {} (14)
  (14) edge  node {} (15) ;
\end{tikzpicture}
}\f]
where the pedix index represents the elements which contributed to the value on the node.

The operation performed is a reduction of k values, where k is the number of elements sharing the same point, as shown schematically in the next picture
\f[
\fbox{
\newcommand\crule[3][black]{\textcolor{#1}{\rule{#2}{#3}}}
  \begin{tikzpicture}[shorten >=1pt,auto,node distance=1.5cm,
    thick,main node/.style={font=\sffamily\small\bfseries}
    ]
  \node[main node] (1) {\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (2) [right of=1] {\crule{10pt}{10pt}};
  \node[main node] (3) [below of=1]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (4) [right of=3] {\crule{10pt}{10pt}};
  \node[main node] (5) [below of=3]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (6) [right of=5] {\crule{10pt}{10pt}};
  \node[main node] (7) [below of=5]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}};
  \node[main node] (8) [right of=7] {\crule{10pt}{10pt}};
  \draw[in=90, out=90] ([xshift=-15pt]1.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=-5pt]3.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=5pt]5.north) to node [below] {} (2) ;
  \draw[in=-90, out=90] ([xshift=15pt]7.north) to node [below] {} (2) ;
  \end{tikzpicture} }
\f]


\section sec_structure Structure of the code

The Galerkin discretization infrastructure is implemented in several files:
- \ref element_traits.h defines the mapping between the GridTools and Intrepid interfaces.
- \ref basis_functions.h basis_functions.h contains the definition of a reference element, which is univocally
  determined by three template arguments:
  - the order of the basis defined on this element
  - the type of the basis (e.g. Lagrange, Raviart-Thomas, Nedelec, BDM, ...)
  - the shape of the element (e.g. Hexahedron, Quadrilateral, Line, ...)

  This structure is used to define the discretization of both the geometric map
  (reference to current configuration) and of the solution. So we can in principle
  use arbitrary elements types with arbitrary geometric maps, as long as the element shape is
  the same.
- \ref cubature.h contains the definition of the cubature rule, i.e. the points and weights
  which are used for the numerical computation on an integral on the reference element. The
  cubature rule is univocally defined by specifying its order and \ref gridtools::reference_element::shape "shape" as template arguments.
- \ref intrepid.h is responsible for computing the elemental quantities used in the assembly.
  It defines two structure:
  - the \ref gridtools::intrepid::discretization "discretization", which contains the basis
    function and local information concerning the finite elements discretization of the solution
  - the \ref gridtools::intrepid::geometry "geometry", which derives from the discretization,
    contains basis functions and local information used for the interpolation of the grid points in
    the current configuration, and additionally it contains the coordinates of the
    element nodes in the reference domain (the "local grid").

- \ref assembly.h "assembly.h" contains the part of the assembly which is common to all the Galerkin
  discretizations, and thus hidden from the user code. This part is responsible for computing all the
  quanties needed for performing an integral on the current domain configuration, namely the
  jacobian of the geometric map (i.e. the map of an element from the reference configuration to the
  current one), its determinant, and its inverse. This structure thus depends exclusively on the
  geometric map, and not on the finite elements used for the discretization of the fields.

With all this machinery in place we can easily implement a finite element discretization
of an arbitrary equation. The following files provide an example of how the user code would look like:
- \ref mass.cpp "mass.cpp" assembly of a mass matrix
- \ref stiffness.cpp "stiffness.cpp" assembly of a Laplacian

\section sec_code Code Step by Step

We present in what follows the user interface implemented in the file
\ref gridtools::stiffness.cpp "stiffness.cpp", explaining the syntax and the emphasyzing the
flexibility of the programming model.

As usual in GridTools the user program is split in two part:
- One defining the kernel functors, which can be arranged in a tree-like structure expressing
  the dependencies, and are executed on the backend (device).
- One implementing the main function, executing on the frontend (host), preparing and managing the
  resourses and the kernel launches.

\subsection ssec_device Device

We begin by describing the first part, in which we implement the main kernel functor. As mentioned in
the above section, the standard machinery needed to compute the standard finite elements integrals
(i.e. the Jacobian, its determinant and its inverse) is
implemented already the library, precisely in the file \ref assembly.h "assembly.h",
which is included here.

The remaining part is the computation of the discretized stiffness matrix.
This computation is performed by means of the following functor

\snippet galerkin/stiffness.cpp integration
which computes the following local integral
\f[ \int_{\hat\Omega} (J^{-1}\nabla\phi) \cdot (J^{-1}\nabla\psi) |J|\;d{\hat\Omega} .\f]

The input arguments to this functor (i.e. the \ref gridtools::accessor "accessors"), are listed in the snippet below
\snippet galerkin/stiffness.cpp accessors
and represent in order the Jacobian determinant, the Jacobian inverse matrix, the quardature weights, the output stiffness matrix,
the local gradient of the basis function computed in the cubature points, and the gradient of the test function computed
in the cubature points. These arguments are gouped as usual in the MPL vector \ref stiffness::arg_list arg_list.

After the arguments definition the Do method is defined as usual, and the innermost loop of the matrix assembly
is directly exposed in the user code.
\snippet galerkin/stiffness.cpp Do_stiffness

\subsection ssec_host Host

Let us describe now the part which is concerning the host, which starts with few useful type definitions
\snippet galerkin/stiffness.cpp definitions
Here we define the type of storage where the stiffness matrix will be allocated (matrix_type). It consists of a 5D storage, since the first 3
dimensions identify an element, the 4th identifies a specific degree of freedom in the element, and the last dimension spans the
space dimensionality.

The second and third type definitions (fe and geo_map) are used by the user to select the discretization used for the solution and for
the interpolation of the domain. In this case we use Lagrange polynomial of order one for both, just to keep things simple. The three template
arguments specified are:
  - the order of the basis (determining the number of degrees of freedom and the accuracy)
  - \ref gridtools::enumtype::Basis "the type of the basis"
  - \ref gridtools::enumtype::Shape "the shape of the elemental cell"

In the next line we define the \ref gridtools::cubature "cubature", giving as first template argument the minimum polynomial order that we want it to integrate exactly,
while the second template argument is the shape type.

Then the types geo_t and discr_t are the structures responsible of computing all the local contributions to the assembly, such as derivatives of the
basis functions evaluated in the quadrature points.

The last definition is an alias for the \ref assembly "assembly infrastructure", which is responsible for computing the Jacobian-related quantities and
thus only depends on the geometric map.

We proceed with the instantiation of the instances of type geo_t and discr_t, and specify which operation are to be computed on the basis functions
(the possible values are OPERATOR_GRAD, OPERATOR_VALUE, OPERATOR_DIV, OPERATOR_CURL, or OPERATOR_DN where N is a number from 1 to 10).
\snippet galerkin/stiffness.cpp instantiation
The line
\verbation
geo.compute(Intrepid::OPERATOR_GRAD);
\endverbatim
is added by default and can therefore be omitted.
We instantiate also the assembler
\snippet galerkin/stiffness.cpp instantiation

In the following snippet we compute a equispaced cartesian grid, which would be substituted by user provided grids in the applications.
\snippet galerkin/stiffness.cpp grid

We then proceed with the instantiation and initialization of the stiffness matrix
\snippet galerkin/stiffness.cpp instantiation_stiffness

We remark here that one could easily define and instantiate with the same strategy all the needed tools to perform integrals on the elements boundary.
This can be achieved in the following snippet
\snippet galerkin/stiffness.cpp boundary

The following part consists in the usual placeholders definitions
\snippet galerkin/stiffness.cpp placeholders
We remark that instead of creating an instance of \ref gridtools::domain_type "domain_type" as usually done in GridTools, we call the method
\ref assembly::domain "assembly::domain" which appends the user defined placeholders to those already defined by the assembler.

The description of the computation defines a series of kernel functors depending one on each other
\snippet galerkin/stiffness.cpp computation
\ref assembly::update_jac "update_jac", \ref assembly::det "det", and  \ref assembly::inv "inv" are
provided by the assembly infrastructure, while the stiffness functor is the one we described in the previous section.

*/
