.. _concepts:

=========
Concepts
=========

---------------
Basic concepts
---------------

.. glossary::

  `IterationPoint`: 
     A tuple of indices. 

     .. note:: Usually generated by the backend

  `IterationSpace` 
     A set `IterationPoint` s. An `IterationSpace` can be *tagged*, which means that the set of IterationPoints can be partitioned into sub-sets each of which associated with a tag. The tags are compile time *names* of the sub-iteration spaces that will be used to dispatch the proper computation in the right sub-set of the iteration space. In GridTools the iteration spaces are three-dimensional, so the IterationPoints are made of tuples of three elements.

  `ExecutionOrder` 
    A partial order on an iteration space. This will be specified with keywords, like `forward`, `backward`, `parallel` that represent the *attributes* of the `ExecutionOrder` according to GridTools execution model (2 Dims are always parallel and the third may be sequential).

  `LocationType` 
    A set of points called Locations (see the note below). Locations are associated with `IterationPoints` and unique integer IDs (*Note*: usually through affine isomorphism), not necessarily contiguous. `LocationTypes` specifies the interfaces to refer to `Locations`, usually using `LocationID operator()(...)`, which takes `IterationPoints` and returns Location IDs. The map between IDs and `IterationPoints` is bijective. 
    .. note::
    The Location concept is not defined explicitly, and in many ways they are never really constructed. 
    A LocationType represents the different entities of grid, for instance an edge, a vertex, and a center of a cell. 
    The Locations are the actual edges, vertices, and centers.

  `GridTopology` 
    A data structure representing the discretized (geometric) domain. A `Grid` will contain multiple `LocationType`s, and the `GridTopology` specifies the connectivity between `IterationPoint`'s of different `LocationType`'s (*Note*: Not all the mapping are necessary/needed, it depends on the operations requested by the application).

  `Grid` 
    Given size information and `GridTopology`, a `Grid` provides the loop bounds for the executing a computation on specific `LocationType` 's.

    .. note:: 
      For example an iteration on the `LocationType` `edges` has different bounds than one on `vertices`.

  `LayoutMap`
    A (compile time) sequence of `N` integer values from `-1` to `k <= N-1`. It is used to indicate the order of the dimensions in a affine-layout multidimensional array. A value `j` in position `i` indicates that dimension `i` has the `j`th stride (all ordinals and indices are 0-based) when strides are listed in descending order. A value of `-1` indicates that the dimension has a special treatment: any index used to access an element in that dimension and any size associated to it is ignored, and the associated stride is `0`. 

    .. note::
      This can be used to implement logical fields that are constant along certain directions, or to implement lower dimensional arrays that have to be _oriented_ with respect to a coordinate systems. A dimension with `-1` is called either _killed_, _masked_ or _ghost_.

  `StorageInfo` 
    This concept describes the dimensions, alignment and layout of a multidimensional array (the layout is assumed to be affine).

  `DataStore`
    Manages a logical array of values (*Note*: The values will be associated to locations of a specific location type `data_store` is created for). A `DataStore` is associated to a `StorageInfo`. A `DataStore` manages multiple address spaces and keeps track of the consistency of it (WE WOULD NEED TO DISCUSS WHAT KIND OF CONSISTENCY WE HAVE) (for instance keeping the state of a GPU storage), thus allowing the user to avoid common pitfalls when dealing with synchronization issues and the GridTools library to manage automatically the storage consistency. `DataStore` s are shallow copied, following a `shared pointer` semantics.

  `DataStoreList` 
    A fixed length cyclic list of `DataStore`s with the same `StorageInfo`. Each element of the list may be referred to as `Snapshot`. A `StorageList` supports random access to the elements and shift_fwd and shift_bwd operations. A `DataStore` can be seen as a trivial `DataStoreList` with a single element. An element of a `DataStoreList` is also called `Snapshot`, since the concept is often used to keep solution of stencil applications in different time-steps.

    .. note::
      `DataStoreList` s are never directly handled by the user. This is an intermediate concept to introduce the `DataStoreField`.

  `Snapshot` 
    Each element of a `DataStoreList`

  `DataStoreField`
    A fixed length sequence of `DataStoreList`s or `DataStore`s, all associated to the same `StorageInfo`. Each element of the sequence is also called *component*

  `StorageView`
    A `storage_view` class allows to access and modify the elements of a `DataStore` through tuple of indices. A `storage_view` can access the data in a specific address space managed by a `DataStore`. For instance, for a GPU enabled `DataStore`, a `storage_view` can be constructed to access data on the host, and another one to access data from the GPU, but not both simultaneously.

  `Extent`
    A class matching the Extent concept is specifying the size and shape of a neighborhood

  `DataFieldAccessor`
    An object with an interface to access one element of a data field and its neighbors. A data field may have multiple accessors with different interfaces. Depending on the Grid, the interface may comprise ways to access neighbors in other `LocationType` s.

  `AccessorPack`
    (from the C++ standard use of "parameter pack") A list of `DataFieldAccessor` s.

  `Splitter` 
    (See [[Splitters]]) A `Splitter` serves to split cells in two subsets. A splitter has an integer index.

  `Level`
    (See [[Splitters]]) A `Level` plus an integer value different than '0' indicating a cell around a `Splitter`.

  `Intereval`
    (See [[Splitters]]) A pair of `Level` s

  `Axis`
    (See [[Splitters]]) A `Level` that includes all the `Interval` s in a given computation.

  `OperatorFunction`
    A decorated class, also referred to as functor (improperly so), which provides `apply` methods each  accepting two arguments: an template argument matching an `AccessorPack` and an `Interval`. The `Interval`s of the different `apply` overloads must define a contiguous and not overlapping `Axis`.

    .. note:: 
      The named accessors are not strictly necessary for the `OperatorFunction` to be well defined, they are useful shortcuts and they define mnemonics.
      The OperatorFunction is executed by calling a `static void void apply(...)` method. This was necessary in pre-C++11 versions, but now we can depart 
      from requiring `static` (even though it may be useful to enforce it to prevent stateful classes).

  `DataFieldPack` 
    An sequence of references to `DataField` s.

  `Placeholder` 
  `BoundOperator`
    The association of an `OperatorFunction` to placeholders.

  `MultiStageComputation`
    A multi-stage computation is a partial order (DAG) on `BoundOperator`s associated with an `ExecutionOrder`.

  `Computation`
    A sequence of `MutliStageComputations` associated with a `Grid`.

    .. note::
      The `Computation` deduces the `IterationSpace` from the `Grid` and the `ExecutionOrder` defined in the `MultiStageCompuptation`. 
      The `Interval` s from the `OperatorFunction` s from which the `MultiStageComputation` is composed are taken into accoun to select the proper 
      overloads of the `apply` member functions. The data is taken from the `DataFieldAggregator` and the `Placeholder` s. 
      This specifies all the information needed to execute the computation.

---------------
Refinement
---------------

`StructuredGrid`: `Grid`

`IcosahedralGrid`: `Grid`

`StructuredOperator`: `OperatorFuncion`

`StructuredExtent`: `Extent`

`UnstructuredExtent`: `Extent`

