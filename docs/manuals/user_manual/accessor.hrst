Accessors
========================

------------------------
 Regular Accessors
------------------------

Regular accessors are proxy objects
used to access data fields
with any dimension. The access is performed by
specifying increments (offsets) with respect to
the current position of the stencil (iteration point).

As described in the :ref:`storage-module` documentation,
a data field can be a contiguous array
with arbitrary dimension, a vector of multidimensional arrays,
or a kind of `matrix` of multidimensional
arrays (possibly with empty elements).
In order to avoid ambiguities we called
[Space Dimension](space dimension) the dimension of each
multidimensional array (or `snapshot`),
and [Field Dimension](field dimensions) the dimensions identifying
the position of the snapshot inside the
vector (or matrix). Since the field dimensions are at most two,
we will identify them as `component dimension`
and `snapshot dimension`, in line with their most intuitive use case,
i.e. a vector representation of a time discretization.

.. todo::
 this needs reformulation

We introduce the ``accessors``
syntax with progressively more complex examples
to explain how the different dimensions can be accessed.

^^^^^^^^^^^^^^^^^^^
Space Dimensions
^^^^^^^^^^^^^^^^^^^

Let's start with an arbitrary dimensional array
(a single :term:`snapshot<snapshot>`). The API exposed is very intuitive.
Suppose you have as first argument of the functor a
5 (space) dimensional snapshot as an input with null extent called ``acc``.
Then the accessor to use is the following:

.. code-block:: gridtools

 using acc = accessor<0, enumtype::in, extent<>, 5>;

We can access the 2 extra dimensions by specifying all the offsets

.. code-block:: gridtools

 acc(0, 0, -1, 2, 2)

We can also assign a name to a dimension, and increment it
using the following syntax, where we ignore the first two ```0``` s:

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k - 1, c + 2, t + 2)


In the latter API the order of the arguments is irrelevant

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k - 1, t + 2, c + 2) == acc(c + 2, k - 1, t + 2)

Note that the second notation may greatly improve the readability of the
user functor body by exposing a matlab-like API, especially when high
dimensionality is used.

^^^^^^^^^^^^^^^^^^^^^
Field Dimensions
^^^^^^^^^^^^^^^^^^^^^

Specifying an offset for a field dimension works exactly as for the
space dimension. So there is no way to distinguish the two only based
on the user functor. Whether we are accessing a space dimension or a field
dimension will depend only on the storage type which will be bound to the
accessor, and not on the accessor itself. So in the example

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k - 1, c + 2, t + 2)

``c + 2`` may refer to an offset to the 4th dimension or the third components (the indices are
zero based) of a vector field, while ``t + 2`` may refer to the third snapshot of that component.
Alternatively, if the storage passed in had 4 space dimensions, the ``t + 2`` would have
indicated the third component.

^^^^^^^^^^^^^^^^^^
Accessor Alias
^^^^^^^^^^^^^^^^^^

An accessor alias is a regular accessor which has an offset set at compile-time.
For instance, say you have a vector field in :math:`R^3` with components h, v, w.
This vector field is accessed via an accessor called ```vec```

.. code-block:: gridtools

 using vec = accessor<0, enumtype::in, extent<>, 4>;

However you may want to be able to refer to the third element of the vector
with ```w``` sometimes
in some expressions. You can do this defining an alias to the third component
of the accessor:

.. code-block:: gridtools

 using w = alias<vec, dimension<4>>::set<2>;

The line above sets at compile-time the fourth offset to the value 2, so that we have
the following equivalency:

.. code-block:: gridtools

 w() == vec(0, 0, 0, 2)

which may contribute to considerably lighten the notation in complicated expressions.
Note that you can still access the other dimensions with an offset, by using the alias. So that

.. code-block:: gridtools

 dimension<1> i;
 dimension<4> q;
 w(i + 1) == vel(i + 1, q + 2)


^^^^^^^^^^^^^^^^^^
Expressions
^^^^^^^^^^^^^^^^^^

The `apply`-method example provided in :ref:`stencil-operator-example` showed the basic syntax to access data.

.. code-block:: gridtools

 template <typename Evaluation>
 GT_FUNCTION static void apply(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0)) - eval(lap(0, 0, 0));
     if (eval(out()) * (eval(in(1, 0, 0)) - eval(in(0, 0, 0))) > 0) {
         eval(out()) = 0.;
     }
 }


We can notice that the ``eval`` keyword is repeated several times, which is somehow
tedious, especially when the expression is complicated it becomes quickly very hard to read.
It is possible to embed the expressions in a single eval, i.e.

.. code-block:: gridtools

 using namespace expressions;
 template <typename Evaluation>
 GT_FUNCTION static void apply(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
     if (eval(out() * (in(1, 0, 0) - in(0, 0, 0)) > 0) {
         eval(out()) = 0.;
     }
 }

This is achieved by using the expressions namespace, in which the operations ```+```, ```-```,
```*```, ```/```, ```pow<2>``` are
overloaded, and generate an expression to be evaluated. An example of its
usage, demonstrating its effectiveness, can be found in the
shallow water example.

.. todo::
 add reference to shallow water

It is possible also to instantiate a compile time expression to be lazily evaluated,
useful for instance if we want to evaluate it multiple times

.. code-block:: gridtools

 using namespace expressions;
 constexpr auto cond = out() * (in(1, 0, 0) - in(0, 0, 0);
 template <typename Evaluation>
 GT_FUNCTION static void apply(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
     if (eval(cond) > 0) {
         eval(out()) = 0.;
     }
 }

.. _global-accessor:

----------------------------------------------------
Global Parameters and Accessors
----------------------------------------------------

Global accessors are accessing read-only data which is independent of the current iteration point.
For this reason, intent, extents and offsets cannot be specified for a global accessor.
Here the term `global` means that the data is the same for the whole grid. An example can be
a constant scalar parameter that you want to pass to the functor, or a user defined struct containing
various configuration options.

The API allows the user to define an arbitrary object to act as a `global parameter` as long as it is trivially copyable.
To create a global parameter from a user-defined object, we pass the object to ``make_global_parameter()``

.. code-block:: gridtools

   auto my_global_parameter = backend_t::make_global_parameter(my_object);

Note that the object is read-only only during the execution of a computation, but can be modified
in between executions with

.. code-block:: gridtools

   backend_t::update_global_parameter(my_global_parameter, new_value);

The accessor associated with a global parameter must be a `global accessor`

.. code-block:: gridtools

    using global_acc = global_accessor<0>;

Calling ``eval`` on the global accessor returns the user defined data structure. Supposing that
this data structure contains a user function called ``ordinal``, returning an integer, we can write
in the do method

.. code-block:: gridtools

    auto ordinal_ = eval(global_boundary()).ordinal();

.. note::
 All the member functions defined in the user-defined
 data structure must be labeled with GT_FUNCTION, in
 order for them to be callable from devices.

There is a special case for which we have a dedicated API: i.e. when the user defined object
(the global parameter)
defines the parenthesis operator ``operator()``, and we want to call that operator from the `apply`-method.
In that case the accessor's parenthesis operator can be used and the arguments will be
automatically forwarded to the global parameter. An example is the case in which we want to pass
a small matrix as a global parameter:

.. code-block:: gridtools

    using matrix = global_accessor<0>;
    auto elem = eval(matrix(i, j));

A useful example to understand this use case can be found in the extended4D example.

.. todo::

 add reference
