Accessors
========================

------------------------
 Regular Accessors
------------------------

Regular accessors are proxy objects
used to access data fields
with any dimension. The access is performed by
specifying increments (offsets) with respect to
the current position of the stencil (iteration point).

As described in the :ref:`storage-module` documentation,
a data field can be a contiguous array
with arbitrary dimension, a vector of multidimensional arrays,
or a kind of `matrix` of multidimensional
arrays (possibly with empty elements).
In order to avoid ambiguities we called
[Space Dimension](space dimension) the dimension of each
multidimensional array (or `snapshot`),
and [Field Dimension](field dimensions) the dimensions identifying
the position of the snapshot inside the
vector (or matrix). Since the field dimensions are atmost two,
we will identify them as `component dimension`
and `snapshot dimension`, in line with their most intuitive use case,
i.e. a vector representation of a time discretization.

.. todo:: 
 this needs reformulation

We introduce the ``accessors``
syntax with progressively more complex examples
to explain how the different dimensions can be accessed.

^^^^^^^^^^^^^^^^^^^
Space Dimensions
^^^^^^^^^^^^^^^^^^^

Let's start with an arbitrary dimensional array
(a single :term:`snapshot<snapshot>`). The API exposed is very intuitive.
Suppose you have as first argument of the functor a
5 (space) dimentional snapshot as an input with null extent called ``acc``.
Then the accessor to use is the following:

.. code-block:: gridtools

 using acc = accessor<0, enumtype::in, extent<>, 5>;

We can access the 2 extra dimensions by specifying all the offsets

.. code-block:: gridtools

 acc(0,0,-1,2,2)

We can also assign a name to a dimension, and increment it
using the following syntax, where we ignore the first two ```0``` s:

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k-1, c+2, t+2)


In the latter API the order of the arguments is irrelevant

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k-1, t+2, c+2) == acc(c+2, k-1, t+2)

Note that the second notation may greatly improve the readibility of the
user functor body by exposing a matlab-like API, especially when high
dimensionality is used.

^^^^^^^^^^^^^^^^^^^^^
Field Dimensions
^^^^^^^^^^^^^^^^^^^^^

Specifying an offset for a field dimension works exactly as for the
space dimension. So there is no way to distinguish the two only based
on the user functor. Whether we are accessing a space dimension or a field
dimension will depend only on the storage type which will be bound to the
accessor, and not on the accessor itself. So in the example

.. code-block:: gridtools

 dimension<3> k; dimension<4> c; dimension<5> t;
 acc(k-1, c+2, t+2)

 #ifdef 
 #define

``c+2`` may refer to an offset to the 4th dimension or the third components (the indices are
zero based) of a vector field, while ``t+2`` may refer to the third snapshot of that component.
Alternatively, if the storage passed in had 4 space dimensions, the ``t+2`` would have
indicated the third component.

^^^^^^^^^^^^^^^^^^
Accessor Alias
^^^^^^^^^^^^^^^^^^

An accessor alias is a regular accessor which has an offset set at compile-time.
For instance, say you have a vector field in :math:`R^3` with components h, v, w.
This vector field is accessed via an accessor called ```vec```

.. code-block:: gridtools

 using vec = accessor<0, enumtype::in, extent<>, 4>;

However you may want to be able to refer to the third element of the vector
with ```w``` sometimes
in some expressions. You can do this defining an alias to the third component
of the accessor:

.. code-block:: gridtools

 using w = alias<vec, dimension<4> >::set<2>;

The line above sets at compile-time the fourth offset to the value 2, so that we have
the following equivalency:

.. code-block:: gridtools

 w() == vec(0,0,0,2)

which may contribute to considerably lighten the notation in complicated expressions.
Note that you can still access the other dimensions with an offset, by using the alias. So that

.. code-block:: gridtools

 dimension<1> i;
 dimension<4> q;
 w(i+1) == vel(i+1, q+2)


^^^^^^^^^^^^^^^^^^
Expressions
^^^^^^^^^^^^^^^^^^

The Do method example provided in :ref:`stencil-operator-example` showed the basic syntax to access data.

.. code-block:: gridtools

 template < typename Evaluation >
 GT_FUNCTION static void Do(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0)) - eval(lap(0, 0, 0));
     if (eval(out()) * (eval(in(1, 0, 0)) - eval(in(0, 0, 0))) > 0) {
         eval(out()) = 0.;
     }
 }


We can notice that the ``eval`` keyword is repeated several times, which is somehow
tedious, especially when the expression is complicated it becaomes quickly very hard to read.
It is possible to embed the expressions in a single eval, i.e.

.. code-block:: gridtools

 using namespace expressions;
 template < typename Evaluation >
 GT_FUNCTION static void Do(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
     if (eval(out() * (in(1, 0, 0) - in(0, 0, 0)) > 0) {
         eval(out()) = 0.;
     }
 }

This is achieved by using the expressions namespace, in which the operations ```+```, ```-```,
```*```, ```/```, ```pow<2>``` are
overloaded, and generate an expression to be evaluated. An example of its
usage, demonstrating its effectiveness, can be found in the
shallow water example.

.. todo::
 add reference to shallow water

It is possible also to instantiate a compile time expression to be lazily evaluated,
useful for instance if we want to evaluate it multiple times

.. code-block:: gridtools

 using namespace expressions;
 constexpr auto cond = out() * (in(1, 0, 0) - in(0, 0, 0);
 template < typename Evaluation >
 GT_FUNCTION static void Do(Evaluation &eval) {
     eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
     if (eval(cond) > 0) {
         eval(out()) = 0.;
     }
 }

-------------------------
Vector Accessors
-------------------------

Vector accessors are used when dealing with
:ref:`expandable_parameters`,
which are sequences of storages on which we want to perform the same
operations. They implement a "single stencil multiple storages" pattern,
as if the same stencil was applied to all the elements of the vector concurrently.

This `loop` or `vector operation` is completely abstracted away from the API of the
user function. The user has to define a ``vector_accessor`` as if it was a regular
accessor, and the corresponding stencil will be executed multiple times, each time
considering different elements in the vector.

.. note::
 If multiple vector accessors are used in the same
 stage, the corresponding expandable parameters
 storage vectors must have the same length

.. note:: 

 We can mix vector accessors with regular accessors.
 In that case the regular accessor will be the same for
 all the stage invocations, while the vector accessor
 will iterate over its components.

For an example of usage of the vector accessor see the Advection Pdbott example:

.. todo::
 add reference

------------------------------
Global Accessors
------------------------------

Global accessors are accessing read-only data which is independent of the current iteration point.
For this reason [Intent](intents), [Extent](extents) and [Offset](offsets) cannot be specified for a global accessor.
Here the term "global" means that the data is the same for the whole grid. An example can be
a constant scalar parameter that you want to pass to the functor, or a user defined struct containing
various configuration options.

The API allows the user to define an arbitrary object deriving from [Global Parameter](global parameter), and pass it
to the computation. The accessor associated with this global parameter must be a global accessor

.. code-block:: gridtools

    using global_accessor< 0 > global_boundary;

Calling ``eval`` on the global accessor returns the user defined data structure. Supposing that
this data structure contains a user function called ```ordinal``` returning an integer, we can write
in the do method

.. code-block:: gridtools

    auto ordinal_ = eval(global_boundary()).ordinal();

.. note:: 
 All the member functions defined in the user-defined
 data structure must be labeled with GT_FUNCTION, in
 order for them to be callable from devices.

There is a special case for which we have a dedicated API: i.e. when the user defined object
(the global parameter)
defines parenthesis operator ``operator()``, and we want to call that operator from the Do method.
In that case the accessor's parenthesis operator can be used and the arguments will be
automatically forwarded to the global parameter. An example is the case in which we want to pass
a small matrix as a global parameter:

.. code-block:: gridtools

    using global_accessor< 0 > matrix;
    auto elem = eval(matrix(i,j));

A useful example to understand this use case can be found in the extended4D example.

.. todo:: 
 
 add reference

