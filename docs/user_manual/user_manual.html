

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>User Manual &mdash; GridTools 0.22.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/css/cscs.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GridTools 0.22.0 documentation" href="../index.html"/>
        <link rel="next" title="Glossary" href="../glossary/glossary.html"/>
        <link rel="prev" title="Getting Started" href="../getting_started/getting_started.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> GridTools
          

          
            
            <img src="../_static/logo.svg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.22
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#storage-module">Storage Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#storage-info">Storage Info</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-store">Data Store</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-view">Data View</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stencil-operators">Stencil Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#accessor-type">Accessor Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessor-aliases">Accessor Aliases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-list">Parameter list</a></li>
<li class="toctree-l3"><a class="reference internal" href="#apply-method"><cite>Apply</cite>-Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expressions">Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#execution-model">Execution Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#access-restrictions">Access restrictions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stencil-composition">Stencil Composition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preparing-arguments-storage-placeholders">Preparing Arguments: Storage Placeholders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-the-iteration-space-the-grid">Defining the Iteration Space: the Grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-regions-and-vertical-boundary-conditions">Vertical Regions and Vertical Boundary Conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-interval">Default Interval</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-vertical-intervals">Defining Vertical Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-functionality-for-vertical-intervals">Advanced Functionality for Vertical Intervals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-stencils">Composition of Stencils</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selecting-the-backend">Selecting the Backend</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-functionality">Advanced Functionality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stencil-functions">Stencil Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-calls-call">Function Calls: <cite>call&lt;&gt;</cite></a></li>
<li class="toctree-l4"><a class="reference internal" href="#procedure-calls-call-proc">Procedure Calls: <cite>call_proc&lt;&gt;</cite></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#software-managed-caches">Software-Managed Caches</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cache-type">Cache Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cache-policy">Cache Policy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#expandable-parameters">Expandable Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-parameters-and-accessors">Global Parameters and Accessors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preliminaries">Preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-condition-class">Boundary Condition Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-condition-application">Boundary Condition Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-predication">Boundary Predication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#provided-boundary-conditions">Provided Boundary Conditions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#halo-exchanges">Halo Exchanges</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id17">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">Preliminaries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#processor-grid">Processor Grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#layout-map">Layout Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#halo-descriptor">Halo Descriptor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gcl-communication-module">GCL Communication Module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#distributed-boundary-conditions">Distributed Boundary Conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-principles">Design Principles:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#communication-traits">Communication Traits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binding-boundaries-and-communication">Binding Boundaries and Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributed-boundaries">Distributed Boundaries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interfacing-to-other-programming-languages">Interfacing to other programming languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exporting-functions-with-no-array-type-arguments">Exporting functions with no array-type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-types">Complex types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exporting-functions-with-array-type-arguments-to-fortran">Exporting functions with array-type arguments to Fortran</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cmake-usage">CMake usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/internal.html">Internal Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GridTools</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>User Manual</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/user_manual.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-manual">
<span id="id1"></span><h1>User Manual<a class="headerlink" href="#user-manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="storage-module">
<span id="id2"></span><h2>Storage Module<a class="headerlink" href="#storage-module" title="Permalink to this headline">¶</a></h2>
<p>The storage module is one of the main modules in <cite>GridTools</cite>. The main target of this module is to provide proper means to access,
view, and modify data. The detail of the hardware is hidden to the user, but the user is responsible for indicating what
storage is needed. Different <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backends</span></a> are available for different kinds of storages, see
<a class="reference internal" href="#backend-selection"><span class="std std-ref">Selecting the Backend</span></a>. Following subsections will explain the different basic elements that are used in the storage
module.</p>
<p>The storage has the notion of <code class="docutils literal"><span class="pre">halo</span></code>. This in turns allows the user of the storage to distinguish between the compute
domain and the full domain, where the latter includes the halos. The halo is symmetric in the storage class, that is,
the number of halo points at the two ends of a dimension is the same. Different dimensions may have different numbers of
halo points. The main reason for including halos in the storage is to enforce the alignment of the storage in the inner
region to improve the performance of stencil operations.</p>
<div class="section" id="storage-info">
<span id="id3"></span><h3>Storage Info<a class="headerlink" href="#storage-info" title="Permalink to this headline">¶</a></h3>
<p>The storage info can be seen as a meta data object that keeps information about a storage. This information is alignment,
data layout in memory, halo areas, dimensionality, size of the storage, etc.  The object must be created before storage
can be allocated. The storage info object can be shared among different storages, if they have the same meta data. The
right storage info type can be retrieved with <code class="docutils literal"><span class="pre">storage_traits&lt;Backend&gt;</span></code>. The supported backends are described
in <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backends</span></a>.</p>
<p>As an example, we can retrieve the default three-dimensional storage info type with size 10 x 10 x 10 for the CUDA
backend, with no halos and identifier <cite>0</cite> as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/storage/storage_traits_cuda.hpp&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">gridtools</span><span class="p">;</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span> <span class="c1">// or gt::target::mc or gt::target::x86</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">select_storage_info</span><span class="o">&lt;</span><span class="mi">0</span> <span class="cm">/* id */</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/* dims */</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="n">si</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
</pre></div>
</div>
<p>Be aware that the identifier used in <cite>select_storage_info</cite> must uniquely determine the type of the storage info and the
actual instantiation with sizes.</p>
<p>The traits class has several ways how a storage info type can be inferred:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">select_storage_info&lt;Id,</span> <span class="pre">Dims,</span> <span class="pre">gt::halo&lt;...&gt;&gt;</span></code> returns the default storage info for a certain backend.</li>
<li><code class="docutils literal"><span class="pre">select_custom_layout_storage_info&lt;Id,</span> <span class="pre">gt::layout&lt;...&gt;,</span> <span class="pre">gt::halo&lt;...&gt;&gt;</span></code> lets you specify the exact layout map (see
below) of the storage. Keep in mind that the default layout should have best performance on the target architecture.</li>
<li><code class="docutils literal"><span class="pre">select_special_storage_info&lt;Id,</span> <span class="pre">gt::selector&lt;...&gt;,</span> <span class="pre">gt::halo&lt;...&gt;&gt;</span></code> lets you select a default storage info
for a certain backend, but you can mask certain dimensions. For example <code class="docutils literal"><span class="pre">gt::selector&lt;0,</span> <span class="pre">0,</span> <span class="pre">1&gt;</span></code> will result in a
three-dimensional storage where all dimensions except in k-direction are masked. The layout will be optimized for the
chosen backend.</li>
<li><code class="docutils literal"><span class="pre">select_storage_info_align&lt;Id,</span> <span class="pre">Dims,</span> <span class="pre">gt::halo&lt;...&gt;,</span> <span class="pre">Alignment&gt;</span></code> lets you select a default storage info for a
certain backend, but with a non-default alignment requirement.</li>
<li><code class="docutils literal"><span class="pre">select_custom_layout_storage_info_align&lt;Id,</span> <span class="pre">gt::layout&lt;...&gt;,</span> <span class="pre">gt::halo&lt;...&gt;,</span> <span class="pre">Alignment&gt;</span></code> lets you specify
the exact layout of the storage and the alignment requirement.</li>
<li><code class="docutils literal"><span class="pre">select_special_storage_info_align&lt;Id,</span> <span class="pre">gt::selector&lt;...&gt;,</span> <span class="pre">gt::halo&lt;...&gt;,</span> <span class="pre">Alignment&gt;</span></code> lets you mask certain
dimensions and you can specify the alignment requirement.</li>
</ul>
<p><a class="reference internal" href="#fig-storage-info"><span class="std std-numref">Fig. 3</span></a> shows a depiction of the <code class="docutils literal"><span class="pre">storage_info</span></code> compile-time data.</p>
<div class="figure" id="id22">
<span id="fig-storage-info"></span><a class="reference internal image-reference" href="../_images/storage_info.png"><img alt="../_images/storage_info.png" src="../_images/storage_info.png" style="width: 238.79999999999998px; height: 157.79999999999998px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Storage info and associated compile-time data.</span></p>
</div>
<ul>
<li><p class="first"><strong>Id</strong>: A unique identifier for the storage info type</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For each <code class="docutils literal"><span class="pre">storage_info</span></code> type you should use only one instantiation. The mapping between a storage and the run-time
information in the <cite>storage_info</cite> has to be done at compile time via the index. Thus <cite>GridTools</cite> cannot distinguish the
storages by the run-time sizes passed to the <cite>storage_info</cite>. If you want to instantiate multiple <cite>storage_info</cite> with
the same halo, alignment, layout but with different dimensionality you must use a different ID.</p>
</div>
</li>
<li><p class="first"><strong>Layout Map:</strong> Information about the memory layout. The <code class="docutils literal"><span class="pre">layout_map</span></code> template takes a permutation of the value from
<code class="docutils literal"><span class="pre">0</span></code> to <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the storage. The values indicate the order of the
dimensions by decreasing strides. For instance a C array <code class="docutils literal"><span class="pre">X[i][j][k]</span></code> layout would be equivalent to <code class="docutils literal"><span class="pre">layout_map&lt;0,</span>
<span class="pre">1,</span> <span class="pre">2&gt;</span></code>. The dimension with stride 1 has the highest indexi, so in this case, the k-stride is unit stride. A Fortran
style array <code class="docutils literal"><span class="pre">X[i][j][k]</span></code> layout would be equivalent to <code class="docutils literal"><span class="pre">layout_map&lt;2,</span> <span class="pre">1,</span> <span class="pre">0&gt;</span></code>, meaning that the i-stride is
unit-stride (thus, the first index of the <code class="docutils literal"><span class="pre">layout_map</span></code> is 2).</p>
<p>There is also the possibility to mask dimensions. This means that the storage appears as n-dimensional but the masked
dimensions are ignored. For instance a <code class="docutils literal"><span class="pre">storage_info</span></code> with <code class="docutils literal"><span class="pre">layout_map&lt;1,</span> <span class="pre">-1,</span> <span class="pre">0&gt;</span></code> describes a 3-dimensional
storage, where the i-stride is unit stride and the j dimension is masked. In this case the storage is allocated as a
two-dimensional array, but it behaves as a three-dimensional array. Accessing the array at <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code> always returns
the element at <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">0,</span> <span class="pre">k)</span></code>. This kind of storage can be used two implement oriented planes in stencils.</p>
<p>The following example creates a storage info for the cuda backend. It has a masked dimension in <code class="docutils literal"><span class="pre">J</span></code> (i.e., it
represents a I-K-plane) and the I-dimension is unit stride.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/storage/storage_traits_cuda.hpp&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">gridtools</span><span class="p">;</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">select_custom_layout_storage_info</span><span class="o">&lt;</span><span class="mi">0</span> <span class="cm">/* id */</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">layout</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="n">si</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Selector:</strong> Selectors in the storage traits allow to mask dimensions, but automatically have the optimal layout for
the chosen backend. Dimensions in the <cite>selector</cite> that are set to <cite>0</cite> will be masked. For example, we can create a
storage which is masked in <code class="docutils literal"><span class="pre">J</span></code> (again a I-K-plane), whose layout is optimal for the cuda backend:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/storage/storage_traits_cuda.hpp&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">gridtools</span><span class="p">;</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">select_special_storage_info</span><span class="o">&lt;</span><span class="mi">0</span> <span class="cm">/* id */</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">selector</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="n">si</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Alignment:</strong> Information about the alignment in terms of number of elements. There is the possibility to provide
information about how the data points should be aligned in memory. The alignment is enforced to the first elements in
the compute domain of the dimension with stride one. This provides a huge performance gain for some architectures (e.g.,
GPUs). The storage module combines the alignment, layout, and halo information in order to align the non-halo data
points of the stride-one dimension in memory. The legacy x86 <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> uses no alignment (<code class="docutils literal"><span class="pre">alignment&lt;1&gt;</span></code>) by
default. The CUDA <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> uses a default alignment of 32 data elements (<code class="docutils literal"><span class="pre">alignment&lt;32&gt;</span></code>), the MC
<a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> defaults to <code class="docutils literal"><span class="pre">alignment&lt;8&gt;</span></code>.</p>
</li>
<li><p class="first"><strong>Halo:</strong> The halo information has to be passed as type information to the storage info. The reason for this is that
the proper alignment can only be computed with given halo information. The storage info object provides aligned data
points (non-halo points) for the stride 1 dimension. The halo information is given as follows: <code class="docutils literal"><span class="pre">halo&lt;Sizes...&gt;</span></code>
where sizes is the halo size at both ends of the corresponding dimension, in terms of element sizes. E.g., <code class="docutils literal"><span class="pre">halo&lt;2,</span>
<span class="pre">4,</span> <span class="pre">0&gt;</span></code> is a halo of size 2 in direction I+ and I-, halo of size 4 in direction J+ and J-, and no halo in K.</p>
<p>Note that the size passed to the constructor of the storage info is including the halo. The following example will
create a storage info with halos 1 in i-direction and halos 0 in j-direction. The allocated storage is 10 x 10 x 10,
but the compute domain is only 8 x 10 x 10. The element (1, 0, 0) is the first element of the compute domain and will
be aligned.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/storage/storage_traits_cuda.hpp&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">gridtools</span><span class="p">;</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">gt</span><span class="o">::</span><span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">select_storage_info</span><span class="o">&lt;</span><span class="mi">0</span> <span class="cm">/* id */</span><span class="p">,</span> <span class="mi">3</span> <span class="cm">/* dims */</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="n">si</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
<p>A visual representation of the storage info is given in <a class="reference internal" href="#fig-storage-info-example"><span class="std std-numref">Fig. 4</span></a>. The allocated memory starts
at the bottom. The allocation starts with some padding (due to the alignment requirements). The compute domain (yellow)
is surrounded by a halo region (green).</p>
<div class="figure" id="id23">
<span id="fig-storage-info-example"></span><a class="reference internal image-reference" href="../_images/storage_info_example.png"><img alt="../_images/storage_info_example.png" src="../_images/storage_info_example.png" style="width: 524.0px; height: 246.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Example storage info.</span></p>
</div>
<p><strong>Interface</strong>: A <code class="docutils literal"><span class="pre">storage_info</span></code> object provides methods for querying the meta data.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_length()</span> <span class="pre">const</span></code>: retrieve the total number of data points in dimension
<code class="docutils literal"><span class="pre">D</span></code> dimensions</li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">stride()</span> <span class="pre">const</span></code>: retrieve the stride in dimension <code class="docutils literal"><span class="pre">D</span></code></li>
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;total_lengths()</span> <span class="pre">const</span></code>: return the array of total number of data points in each
direction</li>
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;strides()</span> <span class="pre">const</span></code>: return the array of (aligned) strides.</li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">begin()</span> <span class="pre">const</span></code>: retrieve the position of the first non halo point in dimension <cite>D</cite></li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">end()</span> <span class="pre">const</span></code>: retrieve the position of the last non halo point in dimension <cite>D</cite></li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_begin()</span> <span class="pre">const</span></code>: retrieve the position of the first point (can also be a
halo point) in dimension <code class="docutils literal"><span class="pre">D</span></code> (always <code class="docutils literal"><span class="pre">0</span></code>)</li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_end()</span> <span class="pre">const</span></code>: retrieve the position of the last point (can also be a
halo point) in dimension <code class="docutils literal"><span class="pre">D</span></code></li>
</ul>
</div>
<div class="section" id="data-store">
<span id="id4"></span><h3>Data Store<a class="headerlink" href="#data-store" title="Permalink to this headline">¶</a></h3>
<p>Once the <code class="docutils literal"><span class="pre">storage_info</span></code> object is created a <code class="docutils literal"><span class="pre">data_store</span></code> can be created. A <code class="docutils literal"><span class="pre">data_store</span></code> is keeping together the
<code class="docutils literal"><span class="pre">storage_info</span></code> object, a data type and the actual memory allocation (see also <a class="reference internal" href="#fig-data-store"><span class="std std-numref">Fig. 5</span></a>). The main
purpose of the <code class="docutils literal"><span class="pre">data_store</span></code> is to provide means for synchronizing, keeping consistency, and cleaning up memory. A
<code class="docutils literal"><span class="pre">data_store</span></code> does a shallow copy when being copied, which means that the underlying allocated storage is not copied
and original and copy will point to the same data.</p>
<p>When a data store is used on an accelerator, it has two copies of the data, one copy resides in the memory of the host
system, and a second copy resides in the memory of the accelerator (target system).</p>
<div class="figure" id="id24">
<span id="fig-data-store"></span><a class="reference internal image-reference" href="../_images/data_store.png"><img alt="../_images/data_store.png" src="../_images/data_store.png" style="width: 348.8px; height: 360.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text"><a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> and associated compile-time data.</span></p>
</div>
<p>The type of a <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> combines a <code class="docutils literal"><span class="pre">storage_info</span></code> type and the underlying type. Given a <code class="docutils literal"><span class="pre">storage_info_t</span></code>,
the proper type for the data store can be retrieved using <code class="docutils literal"><span class="pre">storage_traits&lt;Backend&gt;::select_storage</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">Backend</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Example</strong>:
Following codes snippets show how <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> can be created. At first the user has to identify if
the memory management is done externally or not. If it is done externally the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> won’t allocate nor
deallocate the memory. The standard use-case is to use managed <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a>. The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a>
can be initialized with a value or a lambda and can optionally be named by passing an additional string.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">host</span><span class="o">&gt;::</span><span class="n">select_storage_info</span><span class="o">&lt;</span><span class="mi">0</span> <span class="cm">/* id */</span><span class="p">,</span> <span class="mi">2</span> <span class="cm">/* dims */</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">host</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 4 data points + 2 halo points in I, 3 data points and 0 halo points in J</span>

<span class="c1">// standard use cases</span>
<span class="n">data_store_t</span> <span class="nf">ds1</span><span class="p">(</span><span class="n">si</span><span class="p">);</span> <span class="c1">// create a data store without a name (will allocate memory internally)</span>
<span class="n">data_store_t</span> <span class="nf">ds2</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="s">&quot;ds2&quot;</span><span class="p">);</span> <span class="c1">// create a data store with a name (will allocate memory internally)</span>
<span class="n">data_store_t</span> <span class="nf">ds3</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&quot;ds3&quot;</span><span class="p">);</span> <span class="c1">// create a named and value initialized data store</span>
<span class="n">data_store_t</span> <span class="nf">ds4</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;</span> <span class="p">},</span> <span class="s">&quot;ds4&quot;</span><span class="p">);</span> <span class="c1">// create a named and lambda initialized data store</span>

<span class="c1">// copying a data store</span>
<span class="n">ds2</span> <span class="o">=</span> <span class="n">ds1</span><span class="p">;</span> <span class="c1">// ds2 will deallocate the previously allocated memory and will point to the same data as ds1.</span>

<span class="c1">// external pointer use case</span>
<span class="k">extern</span> <span class="kt">double</span><span class="o">*</span> <span class="n">external_ptr</span><span class="p">;</span>
<span class="n">data_store_t</span> <span class="nf">ds_ext</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">external_ptr</span><span class="p">);</span> <span class="c1">// create a data store that is not managing the memory</span>
</pre></div>
</div>
<p><strong>Interface</strong>:
The <code class="docutils literal"><span class="pre">data_store</span></code> object provides methods for performing following things:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">reset()</span></code>: reset the data_store. maybe deallocates memory.</li>
<li><code class="docutils literal"><span class="pre">bool</span> <span class="pre">valid()</span> <span class="pre">const</span></code>: check if underlying storage info and storage is valid.</li>
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;total_lengths()</span> <span class="pre">const</span></code>: return the array of total number of data points in each
direction</li>
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;strides()</span> <span class="pre">const</span></code>: return the array of (aligned) strides.</li>
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">sync()</span> <span class="pre">const</span></code>: synchronize the copies on the host and the target.</li>
<li><code class="docutils literal"><span class="pre">reactivate_target_write_views</span></code>: re-enables read-write device views (see <a class="reference internal" href="#id5">Data View</a>)</li>
<li><code class="docutils literal"><span class="pre">reactivate_host_write_views</span></code>: re-enabled read-write host views (see <a class="reference internal" href="#id5">Data View</a>)</li>
<li><code class="docutils literal"><span class="pre">std::string</span> <span class="pre">const</span> <span class="pre">&amp;name()</span> <span class="pre">const</span></code>: retrieve the name of the storage.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> cannot be used to modify or access the data.
In order to do so we use the view concept, which is explained next.</p>
</div>
</div>
<div class="section" id="data-view">
<span id="id5"></span><h3>Data View<a class="headerlink" href="#data-view" title="Permalink to this headline">¶</a></h3>
<p>The view is a lightweight object to access and modify the data stored in a <code class="docutils literal"><span class="pre">data_store</span></code>.  Views can be generated for
both host and target. Views can be created in read only or in read-write mode. The read-only views can be beneficial
because they don’t trigger synchronizations with the device. These functions are used to create views:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">host_view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">host_view_ro</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">target_view</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">target_view_ro</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
</pre></div>
</div>
<p>A read-write view requests exclusive ownership on the data store, meaning that a read-write view on the host puts the
data store in a state such that no view (neither read-only nor read-write) can be created or used on target.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">host_view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="c1">// creating another host view is ok (read-write and read-only)</span>
<span class="k">auto</span> <span class="n">host_view_ro</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">another_host_view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>

<span class="c1">// creating any target view will fail without sync</span>
<span class="c1">// FAILS: auto target_view = make_target_view&lt;access_mode::read_only&gt;(data_store);</span>
<span class="k">data_store</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="c1">// now a target view can be created</span>
<span class="k">auto</span> <span class="n">target_view</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
</pre></div>
</div>
<p>A read-only view has mutual ownership on the data store: a read-only view on host can only be created and used if no
read-write view exists on target. Read-only views can co-exist on host and target. When a read-only view exists on host,
and a read-write view is created on target, you can safely use the read-write view, but the read-only view cannot be
used until the data store is synchronized.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="c1">// read_only views can co-exist on host and target</span>
<span class="k">auto</span> <span class="n">host_view_ro</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">target_view_ro</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>

<span class="c1">// creating a read-write view will invalidate the host view</span>
<span class="k">auto</span> <span class="n">host_view_ro</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="c1">// host_views cannot be created or used again until sync is called</span>
<span class="k">data_store</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="c1">// now we can create and use host views again</span>
<span class="k">auto</span> <span class="n">another_host_view_ro</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
</pre></div>
</div>
<p>In order to end a view, the data store must be synchronized explicity by calling <code class="docutils literal"><span class="pre">data_store.sync();</span></code>. The destructor
of a view will not end the view. Note that synchronizing a data store will re-enable read-only views, but it will not
re-enable read-write views. Those can be reenabled by calling <code class="docutils literal"><span class="pre">data_store.reactivate_host_write_views()</span></code> (which will
invalidate read-only views on target) and <code class="docutils literal"><span class="pre">data_store.reactivate_target_write_views()</span></code> (which will invalidate
read-only views on host). Note that the</p>
<p><strong>Example</strong>:</p>
<p>Following example shows the instantiation of a <code class="docutils literal"><span class="pre">data_store</span></code> and a corresponding host and target view.  The host view
can be used when the data is modified on a host. Target views can be accessed from the target only, if it has a separate
memory space (e.g., GPU). If target and host share the memory space, host and target views are identical.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">View</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">kernel</span><span class="p">(</span><span class="n">View</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// set (0, 0) to 3.1415</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// instantiate a data_store</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="o">&gt;::</span><span class="n">select_storage_info</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">gt</span><span class="o">::</span><span class="n">halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">host</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">ds</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>

<span class="c1">// create a view to ds (data_store)</span>
<span class="k">auto</span> <span class="n">host_view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span> <span class="c1">// read write view</span>
<span class="c1">// set (0, 10) to 3.1415</span>
<span class="n">host_view</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
<span class="c1">// synchronize the data store</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="c1">// create a target view</span>
<span class="k">auto</span> <span class="n">device_view_ds</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span> <span class="c1">// read write view</span>
<span class="c1">// call kernel</span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">device_view_ds</span><span class="p">);</span>
<span class="c1">// synchronize the data store</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>

<span class="c1">// reactivate the host view</span>
<span class="n">ds</span><span class="p">.</span><span class="n">reactivate_host_write_views</span><span class="p">();</span>
<span class="c1">// expect (0, 0) == (0, 10)</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">host_view</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">host_view</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p><strong>Interface</strong>:</p>
<p>The <code class="docutils literal"><span class="pre">data_view</span></code> construction can be created with <code class="docutils literal"><span class="pre">make_host_view</span></code> and <code class="docutils literal"><span class="pre">make_target_view</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/storages/data_store.hpp&gt;</span><span class="cp"></span>
<span class="k">auto</span> <span class="n">view1</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">Access</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">view2</span> <span class="o">=</span> <span class="nl">make_target_view</span><span class="o">&lt;</span><span class="n">Access</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
</pre></div>
</div>
<p>Access is either <code class="docutils literal"><span class="pre">access_mode::read_only</span></code> or <code class="docutils literal"><span class="pre">access_mode::read_write</span></code> <code class="docutils literal"><span class="pre">storage/common/definitions.hpp</span></code>. <code class="docutils literal"><span class="pre">view1</span></code>
can be used by a host thread to access data, <code class="docutils literal"><span class="pre">view2</span></code> is a view that can be used from the target system to access data.</p>
<p>The <code class="docutils literal"><span class="pre">data_view</span></code> object has the following public API:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;total_lengths()</span> <span class="pre">const</span></code>: return the array of total number of data points in each
direction</li>
<li><code class="docutils literal"><span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;strides()</span> <span class="pre">const</span></code>: return the array of (aligned) strides.</li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename...</span> <span class="pre">Coords&gt;</span> <span class="pre">data_t&amp;</span> <span class="pre">operator()(Coords...</span> <span class="pre">c)</span> <span class="pre">const</span></code>: used to access elements. E.g., <code class="docutils literal"><span class="pre">view(0,</span> <span class="pre">0,</span>
<span class="pre">2)</span></code> will return the third element.</li>
</ul>
<p>At any point, the consistency of a view with a data store can be checked with</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">Access</span><span class="o">&gt;</span><span class="p">(</span><span class="k">data_store</span><span class="p">);</span>
<span class="n">check_consistency</span><span class="p">(</span><span class="k">data_store</span><span class="p">,</span> <span class="n">view</span><span class="p">);</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">bool</span> <span class="pre">check_consistency(DataStore</span> <span class="pre">const&amp;,</span> <span class="pre">DataView</span> <span class="pre">const&amp;)</span></code> returns true, if the given view can be used
to access and modify the data. If it returns false, the user needs to call <code class="docutils literal"><span class="pre">data_store.sync()</span></code> or reactivate write
functions</p>
</div>
</div>
<div class="section" id="stencil-operators">
<span id="id6"></span><h2>Stencil Operators<a class="headerlink" href="#stencil-operators" title="Permalink to this headline">¶</a></h2>
<p><em>Stencil operators</em> are the GridTools-equivalent of <cite>functors</cite> in regular C++ code.  They are assumed to have no
side-effects and no status (which is why they are marked as <cite>static</cite>). As functions they have an <cite>interface</cite> and an
<cite>implementation</cite>. The interface informs both the caller, on the order and types of arguments that have to be passed to
it, and the implementation, on the names and types of the symbols available to it.</p>
<p>The stencil operator specifies the computation to be performed in each grid point of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> of the
stencil <a class="reference internal" href="../glossary/glossary.html#term-computation"><span class="xref std std-term">Computation</span></a>. In the implementation, a point of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> at which the stencil operator
is called is referred to as <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.</p>
<p>A stencil operator is a <cite>class</cite>, or a <cite>struct</cite>, with the following public properties:</p>
<ul class="simple">
<li>A list of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> types that are associated to the data fields the stencil operator will access
in its implementation.</li>
<li>A <code class="docutils literal"><span class="pre">param_list</span></code> listing all the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> types defined above. They are created using <code class="docutils literal"><span class="pre">make_param_list</span></code>.</li>
<li>A set of <em>static template member functions</em> named <code class="docutils literal"><span class="pre">apply</span></code>, also referred to as <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Methods</span></a>.
These functions should be annotated with <code class="docutils literal"><span class="pre">GT_FUNCTION</span></code> which ensures that the functions can be run on GPU and that
they are inlined.</li>
</ul>
<p>The user may add additional static functions for internal usage within the stencil operator.</p>
<p>See the <a class="reference internal" href="#stencil-operator-example"><span class="std std-ref">Example</span></a> for a concrete usage of the syntax of the stencil operators.</p>
<div class="section" id="accessor-type">
<h3>Accessor Type<a class="headerlink" href="#accessor-type" title="Permalink to this headline">¶</a></h3>
<p>There are two kinds of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>:</p>
<ul class="simple">
<li>Regular <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">accessors</span></a> indicate an access to a regular <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> of a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>.</li>
<li>Global accessors indicate that the data to be referred does not participate in the iteration
and always point to a same <em>read only</em> datum to be used in the operator, which is hold in a <a class="reference internal" href="../glossary/glossary.html#term-global-parameter"><span class="xref std std-term">Global Parameter</span></a>.</li>
</ul>
<p>Accessors are defined as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="c1">// regular accessors</span>
<span class="k">using</span> <span class="n">name</span> <span class="o">=</span> <span class="k">accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="k">intent</span><span class="p">,</span> <span class="p">[</span><span class="k">extent</span> <span class="o">=</span> <span class="k">extent</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// global accessor</span>
<span class="k">using</span> <span class="n">name</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>where</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">name</span></code> is the name associated to the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> and will be used in the implementation of the stencil
operator. The name of an accessor is only used within the stencil.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">I</span></code> is an integral index. The indices of the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> in a given stencil operators <em>must</em> be
in the range from 0 to N - 1, where N is the number of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> used by the stencil operator. No
index can appear twice. If these rules are not followed the compilation fails.</p>
<p>For global accessors, the index is the only argument.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">intent</span></code> indicates the type of access the stencil operator makes to the data associated to the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>.
Possible values are</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">intent::in</span></code> to specify <em>read-only</em> access</li>
<li><code class="docutils literal"><span class="pre">intent::inout</span></code> to specify <em>read-write</em> access. The <code class="docutils literal"><span class="pre">extent</span></code> for <cite>i</cite> and <cite>j</cite> for <code class="docutils literal"><span class="pre">inout</span></code> must be made of all
zeros (see next points)</li>
</ol>
<p>Alternatively, the abbreviations <code class="docutils literal"><span class="pre">in_accessor</span></code> our <code class="docutils literal"><span class="pre">inout_accessor</span></code> can be used respectively.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">read_only_accessor</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="p">[</span><span class="k">extent</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">read_write_accessor</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="p">[</span><span class="k">extent</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">extent</span></code> defines the maximum offsets at which the implementation will access data around the <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration
Point</span></a>. They are defined as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">extent</span><span class="o">&lt;</span><span class="n">i_minus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i_plus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j_minus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j_plus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k_minus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k_plus</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>An extent takes three pairs of numbers, one pair for each dimension of the iteration space. The first number of the
pair must be non-positive and indicates the maximum offset in the direction of <em>decreasing</em> indices (also called minus
direction*). The second number must be non-negative and indicates the maximum offset in the direction of
<em>increasing</em> indices (also called plus direction*). Numbers can be ommitted and default to zero.</p>
<p>Example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">my_accessor</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This accessor guarantees that at most one element in negative and positive i-direction will be accessed (i.e. we will
never access <code class="docutils literal"><span class="pre">field(i</span> <span class="pre">+</span> <span class="pre">2)</span></code>). Further, it guarantees that in j-direction, no elements in negative and at most two
elements in positive direction will be accessed. In k-direction, the field is not accessed with any offset.</p>
<p>Note that <code class="docutils literal"><span class="pre">extent&lt;&gt;</span></code> is a valid extent and indicates that the field is always accessed at the iteration point.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Behaviour is undefined if a field is accessed at extents that are outside the box defined by <code class="docutils literal"><span class="pre">extent</span></code>. Under
certain configuration this might lead to erroneous results. Extents bigger than the ones actually accessed by the
implementation will potentially result in performance loss.</p>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">N</span></code> identifies the number of dimensions of the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a>. By default this value is set to 3.</p>
</li>
</ul>
</div>
<div class="section" id="accessor-aliases">
<h3>Accessor Aliases<a class="headerlink" href="#accessor-aliases" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> alias is a regular <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> which has an offset predefiend at compile-time.  For instance,
we might have a 4-dimensional <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a>, where the last dimension refers to the 3 component u, v, w of a vector
field, e.g. the wind-speed. This vector field is accessed via an <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> called <code class="docutils literal"><span class="pre">vel</span></code></p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vel</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>For convenience we can introduce an alias to the <code class="docutils literal"><span class="pre">w</span></code> component</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">w</span> <span class="o">=</span> <span class="n">alias</span><span class="o">&lt;</span><span class="n">vel</span><span class="p">,</span> <span class="k">dimension</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;&gt;::</span><span class="n">set</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The line above sets the fourth offset at compile-time to the value 2, so that we have the following equivalency:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">()</span> <span class="o">==</span> <span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>This allows to considerably lighten the notation in complicated expressions.  Note that you can still access the other
dimensions with an offset, by using the alias, for example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="k">dimension</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">w</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">vel</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-list">
<h3>Parameter list<a class="headerlink" href="#parameter-list" title="Permalink to this headline">¶</a></h3>
<p>The parameter list <code class="docutils literal"><span class="pre">param_list</span></code> is defined as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">accessors</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">_accessors_</span></code> is a comma separated list of all the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> specified before. For example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">in_</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">out_</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">in_</span><span class="p">,</span> <span class="n">out_</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Specifying the parameter list is mandatory because C++ cannot infer what types have been defined as accessors.</p>
</div>
</div>
<div class="section" id="apply-method">
<span id="stencil-operators-apply-method"></span><h3><cite>Apply</cite>-Method<a class="headerlink" href="#apply-method" title="Permalink to this headline">¶</a></h3>
<p>A stencil operator can have several <code class="docutils literal"><span class="pre">apply</span></code>-methods, defining the functors to be applied at different <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical
Intervals</span></a>. An <code class="docutils literal"><span class="pre">apply</span></code> method takes at most two arguments:</p>
<ol class="arabic simple">
<li>The first argument is a templated parameter usually called <code class="docutils literal"><span class="pre">eval</span></code> that holds internal information.</li>
<li>The second arguments specifies the Vertical Interval to which functor is applied to. If the grid is not created with
an axis, but only with a vertical size, this argument can be skipped and the stencil is applied to the whole axis.
Whenever the grid is created using an axis, the user should specify a vertical interval for each method.</li>
</ol>
<p>Example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Eval</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span>
<span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Eval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eval</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
</pre></div>
</div>
<p>Within an <code class="docutils literal"><span class="pre">apply</span></code>-method, data bound to the accessors can be accessed through the <code class="docutils literal"><span class="pre">eval</span></code> argument.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">accessor_name</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Make sure to add the parentheses after the accessor.</p>
</div>
<p>The previous syntax will evaluate the accessor at the iteration point. Values can be accessed at offsets relative to the
evaluation point by passing a sequence of integral indices to the accessor:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">accessor_name</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>This accesses an element at an offset of 1 in the first dimension (plus direction) of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>, and
an offset of 1 in the minus direction in the third dimension. A way to think of it is to consider the point of
evaluation as a triplet <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">j</span></code> and <code class="docutils literal"><span class="pre">k</span></code>, and those offsets are added to the current index coordinates to
identifying the actual value to access. The evaluation returns a reference to the value for accessors with
<code class="docutils literal"><span class="pre">inout</span></code>-intent, and a const reference for <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> with <code class="docutils literal"><span class="pre">in</span></code>-intent.</p>
<p>The next example calculates the average of two neighbored values in the first dimension and assign it to the output
field:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">())</span> <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic">
<li><p class="first">Writing into non-zero offsets is considered bad practice and can lead to incorrect computations. This may be
forbidden in the future.</p>
</li>
<li><p class="first">Stencil operators must not have any horizontal dependencies within itself. That means: If a stencil operator writes
into a field, it must not access this field with non-zero horizontal offset.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// ok, if this stage does not write to in</span>
<span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// undefined!</span>
<span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// undefined, if execution policy is parallel (see stencil composition sections)</span>
</pre></div>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="example">
<span id="stencil-operator-example"></span><h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">flx_function</span> <span class="p">{</span>

    <span class="k">using</span> <span class="n">out</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">in</span>  <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">lap</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">lap</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">full_interval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="expressions">
<h3>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Should we remove the expressions namespace? Why should we forbid this functionality in certain cases?</p>
</div>
<p>Multiple calls to eval can be merged into one when the <code class="docutils literal"><span class="pre">expressions</span></code>-namespace is imported. This is possible, because
calculations with accessors produce expressions that can be evaluated. Readibility can be greatly improved, but it might
have some negative impact on compilation time.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">expressions</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">expressions</span><span class="p">;</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">expressions</span></code>-namespace has overloads for common operations on accessors, namely <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>,
<code class="docutils literal"><span class="pre">pow&lt;&gt;</span></code>. Using those operations with accessors creates an expression that can be evaluated using <code class="docutils literal"><span class="pre">eval</span></code>. An
extensive example of its usage, demonstrating its effectiveness, can be found in the <a class="reference external" href="https://github.com/eth-cscs/gridtools/blob/master/regression/shallow_water_enhanced.hpp">shallow water implementation</a>.</p>
<p>Note that those expressions can also be used to lazily evaluate expressions. This provides a way to reuse expressions in
your code:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">expressions</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">out</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="execution-model">
<span id="id7"></span><h2>Execution Model<a class="headerlink" href="#execution-model" title="Permalink to this headline">¶</a></h2>
<p>Stencil operations are executed in a three dimensional <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration space</span></a>. The first two dimensions of the
iteration space, usually referred to as <cite>I</cite> and <cite>J</cite> dimensions identify the horizontal dimension. There is no
prescription on in what order stencil operators in different points of the same <cite>IJ</cite> plane will be executed. Stencil
operators in the third dimension of the iteration space, usually referred as <cite>K</cite> or vertical dimension, can have
prescribed order of executions. There are three different ways of execution policies for the <cite>K</cite> dimension:</p>
<ul class="simple">
<li><cite>forward</cite>: The computation at index <cite>k</cite> in the vertical dimension is executed after index <cite>k - 1</cite> for all points in
the horizontal plane;</li>
<li><cite>backward</cite>: The computation at index <cite>k</cite> in the vertical dimension is executed after index <cite>k + 1</cite> for all points in
the horizontal plane;</li>
<li><cite>parallel</cite>: No order is specified and execution can happen concurrently.</li>
</ul>
<p>An execution strategy for a computation is indicated by <code class="docutils literal"><span class="pre">execute::order()</span></code>,
where <cite>order</cite> is one of the <cite>K</cite> dimension execution orders: <code class="docutils literal"><span class="pre">forward</span></code>, <code class="docutils literal"><span class="pre">backward</span></code>, <code class="docutils literal"><span class="pre">parallel</span></code>.</p>
<p>The parallel execution policy allows for tuning the degree of parallelism (in the CUDA backend), by selecting
<code class="docutils literal"><span class="pre">execute::parallel_block&lt;vertical_block_size&gt;</span></code>, where <code class="docutils literal"><span class="pre">vertical_block_size</span></code> describes the dimension of CUDA block
in the vertical (a too high value e.g. each k-level in a separate CUDA-thread might result in a too low instruction level
parallelism and therefore in non-optimal performance).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The option to specify the vertical block size will most likely be moved to the backend in the future,
see <a class="reference internal" href="#backend-selection"><span class="std std-ref">Selecting the Backend</span></a>.</p>
</div>
<p>More concretely, a multistage is a list of stages (implemented with stencil operators) to be executed with a certain
execution policy.  A computation combines several multistages, and will execute one multistage after the other.</p>
<ul class="simple">
<li>For each <cite>IJ</cite> plane, the stages of a multistage will be executed strictly one after the other. This means, that a
stage can assume, that the previous stage has been applied to the the whole <cite>IJ</cite> plane before it is executed. The user
can explicitly create independent stages, that don’t require this restriction.</li>
<li>If the execution policy is <cite>parallel</cite>, a stage cannot impose any assumptions on which stages are applied before in
another <cite>IJ</cite> plane.</li>
<li>If the execution policy is <cite>forward</cite>, it is guaranteed, that if a stage is executed at index <code class="docutils literal"><span class="pre">k</span></code>, then all stages of
the multistage were already applied to the same column with smaller <code class="docutils literal"><span class="pre">k</span></code>, and that no stages of the multistage are
already applied to the indices in the same column with larger <code class="docutils literal"><span class="pre">k</span></code>.</li>
<li>If the execution policy is <cite>backward</cite>, it is guaranteed, that if a stage is executed at index <code class="docutils literal"><span class="pre">k</span></code>, then all stages of
the multistage were already applied to the same column with larger <code class="docutils literal"><span class="pre">k</span></code>, and that no stages of the multistage are
already applied to the indices in the same column with smaller <code class="docutils literal"><span class="pre">k</span></code>.</li>
</ul>
<div class="section" id="access-restrictions">
<h3>Access restrictions<a class="headerlink" href="#access-restrictions" title="Permalink to this headline">¶</a></h3>
<p>The execution model imposes restrictions on how accessors can be evaluated. The following restrictions apply:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Accessors can be read at any offset at any time, if the fields bound to the accessor are read-only within
a whole <em>multistage</em></li>
<li>A stage may write to a field through an accessor. In this stage and in all later stages in the same multistage,
this field must not be read anymore with any non-zero offsets, except with k-offsets in case of
non-parallel policy. For example, you must not access such a field with <code class="docutils literal"><span class="pre">eval(field(-1,</span> <span class="pre">-1,</span> <span class="pre">-1))</span></code>.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="stencil-composition">
<span id="id8"></span><h2>Stencil Composition<a class="headerlink" href="#stencil-composition" title="Permalink to this headline">¶</a></h2>
<div class="section" id="preparing-arguments-storage-placeholders">
<span id="placeholders"></span><h3>Preparing Arguments: Storage Placeholders<a class="headerlink" href="#preparing-arguments-storage-placeholders" title="Permalink to this headline">¶</a></h3>
<p>To allow naming arguments, that are passed to stencil computations, at compile
time, <cite>GridTools</cite> uses <cite>storage placeholders</cite>. The storage placeholders are pairs of
an integer identifier and a storage type (a <cite>GridTools</cite> <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> type).</p>
<p>For example</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">p_in</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">p_out</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>defines two placeholders named <cite>p_in</cite> and <cite>p_out</cite>. Note that the identifier,
that is, the first argument passed to <cite>arg</cite>, must be unique in the computation using it.</p>
<p>A second placeholder type for temporary data exists that can be defined in
exactly the same way:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">p_tmp</span> <span class="o">=</span> <span class="k">tmp_arg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The difference between temporary and non-temporary placeholders is that while non-temporary placeholders are bound with
a user-allocated data-store, this is not needed for temporary placeholders.  <cite>GridTools</cite> takes care to allocate a suitable
storage for those placeholders. The storage duration of a temporary starts with the first stage of the first multistage,
and ends with the last stage of the last multistage.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you define multiple placeholders with the same ID, they can not be distinguished by <cite>GridTools</cite> even if they have different
names or storage types!  <cite>arg</cite> and <cite>tmp_arg</cite> arguments can have the same identifiers, and still represent different
placeholders.</p>
</div>
<p>The placeholders can be used as arguments to certain <cite>GridTools</cite> functions. There are two use cases: first, they define, which
stages are called with which arguments, e.g., in</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">stage</span> <span class="o">=</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">some_stage</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_in</span><span class="p">(),</span> <span class="n">p_tmp</span><span class="p">(),</span> <span class="n">p_out</span><span class="p">());</span>
</pre></div>
</div>
<p>they define that during execution the stage <code class="docutils literal"><span class="pre">some_stage</span></code> will be called with the fields bound to the placeholders at
that point (see further below for documentation of the <cite>make_stage</cite> function). The second use case is binding run-time
values to previously declared arguments, e.g.,</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">computation</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">output_data</span><span class="p">);</span>
</pre></div>
</div>
<p>runs a computation on <cite>input_data</cite> and <cite>output_data</cite>. Storages must only be assigned to <cite>arg</cite> placeholders, all data for
the <cite>tmp_arg</cite> arguments is managed by <cite>GridTools</cite>.</p>
</div>
<div class="section" id="defining-the-iteration-space-the-grid">
<span id="defining-iteration-space"></span><h3>Defining the Iteration Space: the Grid<a class="headerlink" href="#defining-the-iteration-space-the-grid" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a> describe operations on a single <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.
The <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> defines on which points the operator should be applied. In this section
we cover how to define the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> with the <code class="docutils literal"><span class="pre">grid</span></code> object.</p>
<p><cite>GridTools</cite> offers a set of functions which ease the construction of the <code class="docutils literal"><span class="pre">grid</span></code>:</p>
<dl class="function">
<dt id="_CPPv29make_gridiii">
<span id="make_grid__i.i.i"></span>grid <code class="descclassname"></code><code class="descname">make_grid</code><span class="sig-paren">(</span>int <em>size_i</em>, int <em>size_j</em>, int <em>size_k</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv29make_gridiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The simplest <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> will iterate the cube defined by the <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a> <code class="docutils literal"><span class="pre">[0,</span>
<span class="pre">size_i-1]</span></code>, <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">size_j-1]</span></code>, <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">size_k-1]</span></code>. This function must only be used if all stages used within the
computation have zero extents.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29make_grid15halo_descriptor15halo_descriptori">
<span id="make_grid__halo_descriptor.halo_descriptor.i"></span>grid <code class="descclassname"></code><code class="descname">make_grid</code><span class="sig-paren">(</span>halo_descriptor <em>halo_i</em>, halo_descriptor <em>halo_j</em>, int <em>size_z</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv29make_grid15halo_descriptor15halo_descriptori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For finer control of the iteration space a <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptor</span></a> can be passed for the horizontal directions (<code class="docutils literal"><span class="pre">I</span></code>
and <code class="docutils literal"><span class="pre">J</span></code>).  The 3rd and 4th argument of the <code class="docutils literal"><span class="pre">halo_descriptor</span></code> define the start and the endpoint of the
<a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>. Note that the minus (first argument) and plus (second argument) of the <code class="docutils literal"><span class="pre">halo_descriptor</span></code>
should be larger than the maximum extent of the whole computation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The last argument of the halo descriptor (total length) is not used in in the grid. This will be improved in the
future.</p>
</div>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="k">grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">},</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>This example will create a grid. The iteration space in <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code> will be <code class="docutils literal"><span class="pre">[10,</span> <span class="pre">20]</span></code> (including <code class="docutils literal"><span class="pre">20</span></code>!). The
computation is required not to access data outside of <code class="docutils literal"><span class="pre">[7,</span> <span class="pre">23]</span></code>. The iteration space in <code class="docutils literal"><span class="pre">k</span></code> is <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">9]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29make_gridii4Axis">
<span id="make_grid__i.i.Axis"></span>grid <code class="descclassname"></code><code class="descname">make_grid</code><span class="sig-paren">(</span>int <em>size_i</em>, int <em>size_j</em>, Axis <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv29make_gridii4Axis" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The vertical axis needs to be passed to the grid when using several vertical regions. The axis can be constructed by
passing it the size of each of the vertical regions. Details follow in the coming sections.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29make_grid15halo_descriptor15halo_descriptor4Axis">
<span id="make_grid__halo_descriptor.halo_descriptor.Axis"></span>grid <code class="descclassname"></code><code class="descname">make_grid</code><span class="sig-paren">(</span>halo_descriptor <em>halo_i</em>, halo_descriptor <em>halo_j</em>, Axis <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv29make_grid15halo_descriptor15halo_descriptor4Axis" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>See explanations in other functions.</p>
</dd></dl>

</div>
<div class="section" id="vertical-regions-and-vertical-boundary-conditions">
<span id="vertical-regions"></span><h3>Vertical Regions and Vertical Boundary Conditions<a class="headerlink" href="#vertical-regions-and-vertical-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>The <cite>GridTools</cite> <a class="reference internal" href="../glossary/glossary.html#term-execution-model"><span class="xref std std-term">Execution Model</span></a> allows to be sequential in the vertical dimension (<code class="docutils literal"><span class="pre">k</span></code>). Additionally, <cite>GridTools</cite>
offers the possibility to split the vertical dimension into vertical regions,
where stencils can perform different operations. Typical applications of this pattern are models which define
terrain-following coordinates close to the earth surface and flat-coordinates in upper
levels of the atmosphere. Another use-case are vertical boundary-conditions which can
be directly integrated into the stencil operation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the following we will distinguish two concepts: first <a class="reference internal" href="../glossary/glossary.html#term-vertical-region"><span class="xref std std-term">Vertical Regions</span></a> are
non-overlapping subsets of the vertical <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> with run-time defined sizes; second <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical
Intervals</span></a> (or just <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Interval</span></a>) are compile-time defined descriptions
from one vertical level (not every vertical level can be selected, see below) to another.</p>
</div>
<div class="section" id="default-interval">
<h4>Default Interval<a class="headerlink" href="#default-interval" title="Permalink to this headline">¶</a></h4>
<p>In simple applications, where all vertical levels should be treated equally, <cite>GridTools</cite> allows to use a default
<a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> which covers the full vertical region. In this and only this case the apply methods of the stencil
operators should be defined without specifying an <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> (see Section
<a class="reference internal" href="#stencil-operators-apply-method"><span class="std std-ref">Apply-Methods</span></a>) and the iteration space should be created using one of the simple
constructors in the <a class="reference internal" href="#defining-iteration-space"><span class="std std-ref">previous section</span></a> (namely, either <code class="docutils literal"><span class="pre">make_grid(int,</span> <span class="pre">int,</span> <span class="pre">int)</span></code>, or
<code class="docutils literal"><span class="pre">make_grid(halo_descriptor,</span> <span class="pre">halo_descriptor,</span> <span class="pre">int)</span></code>.</p>
</div>
<div class="section" id="defining-vertical-intervals">
<h4>Defining Vertical Intervals<a class="headerlink" href="#defining-vertical-intervals" title="Permalink to this headline">¶</a></h4>
<p><cite>GridTools</cite> allows to split the full vertical iteration space into regions. The number of vertical regions needs to be specified at
compile-time, while the size of each region can be defined at run-time.</p>
<p>For defining a computation with more than a single vertical region we need to define an <code class="docutils literal"><span class="pre">axis</span></code> first.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">my_axis_t</span> <span class="o">=</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <cite>N</cite> describes the number of vertical regions.</p>
<p>At runtime the axis is instantiated with the sizes of each region,</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">my_axis_t</span> <span class="n">my_axis</span><span class="p">{</span><span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="p">...};</span>
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">Nx</span></code> are the sizes of region <code class="docutils literal"><span class="pre">x</span></code>. With our axis object we can now generate a grid with one of the following
signatures</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">grid</span> <span class="n">make_grid</span><span class="p">(</span><span class="kt">int</span> <span class="n">size_i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">my_axis</span><span class="p">)</span>
<span class="k">grid</span> <span class="n">make_grid</span><span class="p">(</span><span class="k">halo_descriptor</span> <span class="n">halo_i</span><span class="p">,</span> <span class="k">halo_descriptor</span> <span class="n">halo_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">my_axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Each region already defines a <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> which can be queried from the axis by</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">first_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">second_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">full_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">full_interval</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a> are compile time object, i.e. C++ types. These <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a>
are used for defining which <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> version of the stencil operator should be used during the iteration.</p>
<p><a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> provides meta-functions which allow to define modified <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">interval::first_level</span></code>, which is the Interval (a C++ type) describing the first level of the Interval</li>
<li><code class="docutils literal"><span class="pre">interval::last_level</span></code>, which is Interval describing the last level of the Interval</li>
<li><code class="docutils literal"><span class="pre">interval::modify&lt;begin,</span> <span class="pre">end&gt;</span></code>, which is an Interval extended (<code class="docutils literal"><span class="pre">begin</span></code> &lt; 0) or shrunk (<code class="docutils literal"><span class="pre">begin</span></code> &gt; 0) at at the
beginning of the Interval and extended (<code class="docutils literal"><span class="pre">end</span></code> &gt; 0) or shrunk (<code class="docutils literal"><span class="pre">end</span></code> &lt; 0) at the end of the Interval.</li>
<li><code class="docutils literal"><span class="pre">interval::shift&lt;value&gt;</span></code>, which is the Interval shifted by <code class="docutils literal"><span class="pre">value</span></code>, i.e. it is a shortcut for <code class="docutils literal"><span class="pre">modify&lt;value,</span>
<span class="pre">value&gt;</span></code>.</li>
</ul>
<p>Examples:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">axis_t</span> <span class="o">=</span> <span class="n">axis</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// axis with 2 vertical regions</span>
<span class="n">axis_t</span> <span class="nf">my_axis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// iteration space spans 5 + 10 levels</span>

<span class="k">using</span> <span class="n">first_interval</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// interval [0, 4]</span>
<span class="k">using</span> <span class="n">second_interval</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval1</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// [5, 14]</span>
<span class="k">using</span> <span class="n">full_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">full_interval</span><span class="p">;</span>         <span class="c1">// [0, 14]</span>

<span class="k">using</span> <span class="n">first_level_only_interval</span> <span class="o">=</span> <span class="n">full_interval</span><span class="o">::</span><span class="n">first_level</span><span class="p">;</span> <span class="c1">// [0]</span>
<span class="k">using</span> <span class="n">last_level_only_interval</span> <span class="o">=</span> <span class="n">full_interval</span><span class="o">::</span><span class="n">last_level</span><span class="p">;</span>   <span class="c1">// [14]</span>
<span class="k">using</span> <span class="n">a_middle_level_interval</span> <span class="o">=</span> <span class="n">second_interval</span><span class="o">::</span><span class="n">first_level</span><span class="p">;</span> <span class="c1">// [5]</span>

<span class="k">using</span> <span class="n">a_middle_interval</span> <span class="o">=</span> <span class="n">a_middle_level_interval</span><span class="o">::</span><span class="n">modify</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// [4, 5]</span>
<span class="k">using</span> <span class="n">a_middle_interval2</span> <span class="o">=</span> <span class="n">a_middle_interval</span><span class="o">::</span><span class="n">shift</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>           <span class="c1">// [5, 6]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only two of levels around a vertical region can be addressed in this way. This can be changed using the methods
described in the see <a class="reference internal" href="#vertical-regions-advanced"><span class="std std-ref">next section</span></a>.</p>
</div>
</div>
<div class="section" id="advanced-functionality-for-vertical-intervals">
<span id="vertical-regions-advanced"></span><h4>Advanced Functionality for Vertical Intervals<a class="headerlink" href="#advanced-functionality-for-vertical-intervals" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">axis</span></code> type has two additional template parameters to change some default restrictions:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">NIntervals</span><span class="p">,</span> <span class="n">int_t</span> <span class="n">ExtraOffsetsAroundFullInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">int_t</span> <span class="n">LevelOffsetLimit</span> <span class="o">=</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">axis</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">LevelOffsetLimit</span></code> defines how many levels around each vertical region can be addressed by specialized
<code class="docutils literal"><span class="pre">Apply</span></code>-methods. Increasing this value could have negative implications on compile-time.</li>
</ul>
</div>
</div>
<div class="section" id="composition-of-stencils">
<span id="id9"></span><h3>Composition of Stencils<a class="headerlink" href="#composition-of-stencils" title="Permalink to this headline">¶</a></h3>
<p>The main component of <cite>GridTools</cite> provide the capability of composing different <a class="reference internal" href="../glossary/glossary.html#term-stage"><span class="xref std std-term">Stages</span></a>. A stage is the
application of a single <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a> to an <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>. The ability to fuse multiple stages
allows the <cite>GridTools</cite> library to improve the memory locality of the computation by taking advantage of the produce consumer
relations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When composing stencils, each output data field must be written only
once. Failing to do so will end up in undefined behavior. We plan to
introduce compile time checks to catch the violation of this
condition.</p>
</div>
<p>The result of a composition is a <a class="reference internal" href="../glossary/glossary.html#term-multi-stage"><span class="xref std std-term">Multi-Stage</span></a>.
For reason of uniformity, a Multi-Stage with a singe <a class="reference internal" href="../glossary/glossary.html#term-stage"><span class="xref std std-term">Stage</span></a>, is still called a multi-stage, since the
composition is generally assumed to take a list of stages, even if the stage is just one.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This decision put the emphasis on the fact that composition
is considered the main feature of <cite>GridTools</cite>. If your application
is made of a simple stencil, or stencils that cannot be
composed (see below), then <cite>GridTools</cite> may not be the right solution
for you.</p>
</div>
<p><cite>GridTools</cite> allows multi-stage computations to be composed. The final composition, with the addition of a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a> is
simply called a <cite>GridTools</cite> <a class="reference internal" href="../glossary/glossary.html#term-computation"><span class="xref std std-term">Computation</span></a>.</p>
<p>Initially we need to specify the stages. A stage is specified by
indicating a <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a> and some
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a> to its arguments. The placeholders are
aliases to the actual arguments and are used to compute the data
dependencies of the computation independently of the actual data
fields that will be accessed by the computation. The syntax for
specifying a stage uses a helper function called <cite>make_stage</cite>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">stage</span> <span class="o">=</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">plc0</span><span class="p">(),</span> <span class="n">plc1</span><span class="p">(),</span> <span class="p">...);</span>
</pre></div>
</div>
<p>Where the <cite>operator</cite> is the stencil operator of the stage and the <cite>plc0</cite>,
<cite>plc1</cite>, … are the placeholders. The number and the intent of the placeholders
depend on the <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a>.</p>
<p>A <a class="reference internal" href="../glossary/glossary.html#term-multi-stage"><span class="xref std std-term">Multi-Stage</span></a> is a concatenation of stages, plus the indication of
the <a class="reference internal" href="../glossary/glossary.html#term-vertical-execution-order"><span class="xref std std-term">Vertical Execution Order</span></a> to be used for all the stages.</p>
<p>The following example demonstrates how to create a multistage for a diffusion operator.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">multi_stage</span> <span class="o">=</span> <span class="nl">make_multistage</span><span class="p">(</span>
    <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not possible to make a <a class="reference internal" href="../glossary/glossary.html#term-multi-stage"><span class="xref std std-term">Multi-Stage</span></a> with stages of different
<a class="reference internal" href="../glossary/glossary.html#term-vertical-execution-order"><span class="xref std std-term">Vertical Execution Orders</span></a>.</p>
</div>
<p>The data-dependence analysis of <cite>GridTools</cite> will determine the data flow
and the <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extents</span></a> at which each data field will be accessed. This
information is then passed to the architecture specific backend for the
execution.</p>
<p>Before the computation can be executed, a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>, specifying
the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>, must be provided.</p>
<p>Creating a complete stencil for horizontal diffusion looks as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">backend_t</span></code> specifies the <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> that will execute the computation.</p>
<p>The details about dependencies between stages and multistages are described in <a class="reference internal" href="#execution-model"><span class="std std-ref">Execution Model</span></a>. If two stages
have no dependencies, they don’t need to be synchronized. Thus, the user can make them independent. In case of the
horizontal diffusion, the fluxes in x and y have no dependency on each other, thus, <code class="docutils literal"><span class="pre">make_independent</span></code> can be used:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="n">make_independent</span><span class="p">(</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">())),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">make_independent</span></code> does not have impact on the data-dependency analysis but, potentially, only on the execution
schedule.</p>
<p>A computation can also have several multistages. The general signature is as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">grid</span><span class="p">,</span> <span class="n">multi_stage0</span><span class="p">,</span> <span class="n">other_multi_stages</span><span class="p">...);</span>
</pre></div>
</div>
<p>A computation can incorporate multiple multi-stage computations and they
may have different execution policies. This is very useful for implementing
computations that require two vertical swipes, one ascending and one
descending, but has to be used with care. Before explaining the rules for using
this feature, we provide a simple example of the syntax in the vertical
advection example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">vertical_advection</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">forward_op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_utens_stage</span><span class="p">(),</span> <span class="n">p_wcon</span><span class="p">()),</span>
    <span class="p">),</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">backward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">backward_op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_utens_stage</span><span class="p">(),</span> <span class="n">p_u_pos</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>This option is particularly useful on multi-core machines with caches, since
the backend there can actively pass information between the two stages thus
improving substantially the performance.</p>
<p>To execute a given <a class="reference internal" href="../glossary/glossary.html#term-multi-stage"><span class="xref std std-term">Multi-Stage</span></a>, the
<cite>run</cite> method has to be called. Data has to be assigned to each non-temporary
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholder</span></a>.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">horizontal_diffusion</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">,</span> <span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No data can be assigned to temporary fields (i.e., <cite>tmp_arg</cite>
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a>). Storage for all temporary arguments is
managed by <cite>GridTools</cite>.</p>
</div>
<p>In case that the stencil is always run on the same data fields, you can also
assign those fields to the respective placeholders directly in the
<code class="docutils literal"><span class="pre">make_computation</span></code> call, i.e. at definition time instead of run time, e.g.:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">,</span> <span class="c1">// data assignment happens here</span>
    <span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">,</span> <span class="c1">// and here</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="n">make_independent</span><span class="p">(</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">())),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">horizontal_diffusion</span><span class="p">.</span><span class="n">run</span><span class="p">()</span> <span class="c1">// no data has to be specified here</span>
</pre></div>
</div>
<p>You can mix the two patterns, that is, assign data to some placeholders at
definition time and to some at run time. But each placeholder needs exactly one
data assignment, either inside <code class="docutils literal"><span class="pre">make_computation</span></code> or inside the <code class="docutils literal"><span class="pre">run</span></code>
method. It is therefore not possible to override definition-time assignments
present in <code class="docutils literal"><span class="pre">make_computation</span></code> at run time in the <code class="docutils literal"><span class="pre">run</span></code> method.</p>
<p>There are other details that pertain <a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a>,
<a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a> and also other <cite>GridTools</cite>
constructs that can greatly improve performance of the computations, especially
<a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a>.</p>
</div>
<div class="section" id="selecting-the-backend">
<span id="backend-selection"></span><h3>Selecting the Backend<a class="headerlink" href="#selecting-the-backend" title="Permalink to this headline">¶</a></h3>
<p>One of the key concepts of <cite>GridTools</cite> is portability between different target architectures.
Stencil operators are written and composed in an architecture-independent way and then instantiated
for a given <code class="docutils literal"><span class="pre">backend</span></code>. The <code class="docutils literal"><span class="pre">backend</span></code> is a tag type with a <code class="docutils literal"><span class="pre">target</span></code> argument with the following possible values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">target::cuda</span></code>: a GPU-enabled backend for NVIDIA GPUs</li>
<li><code class="docutils literal"><span class="pre">target::mc</span></code>: a backend for modern CPUs with long vector-length.</li>
<li><code class="docutils literal"><span class="pre">target::x86</span></code>: a legacy CPU-backend with focus on caching of vertical stencils, likely to be removed in the future.</li>
</ul>
<p>Currently we recommend one of the following two backends for optimal performance</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>for GPUs or</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">mc</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>for modern CPUs or Xeon Phis.</p>
</div>
</div>
<div class="section" id="advanced-functionality">
<h2>Advanced Functionality<a class="headerlink" href="#advanced-functionality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="stencil-functions">
<span id="id10"></span><h3>Stencil Functions<a class="headerlink" href="#stencil-functions" title="Permalink to this headline">¶</a></h3>
<p>Stencil functions offer the possibility to call <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a> from other <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a>.
To use stencil functions the header</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/stencil_composition/stencil_functions/stencil_functions.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>needs to be included.
Two variants are available: functional calls which return a value and procedural calls with side-effect on the given arguments (<a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>).</p>
<div class="section" id="function-calls-call">
<h4>Function Calls: <cite>call&lt;&gt;</cite><a class="headerlink" href="#function-calls-call" title="Permalink to this headline">¶</a></h4>
<p>The basic syntax for function calls is as follows</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="k">call</span><span class="o">&lt;</span><span class="n">stencil_operator</span><span class="p">,</span> <span class="n">vertical_interval</span><span class="p">,</span> <span class="n">return_value_type</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">accessors</span><span class="p">...);</span>
</pre></div>
</div>
<p>Let us describe the template parameters first:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">stencil_operator</span></code> is the operator to be called.</li>
<li><code class="docutils literal"><span class="pre">vertical_interval</span></code> is the <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> where the operator will be applied (it can be empty, if the
stencil operator has an apply method without a vertical region).</li>
<li><code class="docutils literal"><span class="pre">return_value_type</span></code> is the type of the return value for the function call. The <code class="docutils literal"><span class="pre">return_value_type</span></code> will be
automatically deduced from the first <code class="docutils literal"><span class="pre">accessor</span></code> if not specified explicitly.</li>
</ul>
<p>The context object <code class="docutils literal"><span class="pre">eval</span></code> has to be passed as the first argument to <code class="docutils literal"><span class="pre">with</span></code>, followed by the
<a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> which are arguments of the operator.</p>
<p>Note that the first accessor in the stencil operator must be an artificial accessor of type <code class="docutils literal"><span class="pre">inout_accessor</span></code>. This
argument must not be passed to the function, but instead it is the return value of the function.</p>
<p>Example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">lap_function</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">out</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// artificial first accessor</span>
    <span class="k">using</span> <span class="n">in</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">4.</span> <span class="o">*</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">())</span> <span class="o">-</span>
            <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// later:</span>
<span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">call</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">param</span><span class="p">());</span> <span class="c1">// only one parameter</span>
</pre></div>
</div>
<p>This function calculates the laplacian of a field. Note that the function is called only with one parameter, because the
first accessor (<code class="docutils literal"><span class="pre">out</span></code>) is the artificial accessor representing the return value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you pass a vertical interval to <code class="docutils literal"><span class="pre">call</span></code>, a matching apply method needs to exist in the called operator.</p>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> which are passed in the function call can have offsets in the usual way. Additionally the whole operator can be shifted to be executed
on a different grid point, by specifying a relative location with <code class="docutils literal"><span class="pre">at</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">call</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">at</span><span class="o">&lt;</span><span class="n">offset_i</span><span class="p">,</span> <span class="n">offset_j</span><span class="p">,</span> <span class="n">offset_k</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(...);</span>
</pre></div>
</div>
<p>For example, you can evaluate the laplacian at the next k-level as follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">call</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;::</span><span class="k">at</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">param</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="procedure-calls-call-proc">
<h4>Procedure Calls: <cite>call_proc&lt;&gt;</cite><a class="headerlink" href="#procedure-calls-call-proc" title="Permalink to this headline">¶</a></h4>
<p>Procedural calls work in the same way as function calls, but all <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>, which are <code class="docutils literal"><span class="pre">inout</span></code> in the operator,
can be modified.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">call_proc</span><span class="o">&lt;</span><span class="n">stencil_operator</span><span class="p">,</span> <span class="n">vertical_interval</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">accessors</span><span class="p">...);</span>
</pre></div>
</div>
<p>Also offsets work the same way as for function calls. Using <code class="docutils literal"><span class="pre">at</span></code> with <code class="docutils literal"><span class="pre">call_proc</span></code> is not recommended and support
might be dropped in the future.</p>
<p>You can call the laplacian above with the following syntax:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">call_proc</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">lap</span><span class="p">(),</span> <span class="n">param</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="software-managed-caches">
<span id="caches"></span><h3>Software-Managed Caches<a class="headerlink" href="#software-managed-caches" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a> are syntax elements that are used
to describe data reuse pattern of the stencil computations.
They are an essential functionality of the <cite>GridTools</cite> in order
to deliver an efficient implementation of memory bound codes,
since the library uses
this information to allocate cached fields in a fast on-chip
scratch-pad memory.</p>
<p>In computing architectures like NVIDIA GPUs, where the use of
the different on-chip memory hierarchy must be explicitly
declared using the CUDA programming model, the use of <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed
Caches</span></a> of <cite>GridTools</cite> increases the data locality of stencil algorithms
and provides a significant performance speedup.</p>
<p>While the library is capable of exploiting several on-chip memory layers
(like texture cache, const cache, shared memory, and registers of NVIDIA GPUs)
the <cite>GridTools</cite> language is abstracting these underlying memory layers and
exposes syntax elements that are computing architecture agnostic.</p>
<p>Therefore the <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Cache</span></a> syntax should be used by the
user to describe <em>only</em> data reuse patterns, and not type of
on-chip memory that should be exploited (which is a decision delegated to
the computing architecture backend of the library).</p>
<p>An example of the syntax for caching certain fields of a
computation is shown below</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
   <span class="k">grid</span><span class="p">,</span>
   <span class="nl">make_multistage</span><span class="p">(</span>
       <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>
       <span class="nl">define_caches</span><span class="p">(</span><span class="k">cache</span><span class="o">&lt;</span><span class="nn">cache_type</span><span class="o">::</span><span class="n">ij</span><span class="p">,</span> <span class="nn">cache_io_policy</span><span class="o">::</span><span class="k">local</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">())),</span>
       <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
       <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">())</span>
   <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> DSL elements are enclosed into a <code class="docutils literal"><span class="pre">define_caches</span></code> construct,
that accept any number of <code class="docutils literal"><span class="pre">cache</span></code> constructs. At the same time, each
<code class="docutils literal"><span class="pre">cache</span></code> construct can specify multiple fields that shared the same
access pattern.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important to note that the <code class="docutils literal"><span class="pre">cache</span></code> specifications
are prescribing the behavior of the library: if a <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a>
is specified, a <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> will be used. In the rare case of
using too many <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Caches</span></a> a decrease in performance might be
observed due to saturation of available resources</p>
</div>
<p>The <code class="docutils literal"><span class="pre">cache</span></code> construct adheres to the following syntax:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">cache</span><span class="o">&lt;</span><span class="nn">cache_type</span><span class="p">,</span> <span class="nn">cache_io_policy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_args</span><span class="p">...)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">p_args...</span></code> is a list of placeholders for which the specified caching
should be used.
Full examples on <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> usages can be found in the source code in the
<a class="reference external" href="https://github.com/eth-cscs/gridtools/blob/master/gt_examples/stencil_composition/horizontal_diffusion_limited.cpp">horizontal diffusion</a>
and
<a class="reference external" href="https://github.com/eth-cscs/gridtools/blob/master/regression/vertical_advection_dycore.cpp">vertical advection</a>.</p>
<p>We now describe the details of each element of the <code class="docutils literal"><span class="pre">cache</span></code> constructs.</p>
<div class="section" id="cache-type">
<span id="id11"></span><h4>Cache Type<a class="headerlink" href="#cache-type" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cache_type</span></code> describes the type of access pattern present in our stencil for the field being cached. It’s
value can be one of the following (where we indicate the basic mean of implementation on the GPUs, so that the user can understand the amount of resources involved):</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">cache_type::ij</span></code>: cache data fields whose access pattern lies in the ij-plane, i.e. only offsets of the type <cite>i ±
X</cite> or <cite>j ± Y</cite> are allowed (the GPU backend will cache these fields in shared memory). It is undefined behaviour to
access data with k-offsets.</li>
<li><code class="docutils literal"><span class="pre">cache_type::k</span></code>: cache data field whose access pattern is restricted to the k-direction, i.e. only offsets of the
type <cite>k ± Z</cite> (the GPU backend will cache these fields in registers). It is undefined behaviour to access data with
offsets in i or j direction.</li>
</ol>
</div>
<div class="section" id="cache-policy">
<span id="id12"></span><h4>Cache Policy<a class="headerlink" href="#cache-policy" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cache_policy</span></code> specifies a synchronization policy between the data in the <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> and the data in main memory. A scratch-pad can be used
in order to allocate temporary computations that do not require data persistency across multiple stencils. However often the data that is
being cached is already present in main memory fields. In this case, the <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a> of <cite>GridTools</cite> gives the possibility
to specify a cache policy that allows to synchronize the main memory with the cached field.
The possible values are:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">cache_io_policy::fill</span></code>: fill the scratch-pad buffer with data from main memory field before use.</li>
<li><code class="docutils literal"><span class="pre">cache_io_policy::flush</span></code>: After the execution of the stencil operators the data in the <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> is written back into the main memory fields.</li>
<li><code class="docutils literal"><span class="pre">cache_io_policy::fill_and_flush</span></code>: The combination of <code class="docutils literal"><span class="pre">fill</span></code> and <code class="docutils literal"><span class="pre">flush</span></code></li>
<li><code class="docutils literal"><span class="pre">cache_io_policy::local</span></code>: The scratch-pad data is not persistent and only available within the scope of a
multi-stage. Local caches are only meaningful in connection with temporary arguments.</li>
</ol>
<blockquote>
<div><a class="reference internal" href="#fig-kcache-ex"><span class="std std-numref">Fig. 6</span></a> graphically depicts an example of all the ordered operations that are executed when a <code class="docutils literal"><span class="pre">fill_and_flush</span></code>
<a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> is used in a forward vertical loop.</div></blockquote>
<div class="figure" id="id25">
<span id="fig-kcache-ex"></span><a class="reference internal image-reference" href="../_images/kcache_ex.png"><img alt="../_images/kcache_ex.png" src="../_images/kcache_ex.png" style="width: 759.5px; height: 420.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Representation of an implementation for a <code class="docutils literal"><span class="pre">cache&lt;cache_type::k,</span> <span class="pre">cache_io_policy::fill_and_flush&gt;</span></code> that is used within a
stencil with <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extent</span></a> <code class="docutils literal"><span class="pre">&lt;-2,</span> <span class="pre">1&gt;</span></code> in the vertical dimension and implemented as a ring-buffer with 4 levels (in order to allocate all possible offsetted accesses). The three operations
are triggered automatically by the library for a <cite>fill_and_flush</cite> <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> when the vertical loop transition from level 9 to level 10.</span></p>
</div>
</div>
</div>
<div class="section" id="expandable-parameters">
<span id="id13"></span><h3>Expandable Parameters<a class="headerlink" href="#expandable-parameters" title="Permalink to this headline">¶</a></h3>
<p>Expandable parameters implement a “single stencil multiple storages” pattern.
They are useful when we have a vector of storages which have the same
storage info, and we want to perform the same operation with all of them
(a typical situation when implementing e.g. time differentiation schemes).
Normally this could be achieved by creating a loop and running multiple computations,
but this solution would be inefficient. A more efficient solution is provided
through the expandable parameters API.</p>
<p>The user must collect the storage pointers in a <code class="docutils literal"><span class="pre">std::vector</span></code></p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">storage_t</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">storage1</span><span class="p">,</span> <span class="n">storage2</span><span class="p">,</span> <span class="n">storage3</span><span class="p">,</span> <span class="n">storage4</span><span class="p">,</span> <span class="n">storage5</span><span class="p">,</span> <span class="n">storage6</span><span class="p">,</span> <span class="n">storage7</span><span class="p">,</span> <span class="n">storage8</span><span class="p">};</span>
</pre></div>
</div>
<p>This <code class="docutils literal"><span class="pre">std::vector</span></code> is then used as a storage type with no differences with respect to
the regular storages.</p>
<p>The implementation requires the user to specify an integer <code class="docutils literal"><span class="pre">expand_factor</span></code> when defining the computation.
The optimal value for <code class="docutils literal"><span class="pre">expand_factor</span></code> might need to be tuned for different backends.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comp_</span> <span class="o">=</span> <span class="nl">make_expandable_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
       <span class="k">expand_factor</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span>
       <span class="n">domain_</span><span class="p">,</span>
       <span class="n">grid_</span><span class="p">,</span>
       <span class="nl">make_multistage</span><span class="p">(</span><span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())));</span>
<span class="n">comp</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">p</span><span class="p">()</span> <span class="o">=</span> <span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
<p>The vector of
storages is then partitioned into chunks of <code class="docutils literal"><span class="pre">expand_factor</span></code> size (with a remainder). Each
chunk is unrolled within a computation, and for each chunk a different computation is
instantiated. The remainder elements are then processed one by one.</p>
<p>Summing up, the only differences with respect to the case without expandable parameters are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">make_expandable_computation</span></code> has to be used instead of <code class="docutils literal"><span class="pre">make_computation</span></code></li>
<li>an <code class="docutils literal"><span class="pre">expand_factor</span></code> has to be passed to the <code class="docutils literal"><span class="pre">make_expandable_computation</span></code>, defining the size of the chunks of</li>
<li>expandable parameters should be unrolled in each computation.</li>
<li>a <code class="docutils literal"><span class="pre">std::vector</span></code> of storage pointers has to be used instead of a single storage.</li>
</ul>
<p>All the rest is managed by <cite>GridTools</cite>, so that the user is not exposed to the complexity of the
unrolling, he can reuse the code when the expand factor changes, and he can resize dynamically the expandable
parameters vector, for instance by adding or removing elements.</p>
</div>
<div class="section" id="global-parameters-and-accessors">
<span id="global-accessor"></span><h3>Global Parameters and Accessors<a class="headerlink" href="#global-parameters-and-accessors" title="Permalink to this headline">¶</a></h3>
<p>Global accessors are accessing read-only data which is independent of the current <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.
For this reason, intent, <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extents</span></a> and offsets cannot be specified for a global accessor.
Here the term <cite>global</cite> means that the data is the same for the whole <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>. An example can be
a constant scalar parameter that you want to pass to the functor, or a user defined struct containing
various configuration options.</p>
<p>The API allows the user to define an arbitrary object to act as a <a class="reference internal" href="../glossary/glossary.html#term-global-parameter"><span class="xref std std-term">Global Parameter</span></a> as long as it is trivially copyable.
To create a <a class="reference internal" href="../glossary/glossary.html#term-global-parameter"><span class="xref std std-term">Global Parameter</span></a> from a user-defined object, we pass the object to <code class="docutils literal"><span class="pre">make_global_parameter()</span></code></p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">my_global_parameter</span> <span class="o">=</span> <span class="n">backend_t</span><span class="o">::</span><span class="nl">make_global_parameter</span><span class="p">(</span><span class="n">my_object</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the object is read-only only during the execution of a computation, but can be modified
in between executions with</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">backend_t</span><span class="o">::</span><span class="nl">update_global_parameter</span><span class="p">(</span><span class="n">my_global_parameter</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> associated with a global parameter must be a global accessor</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">global_acc</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal"><span class="pre">eval</span></code> on the global accessor returns the user defined data structure. Supposing that
this data structure contains a user function called <code class="docutils literal"><span class="pre">ordinal</span></code>, returning an integer, we can write
in the do method</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ordinal_</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">global_boundary</span><span class="p">()).</span><span class="n">ordinal</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All the member functions defined in the user-defined data structure must be labeled with <code class="docutils literal"><span class="pre">GT_FUNCTION</span></code>, in order for
them to be callable from devices.</p>
</div>
<p>There is a special case for which we have a dedicated API: i.e. when the user defined object
(the global parameter)
defines the parenthesis operator <code class="docutils literal"><span class="pre">operator()</span></code>, and we want to call that operator from the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a>.
In that case the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor’s</span></a> parenthesis operator can be used and the arguments will be
automatically forwarded to the global parameter. An example is the case in which we want to pass
a small matrix as a global parameter:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="boundary-conditions">
<span id="id14"></span><h2>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>The boundary condition module in <cite>GridTools</cite> is designed following the
principle that boundary conditions can be arbitrarily complex, so we
want the user to be able to specify any boundary condition code to set
up their problems.</p>
</div>
<div class="section" id="preliminaries">
<h3>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h3>
<p>One main concept that is needed for the boundary condition is the one
of <cite>direction</cite>.</p>
<p>In a 3D regular grid, which is where this implementation of the
boundary condition library applies, we associate a 3D axis system,
and the cell indices (i, j, k) naturally lie on it. With this axis
system the concept of “vector” can be defined to indicate
distances and directions. Direction is the one thing we need
here. Instead of using unitary vectors to indicate directions, as
it is usually the case for euclidean spaces, we use vectors whose
components are -1, 0, and 1.  For example, <span class="math">\((1, 1, 1)\)</span> is the
direction indicated by the unit vector <span class="math">\((1, 1, 1)/\sqrt3\)</span>.
If we take the center of a 3D grid, then we can define 26
different directions <span class="math">\(\{(i, j, k): i, j, k \in \{-1, 0, 1\}\}\setminus\{(0, 0, 0)\}\)</span>
that identify the different faces, edges and corners of the cube to
which the grid is topologically analogous with.</p>
<p>The main idea is that a boundary condition class specializes
<cite>operator()</cite> on a <cite>direction</cite>, or a subset of directions, and then
perform the user specified computation on the boundaries on those
directions.</p>
<p>The user can define their own boundary condition classes and perform
specific computation in each direction. For this reason <cite>GridTools</cite> provides
a <code class="docutils literal"><span class="pre">direction</span></code> type which can take three direction values, that are
indicated as <code class="docutils literal"><span class="pre">minus_</span></code>, <code class="docutils literal"><span class="pre">plus_</span></code> and <code class="docutils literal"><span class="pre">zero_</span></code>, which are values of an
<code class="docutils literal"><span class="pre">enum</span></code> called <code class="docutils literal"><span class="pre">sign</span></code>.</p>
</div>
<div class="section" id="boundary-condition-class">
<span id="boundary-conditions-class"></span><h3>Boundary Condition Class<a class="headerlink" href="#boundary-condition-class" title="Permalink to this headline">¶</a></h3>
<p>The boundary condition class is a regular class which need to be copy
constructible, and whose member functions should be decorated with the
<code class="docutils literal"><span class="pre">GT_FUNCTION</span></code> keyword to enable accelerators. It must not contain references to data that may be not available on the target device where the boundary conditions are applied.</p>
<p>The boundary condition class provides overloads for the <code class="docutils literal"><span class="pre">operator()</span></code>
which take as first argument a <code class="docutils literal"><span class="pre">direction</span></code> object, a number of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data
Stores</span></a> that are the inputs, and three integer values that will contains the
coordinate indices of the cell that is being iterated on.</p>
<p>All overloads must have the same number of arguments: the first argument is the direction over which the overload will be applied to, then there is the list of <a class="reference internal" href="../glossary/glossary.html#term-data-view"><span class="xref std std-term">Data Views</span></a> that will be accessed by the boundary class, and finally three integers that contains the indices of the element being accessed in the call.
It is standard practice to let the view types be template
arguments. For instance, here a class that applies a copy-boundary
condition (copy the second view into the first one) for all direction
apart all directions for which the third component is <code class="docutils literal"><span class="pre">minus_</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">example_bc</span> <span class="p">{</span>
   <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>

   <span class="cp">GT_FUNCTION</span>
   <span class="nf">example_bc</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Direction</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField1</span><span class="o">&gt;</span>
   <span class="cp">GT_FUNCTION</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Direction</span><span class="p">,</span>
                               <span class="n">DataField0</span> <span class="o">&amp;</span><span class="n">data_field0</span><span class="p">,</span> <span class="n">DataField1</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">data_field1</span><span class="p">,</span>
                               <span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">j</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>
   <span class="p">{</span>
     <span class="n">data_field0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">data_field1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">sign</span> <span class="n">I</span><span class="p">,</span> <span class="k">sign</span> <span class="n">J</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField1</span><span class="o">&gt;</span>
   <span class="cp">GT_FUNCTION</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">direction</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">minus_</span><span class="o">&gt;</span><span class="p">,</span>
                               <span class="n">DataField0</span> <span class="o">&amp;</span><span class="n">data_field0</span><span class="p">,</span> <span class="n">DataField1</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span>
                               <span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">j</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>
   <span class="p">{</span>
     <span class="n">data_field0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><cite>operator()</cite> of the boundary class is called by the library, on the 26 directions, and got each value in the data that correspond to each direction. In the previous example, each direction in which the third component is <code class="docutils literal"><span class="pre">minus</span></code> will select the specialized overload, while all other directions select the first implementation.</p>
</div>
<div class="section" id="boundary-condition-application">
<h3>Boundary Condition Application<a class="headerlink" href="#boundary-condition-application" title="Permalink to this headline">¶</a></h3>
<p>To apply the above boundary conditions class to the data fields, we
need to construct the boundary object, but also to specify the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>
regions. The <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> regions are specified using
<a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptors</span></a>.</p>
<p>To do this we need an array of <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptors</span></a> initialized with the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information of the data fields.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fifth number, namely the total length, in the <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo
Descriptor</span></a> is not used by the boundary condition application module,
but we kept the same implementation we had in other parts of <cite>GridTools</cite> to
avoid introducing too many concepts. This will be improved
in the future.</p>
</div>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halos</span><span class="p">;</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d2</span><span class="p">);</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d3</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d3</span><span class="p">);</span>
</pre></div>
</div>
<p>After this is done we can apply the boundary condition by, as in this
example, constructing the boundary object and applying it to the data
fields. The number of data fields to pass is equal to the number of
fields the <code class="docutils literal"><span class="pre">operator()</span></code> overloads of the boundary class require.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">boundary</span><span class="o">&lt;</span><span class="n">example_bc</span><span class="p">,</span> <span class="n">backend_t</span><span class="o">::</span><span class="n">backend_id_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">halos</span><span class="p">,</span> <span class="n">example_bc</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
      <span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">out_s</span><span class="p">,</span> <span class="n">in_s</span><span class="p">);</span>
</pre></div>
</div>
<p>As can be noted, the <code class="docutils literal"><span class="pre">backend</span></code> is also needed to select the proper
implementation of the boundary application algorithm (see <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>). <code class="docutils literal"><span class="pre">out_s</span></code> and
<code class="docutils literal"><span class="pre">in_s</span></code> are the two data fields passed to the application. The fact
that the first is the output and second is the input derives from the
signature of the overloads of <code class="docutils literal"><span class="pre">operator()</span></code>, and it is user defined.</p>
</div>
<div class="section" id="boundary-predication">
<h3>Boundary Predication<a class="headerlink" href="#boundary-predication" title="Permalink to this headline">¶</a></h3>
<p>Predication is an additional feature to control the boundary
application.  The predicate type have to be specified as template
argument of the boundary class, and the instantiated object of that
type passed as third argument of the boundary class constructor, as in
the following example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">boundary</span><span class="o">&lt;</span><span class="n">direction_bc_input</span><span class="o">&lt;</span><span class="n">uint_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">backend_t</span><span class="o">::</span><span class="n">backend_id_t</span><span class="p">,</span> <span class="n">predicate_t</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">halos</span><span class="p">,</span> <span class="n">direction_bc_input</span><span class="o">&lt;</span><span class="n">uint_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="n">predicate_t</span><span class="p">{}).</span><span class="n">apply</span><span class="p">(</span><span class="n">out_s</span><span class="p">,</span> <span class="n">in_s</span><span class="p">);</span>
</pre></div>
</div>
<p>The predicate must obey a fixed interface, that is, it has to accept
as argument a <code class="docutils literal"><span class="pre">direction</span></code> object, so that the user can, at runtime,
disable some <code class="docutils literal"><span class="pre">operator()</span></code> overloads. This can be very useful when
the user is running on a parallel domain decomposed domain, and only
the global boundaries need to updated with the boundary conditions
application and the rest should have their <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a> updated from
neighbors.</p>
</div>
<div class="section" id="provided-boundary-conditions">
<span id="id15"></span><h3>Provided Boundary Conditions<a class="headerlink" href="#provided-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> provides few boundary application classes for some common cases. They are</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">copy_boundary</span></code> to copy the boundary of the last field of the argument list of <cite>apply</cite> into the other ones;</li>
<li><code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span> <span class="pre">value_boundary</span></code> to set the boundary to a value for all the data fields provided;</li>
<li><code class="docutils literal"><span class="pre">zero_boundary</span></code> to set the boundary to the default constructed value type of the data fields (usually a zero) for the input fields.</li>
</ul>
</div>
</div>
<div class="section" id="halo-exchanges">
<span id="id16"></span><h2>Halo Exchanges<a class="headerlink" href="#halo-exchanges" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id17">
<h3>Introduction<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>The communication module in <cite>GridTools</cite> is dubbed <a class="reference internal" href="../glossary/glossary.html#term-gcl"><span class="xref std std-term">GCL</span></a>. It’s a low level
halo-update interface for 3D fields that takes 3D arrays of some
types, and the descriptions of the halos, and perform the exchanges in
a scalable way.</p>
<p>It is low-level because the requirements from which it was initially
designed, required easy interoperability with C and Fortran, so the API
takes pointers and sizes. The sizes are specified by
<code class="docutils literal"><span class="pre">halo_descriptor</span></code>, which are loosely inspired by the BLAS description
of dimensions of matrices. A new, more modern set of interfaces are
being implemented, to serve more general cases, such as higher
dimensions and other grids.</p>
<p>We first start with some preliminaries and then discuss the main
interfaces.</p>
</div>
<div class="section" id="id18">
<h3>Preliminaries<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<div class="section" id="processor-grid">
<h4>Processor Grid<a class="headerlink" href="#processor-grid" title="Permalink to this headline">¶</a></h4>
<p>The processor grid is a concept that describe a 3D lattice of
computing elements (you may think of those as MPI tasks). The
identifiers of them are tuples of indices. This naturally maps to a 3D
decomposition of a data field.</p>
</div>
<div class="section" id="layout-map">
<h4>Layout Map<a class="headerlink" href="#layout-map" title="Permalink to this headline">¶</a></h4>
<p>The communication layer needs two <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Maps</span></a>:
one for describing the data, and one for the
processor grid. For the user, the dimensions of the data are always
indicated as first, second, and third (or i, j, k), it is the
<a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> that indicates the stride orders, as in the following example:</p>
<p>For instance:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="c1">//         i, j, k</span>
<span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> indicates that the first dimension in the data (i) is the
second in the decreasing stride order, while the second (j) has the
biggest stride, and last dimension (k) is the one with stride 1. The
largest strides are associated to smaller indices, so that
<code class="docutils literal"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code> corresponds to a C-layout, while
<code class="docutils literal"><span class="pre">layout_map&lt;2,</span> <span class="pre">1,</span> <span class="pre">0&gt;</span></code> to a Fortran layout.</p>
<p>The second template <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> in the <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a>
pattern is the map between data coordinates and the processor
grid coordinates.</p>
<p>The following layout specification</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>would mean: The first dimension in data matches with the second
dimension of the computing grid, the second dimension of the data to
the first of the processing grid, and the third one to the third
one. This is rarely different from <code class="docutils literal"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code>, so it can
generally be ignored, but we give an example to clarify its meaning.</p>
<p>Suppose the processor grid (domain decomposition sizes) has size PIxPJx1. Now, we want
to say that the first dimension on data ‘extends’ to the
computing grid on (or that the first dimension in the data corresponds
to) the first dimension in the computing grid. Let’s consider a 2x1
process grid, and the first dimension of the data being the rows (i)
and the second the column (j). In this case we are assuming a
distribution like in <a class="reference internal" href="#fig-dist1"><span class="std std-numref">Fig. 7</span></a>.</p>
<div class="figure" id="id26">
<span id="fig-dist1"></span><a class="reference internal image-reference" href="../_images/dist1.png"><img alt="../_images/dist1.png" src="../_images/dist1.png" style="width: 624.4000000000001px; height: 405.20000000000005px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Example data distribution among two processes.</span></p>
</div>
<p>In this case the map between data and the processor grid is:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="c1">// The 3rd dimension stride is 1</span>
</pre></div>
</div>
<p>On the other hand, having specified</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for this map, would imply a layout/distribution like the following <a class="reference internal" href="#fig-dist2"><span class="std std-numref">Fig. 8</span></a>.</p>
<div class="figure" id="id27">
<span id="fig-dist2"></span><a class="reference internal image-reference" href="../_images/dist2.png"><img alt="../_images/dist2.png" src="../_images/dist2.png" style="width: 447.6px; height: 464.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Example data distribution among two processes.</span></p>
</div>
<p>Where the second dimension in the data correspond to the fist
dimension in the processor grid. Again, the data coordinates
ordering is the one the user choose to be the logical order in the
application, not the increasing stride order.</p>
</div>
<div class="section" id="halo-descriptor">
<span id="id19"></span><h4>Halo Descriptor<a class="headerlink" href="#halo-descriptor" title="Permalink to this headline">¶</a></h4>
<p>Given  a  dimension of  the  data  (array), the  communication  module
requires the user to describe it using the <code class="docutils literal"><span class="pre">halo_descriptor</span></code> class,
which takes five integers. This class identifies the data that needs
to be exchanged.</p>
<p>Consider a dimension which has <code class="docutils literal"><span class="pre">minus</span></code> halo lines on one side, and
<code class="docutils literal"><span class="pre">plus</span></code> halo lines on the other (The minus and plus indicate the sides
close to index 0 and the last index of the dimension,
respectively). The beginning of the inner region is marked by <code class="docutils literal"><span class="pre">begin</span></code>
and its ending by <code class="docutils literal"><span class="pre">end</span></code>. The end is inclusive, meaning that the index
specified by it, is part of the inner region. Another value is
necessary, which has to be larger than <code class="docutils literal"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">begin</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">minus</span> <span class="pre">+</span> <span class="pre">plus</span></code>, and
is the <code class="docutils literal"><span class="pre">total_length</span></code>. This parameter is the equivalent of the
“leading dimension” in BLAS. With these five numbers we can describe
arbitrary dimensions, with paddings on the left and on the right, such
as the example in <a class="reference internal" href="#fig-halo-descriptor"><span class="std std-numref">Fig. 9</span></a>.</p>
<p>The interface for specifying a halo descriptor is fairly simple, where
the name of arguments should be self-explanatory:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">halo_descriptor</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">minus</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">plus</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">begin</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">total_length</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">annotate example with minus plus begin and end</p>
</div>
<div class="figure" id="id28">
<span id="fig-halo-descriptor"></span><a class="reference internal image-reference" href="../_images/halo_descriptor.png"><img alt="../_images/halo_descriptor.png" src="../_images/halo_descriptor.png" style="width: 480.5px; height: 284.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Example halo descriptor with one halo point on the left and two on the right.</span></p>
</div>
</div>
</div>
<div class="section" id="gcl-communication-module">
<span id="id20"></span><h3>GCL Communication Module<a class="headerlink" href="#gcl-communication-module" title="Permalink to this headline">¶</a></h3>
<p>Now we are ready to describe the <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> patterns objects. The first one is <code class="docutils literal"><span class="pre">halo_exchange_dynamic_ut</span></code>. The <code class="docutils literal"><span class="pre">ut</span></code> suffix stands for <code class="docutils literal"><span class="pre">uniform</span> <span class="pre">types</span></code>, meaning that the data fields that this object will manage must all store the same value types, that are declared at instantiation time. The type of the object is defined as in this example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pattern_type</span> <span class="o">=</span> <span class="nl">halo_exchange_dynamic_ut</span><span class="o">&lt;</span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span>
                     <span class="n">ayout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">gcl_cpu</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The template arguments are:</p>
<ol class="arabic simple">
<li>the layout if the data;</li>
<li>the mapping between the data dimensions and processing <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>, as described above (leave it as <code class="docutils literal"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code> if in doubt);</li>
<li>the type of the values to be exchanged;</li>
<li>the number of dimensions of the data/processing grid, and it has to be set to 3 (the GCL was designed to work with other dimensionalities, but the version in <cite>GridTools</cite> is a stripped down version waiting for the next more general interfaces);</li>
<li>the place where the data lives and for which the code is optimized. The options for this arguments are <code class="docutils literal"><span class="pre">gcl_gpu</span></code>, <code class="docutils literal"><span class="pre">gcl_cpu</span></code> and <code class="docutils literal"><span class="pre">gcl_mc</span></code> (not supported yet).</li>
</ol>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> object can be instantiated as:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">pattern_type</span> <span class="nf">he</span><span class="p">(</span><span class="n">pattern_type</span><span class="o">::</span><span class="n">grid_type</span><span class="o">::</span><span class="n">period_type</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span> <span class="n">CartComm</span><span class="p">);</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">period_type</span></code> indicates whether the corresponding dimensions are
periodic or not. <code class="docutils literal"><span class="pre">CartComm</span></code> is the MPI communicator describing the
computing grid.</p>
<p>After the object has been instantiated, the
user registers the halos for the corresponding dimension and the five
numbers we described above, for the three dimensions (0 is the first
dimension).</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus0</span><span class="p">,</span> <span class="n">plus0</span><span class="p">,</span> <span class="n">begin0</span><span class="p">,</span> <span class="n">end0</span><span class="p">,</span> <span class="n">len0</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus1</span><span class="p">,</span> <span class="n">plus1</span><span class="p">,</span> <span class="n">begin1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus2</span><span class="p">,</span> <span class="n">plus2</span><span class="p">,</span> <span class="n">begin2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">len2</span><span class="p">);</span>
</pre></div>
</div>
<p>When the registration is done a setup function must be called before
running data exchange. The argument in the set up function is the
maximum number of data arrays that the pattern will exchange in a
single step. In this example we set it to 3, so that exchanging more
than 3 fields will lead to a runtime error. Be aware that setting a
larger number of supported fields leads to larger memory allocations.
The code looks like:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we are ready to exchange the data, by passing (up to) three
pointers to the data to pack, then calling exchange and then unpack
into the destination data, as in the following example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">array0</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">start_exchange</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">array0</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, the pointers can be put in a <code class="docutils literal"><span class="pre">std::vector&lt;value_type*&gt;</span></code> so that the code would look like:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">vector_of_pointers</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">start_exchange</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">vector_of_pointers</span><span class="p">);</span>
</pre></div>
</div>
<p>An alternative pattern supporting different element types is:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pattern_type</span> <span class="o">=</span> <span class="nl">halo_exchange_generic</span><span class="o">&lt;</span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">arch_type</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> in the type is the mapping of dimensions to the
computing grid, 3 is the number of dimensions, and arch_type is either
<code class="docutils literal"><span class="pre">gcl_gpu</span></code>, <code class="docutils literal"><span class="pre">gcl_cpu</span></code> or <code class="docutils literal"><span class="pre">gcl_mc</span></code> (not supported yet).</p>
<p>The construction of the object is identical to the previous one, but
the set-up somewhat more complex now, since we have to indicate the
maximum sizes and number of fields we will exchange using this object.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halo_dsc</span><span class="p">;</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">DIM1</span> <span class="o">+</span> <span class="n">H1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H1</span><span class="p">);</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">DIM2</span> <span class="o">+</span> <span class="n">H2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H2</span><span class="p">);</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H3</span><span class="p">,</span> <span class="n">H3</span><span class="p">,</span> <span class="n">H3</span><span class="p">,</span> <span class="n">DIM3</span> <span class="o">+</span> <span class="n">H3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H3</span><span class="p">);</span>

<span class="n">he</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// maximum number of fields</span>
         <span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">layoutmap</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">,</span> <span class="n">halo_dsc</span><span class="p">),</span>
         <span class="k">sizeof</span><span class="p">(</span><span class="n">biggest_type_to_be_used</span><span class="p">));</span> <span class="c1">// Estimates the sizes</span>
</pre></div>
</div>
<p>The halo descriptors above indicate the largest arrays the user will
exchange, while the <code class="docutils literal"><span class="pre">field_on_the_fly</span></code> specify a type and layout
(and mandatory traits). The type does not have any effect here, and
neither the layout. The traits are important, and the halos are
essential.  With this pattern, the user needs to indicate what is the
size of the largest value type they will exchange.</p>
<p>When using the pattern, each data field should be wrapped into a
<code class="docutils literal"><span class="pre">field_on_the_fly</span></code> object, such as</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type1</span><span class="p">,</span> <span class="n">layoutmap1</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field1</span><span class="p">(</span>
    <span class="n">ptr1</span><span class="p">,</span> <span class="n">halo_dsc1</span><span class="p">);</span>
<span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type2</span><span class="p">,</span> <span class="n">layoutmap2</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field2</span><span class="p">(</span>
    <span class="n">ptr2</span><span class="p">,</span> <span class="n">halo_dsc2</span><span class="p">);</span>
<span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type3</span><span class="p">,</span> <span class="n">layoutmap3</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field3</span><span class="p">(</span>
    <span class="n">ptr3</span><span class="p">,</span> <span class="n">halo_dsc3</span><span class="p">);</span>
</pre></div>
</div>
<p>Now each field can have different types and layouts, and halo
descriptors. The exchange happens very similarly as before:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">);</span>

<span class="n">he</span><span class="p">.</span><span class="n">exchange</span><span class="p">();</span>

<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">);</span>
</pre></div>
</div>
<p>The interface accepting a <code class="docutils literal"><span class="pre">std::vector</span></code> also works for this pattern (in case all the
fields have the same type).</p>
</div>
</div>
<div class="section" id="distributed-boundary-conditions">
<span id="id21"></span><h2>Distributed Boundary Conditions<a class="headerlink" href="#distributed-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="design-principles">
<h3>Design Principles:<a class="headerlink" href="#design-principles" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>When doing expandable parameters, the user may want to apply BCs and perform communications on a sub-set of the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> collected in these data representations. For this reason an interface for applying distributed boundary conditions takes single data-stores only.</li>
<li>The user may want to apply different BCs to the same data-store at different times during an executions, so the binding between BCs and data-stores should be done at member-function level, not at class level, in order to remove the need for instantiation of heavy objects like <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-updates.</li>
<li>The same holds for the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> to be exchanged: we need to plug the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> at the last minute before doing the packing/unpacking and boundary apply. The requirement given by the underlying communication layer is that the number of data fields to be exchanged must be less than or equal to the maximum number of data fields specified at construction time.</li>
<li>The <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> patterns are quite heavy objects so they have to be constructed and passed around as references. The <code class="docutils literal"><span class="pre">setup</span></code> needs to be executed only once to prevent memory leaks.</li>
<li>The <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information for communication could be derived by a <code class="docutils literal"><span class="pre">storage_info</span></code> class, but there may be cases in which a separate <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information can be provided, and different <code class="docutils literal"><span class="pre">storage_info</span></code> s (with different indices, for instance) may have the same communication requirements (for instance in cases of implicit staggering). For this reason the <cite>halo_descriptor</cite> is passed explicitly to the distributed boundary construction interface.</li>
<li>The <code class="docutils literal"><span class="pre">value_type</span></code> should be passed as an additional template parameter to the distributed boundaries interfaces. The <code class="docutils literal"><span class="pre">value_type</span></code> is used to compute the sizes of the buffers and the data movement operations needed by communication.</li>
</ul>
</div>
<div class="section" id="communication-traits">
<h3>Communication Traits<a class="headerlink" href="#communication-traits" title="Permalink to this headline">¶</a></h3>
<p>Communication traits helps the distributed boundary condition interface to customize itself to the need of the user. A general communication traits class is available in <code class="docutils literal"><span class="pre">distributed_boundaries/comm_traits.hpp</span></code>. The traits required by the distributed boundaries interface, as provided by <cite>GridTools</cite>, are listed below here.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">StorageType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arch</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">comm_traits</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">proc_layout</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">layout_map</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// Layout of the processing grid to relate the data layout to the distribution of data</span>
  <span class="k">using</span> <span class="n">proc_grid_type</span> <span class="o">=</span> <span class="n">MPI_3D_process_grid_t</span><span class="p">;</span> <span class="c1">// Type of the computing grid</span>
  <span class="k">using</span> <span class="n">comm_arch_type</span> <span class="o">=</span> <span class="n">Arch</span><span class="p">;</span> <span class="c1">// Architecture for the communication pattern</span>
  <span class="n">compute_arch</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="p">...;</span> <span class="c1">// Architecture of the stencil/boundary condition backend</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span> <span class="o">=</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">packing_version</span><span class="o">::</span><span class="p">...;</span> <span class="c1">// Packing/Unpacking version</span>
  <span class="k">using</span> <span class="n">data_layout</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">StorageType</span><span class="o">::</span><span class="n">storage_info_t</span><span class="o">::</span><span class="n">layout_t</span><span class="p">;</span> <span class="c1">// Layout of data</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">StorageType</span><span class="o">::</span><span class="n">data_t</span><span class="p">;</span> <span class="c1">// Value Type</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="binding-boundaries-and-communication">
<h3>Binding Boundaries and Communication<a class="headerlink" href="#binding-boundaries-and-communication" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> provides a facility for applying boundary conditions. The distributed boundaries interfaces uses this facility underneath. The boundary application in <cite>GridTools</cite> accept specific boundary classes that specify how to deal with boundaries in different directions and predicated to deal with periodicity and domain decomposition. The latter will be dealt by the distributed boundary interfaces (refer to the boundary condition interfaces for more details).</p>
<p>The distributed boundaries interface require a user to specify which <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> required communication and which require also boundary conditions, and in the latter case what boundary functions to use.</p>
<p>The way of specifying this is through the function <code class="docutils literal"><span class="pre">bind_bc</span></code> which has the following signature:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">unspecified_type</span> <span class="n">x</span> <span class="o">=</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">boundary_class</span><span class="p">,</span> <span class="n">data_stores</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>The number of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> is dictated by the <code class="docutils literal"><span class="pre">boundary_class::operator()</span></code>, that is user defined (or provided by <cite>GridTools</cite>).</p>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> specified in the function call will be passed to the <code class="docutils literal"><span class="pre">boundary_class</span></code> and also used in <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operations.</p>
<p>However, some data fields used in boundary conditions may be read-only and should not be passed to the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operation, both for avoiding unnecessary operations and to limit the amount of memory used by the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update layer. For this reason the <code class="docutils literal"><span class="pre">data_store</span></code> passed the <code class="docutils literal"><span class="pre">bind_bc</span></code> can actually be <code class="docutils literal"><span class="pre">std::placeholders</span></code>. Only the actual <code class="docutils literal"><span class="pre">data_store</span></code> specified in the <code class="docutils literal"><span class="pre">bind_bc</span></code> call will be passed to the communication layer. To bind the <code class="docutils literal"><span class="pre">placeholders</span></code> to actual <code class="docutils literal"><span class="pre">data_store</span></code> the user must bind then using <code class="docutils literal"><span class="pre">.associate(data_stores...)</span></code> with the same mechanism used in <code class="docutils literal"><span class="pre">std::bind</span></code> as in the following example, in which <code class="docutils literal"><span class="pre">data_store</span></code> <code class="docutils literal"><span class="pre">c</span></code> is associated to placeholder <code class="docutils literal"><span class="pre">_1</span></code>.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="p">;</span>
<span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>This example, copies the boundary of <code class="docutils literal"><span class="pre">c</span></code> into <code class="docutils literal"><span class="pre">b</span></code>, and performs the halo exchanges for <code class="docutils literal"><span class="pre">b</span></code>. The halo exchange will not be executed on <code class="docutils literal"><span class="pre">c</span></code>, which is <cite>read only</cite> in this call.</p>
<p>If halo exchanges should be applied to both fields, and the boundary of <code class="docutils literal"><span class="pre">`c</span></code> should be copied into <code class="docutils literal"><span class="pre">b</span></code>, both fields should be used used in <code class="docutils literal"><span class="pre">bind_bc</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="distributed-boundaries">
<h3>Distributed Boundaries<a class="headerlink" href="#distributed-boundaries" title="Permalink to this headline">¶</a></h3>
<p>The distributed boundaries class takes the communication traits as template argument. In the next example we use the communication traits class provided by <cite>GridTools</cite>, and <code class="docutils literal"><span class="pre">communication_arch</span></code> is one of the <a class="reference internal" href="../glossary/glossary.html#term-gcl"><span class="xref std std-term">GCL</span></a> specifiers of where the data accessed by a <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> object reside.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">dbs_t</span> <span class="o">=</span> <span class="n">distributed_boundaries</span><span class="o">&lt;</span><span class="n">comm_traits</span><span class="o">&lt;</span><span class="n">storage_type</span><span class="p">,</span> <span class="n">communication_arch</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>During construction more information is required about the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> structure. We use here the usual <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptor</span></a>.</p>
<p>The user needs also to indicate which dimensions are periodic (refer to <a class="reference internal" href="#gcl-communication-module"><span class="std std-ref">GCL Communication Module</span></a> for more information), and this is done using another <cite>GridTools</cite> facility which is the <code class="docutils literal"><span class="pre">boollist</span></code>. Finally, to let the library compute the right amount of memory to allocate before hand, the maximum number of fields to be exchanged in one call have to be specified. The code showing an example of how to do it follows:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">halo_descriptor</span> <span class="n">di</span><span class="p">{</span><span class="n">halo_sx0</span><span class="p">,</span> <span class="n">halo_dx0</span><span class="p">,</span> <span class="n">begin0</span><span class="p">,</span> <span class="n">end0</span><span class="p">,</span> <span class="n">len0</span><span class="p">};</span>
<span class="k">halo_descriptor</span> <span class="n">dj</span><span class="p">{</span><span class="n">halo_sx1</span><span class="p">,</span> <span class="n">halo_dx1</span><span class="p">,</span> <span class="n">begin1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">len1</span><span class="p">};</span>
<span class="k">halo_descriptor</span> <span class="n">dk</span><span class="p">{</span><span class="n">halo_sx2</span><span class="p">,</span> <span class="n">halo_dx2</span><span class="p">,</span> <span class="n">begin2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">len2</span><span class="p">};</span>
<span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halos</span><span class="p">{</span><span class="n">di</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">dk</span><span class="p">};</span>

<span class="n">boollist</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">periodicity</span><span class="p">{</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">};</span> <span class="c1">// b0, b1, b2 are booleans. If true it will indicate that the corresponding dimension is periodic across the grid of processors.</span>

<span class="kt">int</span> <span class="n">max_ds</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// maximum number of data stores to be used in a halo_update operation</span>

<span class="n">dbs_t</span> <span class="n">dbs</span><span class="p">{</span><span class="n">halos</span><span class="p">,</span> <span class="n">periodicity</span><span class="p">,</span> <span class="n">max_ds</span><span class="p">,</span> <span class="n">MPI_COMMUNICATOR</span><span class="p">};</span>
</pre></div>
</div>
<p>Above here the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> are the local <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> sizes, which are usually the tiles of a domain decomposed <cite>global domain</cite>, which has <cite>global boundaries</cite>. The idea is to apply the boundary conditions to the global boundaries while performing <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updates for the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> regions between sub-domains of the domain decomposed global domain.</p>
<p>The <code class="docutils literal"><span class="pre">distributed_boundary</span></code> object allows the user to query the properties of the grid of processes, for instance the coordinates of the current process and the size of the computing grid.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">,</span> <span class="n">pk</span><span class="p">;</span>
<span class="n">dist_boundaries</span><span class="p">.</span><span class="n">proc_grid</span><span class="p">().</span><span class="n">coords</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">,</span> <span class="n">pk</span><span class="p">);</span> <span class="c1">// Coordinates of current process</span>
<span class="kt">int</span> <span class="n">PI</span><span class="p">,</span> <span class="n">PJ</span><span class="p">,</span> <span class="n">PK</span><span class="p">;</span>
<span class="n">dist_boundaries</span><span class="p">.</span><span class="n">proc_grid</span><span class="p">().</span><span class="n">dims</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">PJ</span><span class="p">,</span> <span class="n">PK</span><span class="p">);</span> <span class="c1">// Sizes of the current grid of processes</span>
</pre></div>
</div>
<p>When invoking the boundary application and <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operations the user calls the <code class="docutils literal"><span class="pre">exchange</span></code> member of <code class="docutils literal"><span class="pre">distributed_boundaries</span></code>. The arguments of <code class="docutils literal"><span class="pre">exchange</span></code> are either <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> stores or <code class="docutils literal"><span class="pre">bind_bc</span></code> objects which associate a boundary condition to <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a>. The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> passed directly to the <code class="docutils literal"><span class="pre">exchange</span></code> methods have their halo updated according to the halo and periodicity information specified at <code class="docutils literal"><span class="pre">distributed_boundaries</span></code> object construction.Arguments created with <code class="docutils literal"><span class="pre">bind_bc</span></code> are updated as mentioned above; halo exchanges are only applied if the fields are inside <code class="docutils literal"><span class="pre">bind_bc</span></code>, but not in <code class="docutils literal"><span class="pre">associate</span></code>.</p>
<p>Next, we show a complete example where two boundary are applied using a fixed value on <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal"><span class="pre">a</span></code> and a <code class="docutils literal"><span class="pre">copy_boundary</span></code> to copy the value of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal"><span class="pre">c</span></code> into <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal"><span class="pre">b</span></code> (refer to <a class="reference internal" href="#gcl-communication-module"><span class="std std-ref">GCL Communication Module</span></a>). The halos of data store <code class="docutils literal"><span class="pre">c</span></code> will not be exchange; this field serves as source of data for the <code class="docutils literal"><span class="pre">copy_boundary</span></code>. Three fields will have their <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updated by the next example, namely <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">d</span></code>:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">dist_boundaries</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">bind_bc</span><span class="p">(</span><span class="n">value_boundary</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">3.14</span><span class="p">},</span> <span class="n">a</span><span class="p">),</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>An additional facility provided is an alternative to the <code class="docutils literal"><span class="pre">exchange</span></code> method. This is used to skip the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updates altogether, and it is called <code class="docutils literal"><span class="pre">boundary_only</span></code>, and the code to use it is identical to the previous example, barring the function name:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">dist_boundaries</span><span class="p">.</span><span class="n">boundary_only</span><span class="p">(</span><span class="n">bind_bc</span><span class="p">(</span><span class="n">value_boundary</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">3.14</span><span class="p">},</span> <span class="n">a</span><span class="p">),</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>This function will not do any halo exchange, but only update the boundaries of <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>. Passing <code class="docutils literal"><span class="pre">d</span></code> is possible, but redundant as no boundary is given.</p>
</div>
</div>
<div class="section" id="interfacing-to-other-programming-languages">
<h2>Interfacing to other programming languages<a class="headerlink" href="#interfacing-to-other-programming-languages" title="Permalink to this headline">¶</a></h2>
<p><cite>GridTools</cite> provides an easy macro interface to generate bindings to C and Fortran.</p>
<p>Suppose, the user wants to export the function <code class="docutils literal"><span class="pre">add_impl</span></code>.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The macros <code class="docutils literal"><span class="pre">GT_EXPORT_*</span></code> provide ways to generate bindings to functions. The different
flavours of this macro are explained below. The macro generates a wrapper around the function
<code class="docutils literal"><span class="pre">add_impl</span></code> which is called <code class="docutils literal"><span class="pre">add</span></code> and registers the function to be exported.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/c_bindings/export.hpp&gt;</span><span class="cp"></span>
<span class="n">GT_EXPORT_BINDING_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The user can generate a C header and a Fortran module that matches this header by
adding a call to <code class="docutils literal"><span class="pre">gt_add_bindings_library</span></code> in his CMake project:</p>
<div class="highlight-CMake"><div class="highlight"><pre><span></span><span class="nb">find_package</span><span class="p">(</span><span class="s">GridTools</span> <span class="s">REQUIRED</span><span class="p">)</span>
<span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_MODULE_PATH</span> <span class="s2">&quot;${GridTools_MODULE_PATH}&quot;</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">gt_bindings</span><span class="p">)</span>
<span class="nb">gt_add_bindings_library</span><span class="p">(</span><span class="s">add_lib</span> <span class="s">SOURCES</span> <span class="s">add.cpp</span><span class="p">)</span>
</pre></div>
</div>
<p>This will generate a library <code class="docutils literal"><span class="pre">add_lib</span></code> which contains the exported symbol <code class="docutils literal"><span class="pre">add</span></code>,
and it will generate a target <code class="docutils literal"><span class="pre">add_lib_declarations</span></code> that generates the files
<code class="docutils literal"><span class="pre">add_lib.h</span></code> and <code class="docutils literal"><span class="pre">add_lib.f90</span></code> containing the bindings that can be used from C
and Fortran.</p>
<p>The C header contains the exported function (boilerplate code removed):</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>The generated Fortran module contains the corresponding declaration:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">add_lib</span>
<span class="k">implicit none</span>
<span class="k">  interface</span>
<span class="k">    </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="k">function </span><span class="n">add</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
      <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
    <span class="k">end function</span>
<span class="k">  end interface</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="section" id="exporting-functions-with-no-array-type-arguments">
<h3>Exporting functions with no array-type arguments<a class="headerlink" href="#exporting-functions-with-no-array-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>There exist various flavours of these macros. Functions which are non-templated or fully-specialized
can be exported with <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING</span></code>, for example:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add_impl</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">GT_EXPORT_BINDING_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">add_impl</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
<span class="n">GT_EXPORT_BINDING</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">add_impl</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>All functions exist in two flavours: Either you can pass the number of arguments as part of the name
of the macro (<code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_2</span></code> stands for two arguments), or you can pass it as a first argument
to the generic <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING</span></code>. The first flavours exist for up to 9 arguments.</p>
<p>Note that <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_X</span></code> requires a name and a function pointer as its arguments.
A lambda cannot be passed as function pointer; thus, the type of the arguments cannot be
deduced. In such cases, the functions can be exported with <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_WITH_SIGNATURE_X</span></code>,
which additionally takes the function type as an argument:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">GT_EXPORT_BINDING_WITH_SIGNATURE_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>Templated functions can be exported for a given set of specializations using
<code class="docutils literal"><span class="pre">GT_EXPORT_GENERIC_BINDING_X</span></code>. In addition to the function name and the function pointer, it takes a list of
overloads for which the bindings are generated:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">GT_EXPORT_GENERIC_BINDING</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
</pre></div>
</div>
<p>In the generated Fortran module, generic bindings will produce an interface combining the different
overloads:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">interface</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="k">function </span><span class="n">add_f0</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">    </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
  <span class="k">end function</span>
<span class="k">  </span><span class="kt">real</span><span class="p">(</span><span class="kt">c_double</span><span class="p">)</span> <span class="k">function </span><span class="n">add_f1</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">    </span><span class="kt">real</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
  <span class="k">end function</span>
<span class="k">end interface</span>
<span class="k">interface </span><span class="n">add</span>
  <span class="k">procedure </span><span class="n">add_f0</span><span class="p">,</span> <span class="n">add_f1</span>
<span class="k">end interface</span>
</pre></div>
</div>
</div>
<div class="section" id="complex-types">
<h3>Complex types<a class="headerlink" href="#complex-types" title="Permalink to this headline">¶</a></h3>
<p>Only a limited set of types can be passed from Fortran / C through the C bindings interface to C++,
namely integral and floating point types, booleans and pointers to those types.</p>
<p>Array references, <cite>GridTools</cite> storages, and any type that is <cite>fortran_array_bindable</cite>
appear as <code class="docutils literal"><span class="pre">gt_fortran_array_descriptor</span></code> in the C bindings. This structure allows
the user to describe the data that needs to be passed to C++.</p>
<p>It is possible to write bindings to functions that accept or return other types.
During the generation process, they are replaced with pointers to the type <code class="docutils literal"><span class="pre">gt_handle</span></code>.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">make_vector_impl</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">use_vector_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">GT_EXPORT_BINDING_0</span><span class="p">(</span><span class="n">make_vector</span><span class="p">,</span> <span class="n">make_vector_impl</span><span class="p">);</span>
<span class="n">GT_EXPORT_BINDING_1</span><span class="p">(</span><span class="n">use_vector</span><span class="p">,</span> <span class="n">use_vector_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The code above will generate the following signatures in the C-header:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">gt_handle</span><span class="o">*</span> <span class="nf">make_vector</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">use_vector</span><span class="p">(</span><span class="n">gt_handle</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The user needs to make sure that the types that stand behind <code class="docutils literal"><span class="pre">gt_handle</span></code> match, otherwise
an exception will be thrown.</p>
</div>
<div class="section" id="exporting-functions-with-array-type-arguments-to-fortran">
<h3>Exporting functions with array-type arguments to Fortran<a class="headerlink" href="#exporting-functions-with-array-type-arguments-to-fortran" title="Permalink to this headline">¶</a></h3>
<p>Special macros exist to export function that take array-like arguments to Fortran. While the normal
macros export such arguments as <code class="docutils literal"><span class="pre">gt_fortran_array_descriptor</span></code>, the “wrapped” macros create
additional wrappers around the functions that fill the structures themselves.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dummy_impl</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="p">{}</span>
<span class="n">GT_EXPORT_BINDING_WRAPPED_1</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">dummy_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">dummy_impl</span></code> is taking a reference to an array. When exporting this function with
<code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_WRAPPED_X</span></code>, an additional wrapper is generated in the Fortran bindings:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">add_lib</span>
<span class="k">implicit none</span>
<span class="k">  interface</span>
<span class="k">    subroutine </span><span class="n">dummy_impl</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dummy&quot;</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="k">use </span><span class="n">array_descriptor</span>
      <span class="k">type</span><span class="p">(</span><span class="n">gt_fortran_array_descriptor</span><span class="p">)</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="k">end subroutine</span>
<span class="k">  end interface</span>
<span class="k">contains</span>
<span class="k">    subroutine </span><span class="n">dummy</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="k">use </span><span class="n">array_descriptor</span>
      <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">dimension</span><span class="p">(:,:),</span> <span class="k">target</span> <span class="kd">::</span> <span class="n">arg0</span>
      <span class="k">type</span><span class="p">(</span><span class="n">gt_fortran_array_descriptor</span><span class="p">)</span> <span class="kd">::</span> <span class="n">descriptor0</span>

      <span class="n">descriptor0</span><span class="p">%</span><span class="n">rank</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="k">type</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="nb">shape</span><span class="p">(</span><span class="n">arg0</span><span class="p">),</span> <span class="p">&amp;</span>
        <span class="nb">shape</span><span class="p">(</span><span class="n">descriptor0</span><span class="p">%</span><span class="n">dims</span><span class="p">),</span> <span class="p">(</span><span class="o">/</span><span class="mi">0</span><span class="o">/</span><span class="p">))</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="k">data</span> <span class="o">=</span> <span class="nb">c_loc</span><span class="p">(</span><span class="n">arg0</span><span class="p">(</span><span class="nb">lbound</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">lbound</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

      <span class="k">call </span><span class="n">dummy_impl</span><span class="p">(</span><span class="n">descriptor0</span><span class="p">)</span>
    <span class="k">end subroutine</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This allows to call the Fortran function <code class="docutils literal"><span class="pre">dummy</span></code> in a convenient way:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">dimension</span><span class="p">(:,</span> <span class="p">:)</span> <span class="kd">::</span> <span class="n">some_array</span>
<span class="k">call </span><span class="n">dummy</span><span class="p">(</span><span class="n">some_array</span><span class="p">)</span>
</pre></div>
</div>
<p>The bindings will take care that the rank matches and it will infer the size of the array automatically.</p>
<p>All additional macros behave as mentioned above, namely <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_WITH_SIGNATURE_WRAPPED</span></code>,
and <code class="docutils literal"><span class="pre">GT_EXPORT_BINDING_GENERIC_WRAPPED</span></code>.</p>
<p>Data types need to be <cite>fortran_array_wrappable</cite> in order to be compatible with these macros. Natively, only
C arrays and <code class="docutils literal"><span class="pre">fortran_array_adapter</span></code> are <cite>fortran_array_wrappable</cite>. The latter is an adapter between
Fortran arrays and <cite>GridTools</cite> storages, such that the user can pass a Fortran array to a C++ function,
which then can be transformed into a <cite>GridTools</cite> storage.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/interface/fortran_array_adapter.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">Backend</span><span class="o">&gt;::</span><span class="n">storage_info_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">Backend</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">modify_array_impl</span><span class="p">(</span><span class="n">fortran_array_adapter</span><span class="o">&lt;</span><span class="n">data_store_t</span><span class="o">&gt;</span> <span class="n">inout</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data_store_t</span> <span class="n">data_store</span><span class="p">{</span><span class="n">storage_info_t</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">}};</span>
    <span class="n">transform</span><span class="p">(</span><span class="n">data_store</span><span class="p">,</span> <span class="n">inout</span><span class="p">);</span>

    <span class="c1">// use data_store</span>

    <span class="n">transform</span><span class="p">(</span><span class="n">inout</span><span class="p">,</span> <span class="n">data_store</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">GT_EXPORT_BINDING_WRAPPED_1</span><span class="p">(</span><span class="n">modify_array</span><span class="p">,</span> <span class="n">modify_array_impl</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="cmake-usage">
<h3>CMake usage<a class="headerlink" href="#cmake-usage" title="Permalink to this headline">¶</a></h3>
<p>A call to <code class="docutils literal"><span class="pre">gt_add_bindings_library</span></code> generates the libraries and the headers. By default,
the C header file and the Fortran file is written directly into the source tree. This choice was
taken to improve building in cross-build environments, because the process cannot rely
on generated binaries being executable on the host system. The output folder can be overwritten
by setting <code class="docutils literal"><span class="pre">FORTRAN_OUTPUT_DIR</span></code> and <code class="docutils literal"><span class="pre">C_OUTPUT_DIR</span></code>.</p>
<p>By default, the name of the generated Fortran module is set to the name of the library. A different
name can be set with <code class="docutils literal"><span class="pre">FORTRAN_MODULE_NAME</span></code>.</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../glossary/glossary.html" class="btn btn-neutral float-right" title="Glossary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../getting_started/getting_started.html" class="btn btn-neutral" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ETH Zurich.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.22.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>