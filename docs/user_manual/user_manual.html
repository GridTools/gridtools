

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>User Manual &mdash; GridTools 0.20.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/cscs.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Upcoming Features" href="../upcoming/upcoming.html" />
    <link rel="prev" title="Getting Started" href="../getting_started/getting_started.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GridTools
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.20
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-gridtools">What Is GridTools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dependencies">Dependencies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#installation-and-use">Installation and Use</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-script">Simple Script</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-gridtools">Using GridTools</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#contributing">Contributing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#storage-module">Storage Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#storage-info">Storage Info</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-store">Data Store</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-view">Data View</a></li>
<li class="toctree-l3"><a class="reference internal" href="#storage-facility">Storage Facility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dsl-introduction">DSL Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">Using GridTools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax-compile-time-protections">Syntax Compile-Time Protections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stencil-operators">Stencil Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#accessor-type">Accessor Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessor-aliases">Accessor Aliases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#param-list"><cite>param_list</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#apply-method"><cite>Apply</cite>-Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expressions">Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#execution-model">Execution Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stencil-composition">Stencil Composition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preparing-arguments-storage-placeholders">Preparing Arguments: Storage Placeholders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-the-iteration-space-the-grid">Defining the Iteration Space: the Grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-regions-and-vertical-boundary-conditions">Vertical Regions and Vertical Boundary Conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-interval">Default Interval</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-vertical-intervals">Defining Vertical Intervals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-functionality-for-vertical-intervals">Advanced Functionality for Vertical Intervals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-stencils">Composition of Stencils</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selecting-the-backend">Selecting the Backend</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-functionality">Advanced Functionality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stencil-functions">Stencil Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-calls-call">Function Calls: <cite>call&lt;&gt;</cite></a></li>
<li class="toctree-l4"><a class="reference internal" href="#procedure-calls-call-proc">Procedure Calls: <cite>call_proc&lt;&gt;</cite></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#software-managed-caches">Software-Managed Caches</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cache-type">Cache Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cache-policy">Cache Policy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conditionals">Conditionals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expandable-parameters">Expandable Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-parameters-and-accessors">Global Parameters and Accessors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id17">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preliminaries">Preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-condition-class">Boundary Condition Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-condition-application">Boundary Condition Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-predication">Boundary Predication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#provided-boundary-conditions">Provided Boundary Conditions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#halo-exchanges">Halo Exchanges</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id20">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">Preliminaries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#processor-grid">Processor Grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#layout-map">Layout Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#halo-descriptor">Halo Descriptor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gcl-communication-module">GCL Communication Module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#distributed-boundary-conditions">Distributed Boundary Conditions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-principles">Design Principles:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#communication-traits">Communication Traits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binding-boundaries-and-communication">Binding Boundaries and Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributed-boundaries">Distributed Boundaries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-management">Data Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interfacing-to-other-programming-languages">Interfacing to Other Programming Languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#exporting-functions-with-no-array-type-arguments">Exporting functions with no array-type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-types">Complex types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exporting-functions-with-array-type-arguments-to-fortran">Exporting functions with array-type arguments to Fortran</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cmake-usage">CMake usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#benchmarking">Benchmarking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../upcoming/upcoming.html">Upcoming Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/internal.html">Internal Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GridTools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>User Manual</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/user_manual.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-manual">
<span id="id1"></span><h1>User Manual<a class="headerlink" href="#user-manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-gridtools">
<h3>What Is GridTools<a class="headerlink" href="#what-is-gridtools" title="Permalink to this headline">¶</a></h3>
<p>The <cite>GridTools</cite> (GT) framework is a set of libraries and utilities to develop performance portable applications in which stencil operations on grids are central. The focus of the project is on regular and block-structured grids as are commonly found in the weather and climate application field. In this context, GT provides a useful level of abstraction to enhance productivity and obtain excellent performance on a wide range of computer architectures. Additionally, it addresses the challenges that arise from integration into production code, such as the expression of boundary conditions, or conditional execution. The framework is structured such that it can be called from different weather models (numerical weather and climate codes) or programming interfaces, and can target various computer architectures. This is achieved by separating the GT core library in a user facing part (frontend) and architecture specific (backend) parts. The core library also abstracts various possible data layouts and applies optimizations on stages with multiple stencils. The core library is complemented by facilities to interoperate with other languages (such as C and Fortran), to aid code development and a communication layer.</p>
<p>For a list of supported compilers refer to the <a class="reference external" href="https://github.com/eth-cscs/gridtools/wiki/Supported-Compilers">project Wiki on github</a>.</p>
<div class="section" id="dependencies">
<h4>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h4>
<p><cite>GridTools</cite> depends on Boost (version 1.60 or newer). <cite>GridTools</cite> does not use any runtime library from Boost, but instead depends on header only libraries such as <code class="docutils literal notranslate"><span class="pre">boost::mpl</span></code> and <code class="docutils literal notranslate"><span class="pre">boost::fusion</span></code>.</p>
</div>
</div>
<div class="section" id="installation-and-use">
<h3>Installation and Use<a class="headerlink" href="#installation-and-use" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> uses CMake as building system. The installation can be configured using <cite>ccmake</cite>. The following variables control the back-ends that will be supported by the runtime components of the installation:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>GT_ENABLE_TARGET_CUDA <span class="c1"># For CUDA GPUs</span>
GT_ENABLE_TARGET_X86  <span class="c1"># For cache based multicores and naive implementation</span>
GT_ENABLE_TARGET_MC   <span class="c1"># For optimized multicores and KNL</span>
</pre></div>
</div>
<p>All the targets can be installed at the same time, but some runtime components may lead to incompatibilities or complex environments to make the codes run. It may be more effective to do multiple installs of the library for different targets in this case.</p>
<p>At the moment the only runtime component of <cite>GridTools</cite> is the GCL, the communication module. This component will be installed in the system as a single-node mockery of the full distributed memory capability. To enable the full GCL you must set to <code class="docutils literal notranslate"><span class="pre">ON</span></code> the following variables</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>GT_USE_MPI
</pre></div>
</div>
<p>In addition, it may be convenient to install the library without compiling and running the tests, that use multiple nodes. To do so you can set to <code class="docutils literal notranslate"><span class="pre">ON</span></code> the following variable:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>GT_GCL_ONLY
</pre></div>
</div>
<p>Other variables can be useful for your system, and you can find their descriptions using <code class="docutils literal notranslate"><span class="pre">ccmake</span></code>.</p>
<p>When installing <cite>GridTools</cite> all the source codes of the components will be copied to the installation path. To avoid compiling and running tests for specific components, <cite>GridTools</cite> allows to enable or disable components using the following variables, with obvious meaning:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>INSTALL_BOUNDARY_CONDITIONS
INSTALL_DISTRIBUTED_BOUNDARIES
INSTALL_COMMON
INSTALL_STENCIL_COMPOSITION
INSTALL_STORAGE
INSTALL_C_BINDINGS
INSTALL_INTERFACE
INSTALL_TOOLS
</pre></div>
</div>
<p>To have access to these variables <code class="docutils literal notranslate"><span class="pre">INSTALL_ALL</span></code> should be set to <code class="docutils literal notranslate"><span class="pre">OFF</span></code>.</p>
<p>Additionally, examples can be compiled if <code class="docutils literal notranslate"><span class="pre">GT_COMPILE_EXAMPLES</span></code> is <code class="docutils literal notranslate"><span class="pre">ON</span></code>. The examples can be installed if <code class="docutils literal notranslate"><span class="pre">GT_INSTALL_EXAMPLES</span></code> is <code class="docutils literal notranslate"><span class="pre">ON</span></code>. The path where to install the examples is specified by <code class="docutils literal notranslate"><span class="pre">GT_INSTALL_EXAMPLES_PATH</span></code> and it is set to <code class="docutils literal notranslate"><span class="pre">CMAKE_INSTALL_PREFIX</span></code> by default.</p>
<div class="section" id="simple-script">
<h4>Simple Script<a class="headerlink" href="#simple-script" title="Permalink to this headline">¶</a></h4>
<p>Below a sample of the commands needed to enable the multicore and CUDA backends and install them in <code class="docutils literal notranslate"><span class="pre">/usr/local</span></code>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>git clone http://github.com/eth-cscs/gridtools.git
<span class="nb">cd</span> gridtools
mkdir build
<span class="nb">cd</span> build
cmake -DGT_ENABLE_TARGET_MC<span class="o">=</span>ON -DGT_ENABLE_TARGET_CUDA<span class="o">=</span>ON -DCMAKE_INSTALL_PREFIX<span class="o">=</span>/usr/local ..
make install
</pre></div>
</div>
</div>
<div class="section" id="using-gridtools">
<h4>Using GridTools<a class="headerlink" href="#using-gridtools" title="Permalink to this headline">¶</a></h4>
<p>Using <cite>GridTools</cite> follows standard CMake practices. To indicate where the <cite>GridTools</cite> root is, CMake should be provided with the variable <code class="docutils literal notranslate"><span class="pre">gridtools_DIR</span></code>, e.g. by calling CMake with <cite>-Dgridtools_DIR=&lt;/path/to/gridtools/lib/cmake&gt;</cite>. The <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file should then contain the following lines:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">find_package</span><span class="p">(</span><span class="s">GridTools</span> <span class="s">0.1.8.2</span> <span class="s">REQUIRED</span><span class="p">)</span>
<span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_MODULE_PATH</span> <span class="s2">&quot;${GridTools_MODULE_PATH}&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Targets that need <cite>GridTools</cite> should indicate <code class="docutils literal notranslate"><span class="pre">GridTools::gridtools</span></code> as target link library. If the communication module is needed <code class="docutils literal notranslate"><span class="pre">GridTools::gcl</span></code> should be used.</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">target_name</span><span class="o">}</span> <span class="s">GridTools::gridtools</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="contributing">
<h3>Contributing<a class="headerlink" href="#contributing" title="Permalink to this headline">¶</a></h3>
<p>Contributions to the <cite>GridTools</cite> set of libraries are welcome. Our policy is however, that we will be the official maintainers and providers of the GridTools code. We believe that this will provide our users with a clear reference point for support and guarantees on timely interactions. For this reason, we require that external contributions to <cite>GridTools</cite> will be accepted after their authors provide to us a signed copy of a copyright release form to ETH Zurich.</p>
</div>
</div>
<div class="section" id="storage-module">
<span id="id2"></span><h2>Storage Module<a class="headerlink" href="#storage-module" title="Permalink to this headline">¶</a></h2>
<p>The storage module is one of the main modules in <cite>GridTools</cite>. Main target of this module is to provide proper means to access, view, and modify data. The detail of the hardware is hidden to the user, but the user is responsible for indicating what storage is needed, and this is indicated by the name of the storage class.
Different <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backends</span></a> are available for different kinds of storages, see <a class="reference internal" href="#backend-selection"><span class="std std-ref">Selecting the Backend</span></a>. Following subsections will explain the different basic elements that are used in the storage module.</p>
<p>The storage has the notion of <code class="docutils literal notranslate"><span class="pre">halo</span></code>. This in turns allows the user of the storage to distinguish between the <code class="docutils literal notranslate"><span class="pre">inner_region</span></code> and the <code class="docutils literal notranslate"><span class="pre">outer_region</span></code>, where the latter includes the halos. The halo is symmetric in the storage class, that is, the number of halo points at the two ends of a dimension is the same. Different dimensions may have different numbers of halo points. The main reason for including halos in the storage is to enforce the alignment of the storage in the inner region to improve the performance of stencil operations.</p>
<div class="section" id="storage-info">
<span id="id3"></span><h3>Storage Info<a class="headerlink" href="#storage-info" title="Permalink to this headline">¶</a></h3>
<p>The storage info element can be seen as a meta data object that keep information about a storage. This information is alignment, data layout in memory, halo areas, dimensionality, size of the storage, etc.
The object must be created before storage can be allocated. The meta data or storage info object can be shared among different storages. The reason is that it is usual that multiple storages used in one computation are having the same meta data. The storage info object is created in the following way:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>storage_info_interface&lt;Id, Layout, Halo, Alignment&gt;(Dims…)</p>
<p>Some <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backends</span></a> also come with a default alignment value that should provide good
performance on supported hardware. On CUDA GPUs for example</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">cuda_storage_info</span><span class="o">&lt;</span><span class="n">Id</span><span class="p">,</span> <span class="n">Layout</span><span class="p">,</span> <span class="n">Halo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dims</span><span class="p">...)</span>
</pre></div>
</div>
<p>can be used, while for the <cite>mc</cite> <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>,</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">mc_storage_info</span><span class="o">&lt;</span><span class="n">Id</span><span class="p">,</span> <span class="n">Layout</span><span class="p">,</span> <span class="n">Halo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dims</span><span class="p">...)</span>
</pre></div>
</div>
<p>is available.</p>
<p><a class="reference internal" href="#fig-storage-info"><span class="std std-numref">Fig. 3</span></a> shows a depiction of the <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> compile-time data.</p>
<div class="figure" id="id25">
<span id="fig-storage-info"></span><a class="reference internal image-reference" href="../_images/storage_info.png"><img alt="../_images/storage_info.png" src="../_images/storage_info.png" style="width: 238.79999999999998px; height: 157.79999999999998px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Storage info and associated compile-time data.</span></p>
</div>
<p>Passed type information:</p>
<ul class="simple">
<li><strong>Id</strong>: A unique identification for the storage info type</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For each <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> type you should use only one
instantiation. The mapping between a storage and the
run-time information in the <cite>storage_info</cite> has to be
done at compile time via the index. Thus <cite>GridTools</cite> cannot
distinguish the storages by the run-time sizes passed
to the <cite>storage_info</cite>. If you want to instantiate
multiple <cite>storage_info</cite> with the same halo, alignment, layout
but with different dimensionality you must use a different ID.</p>
</div>
<ul class="simple">
<li><strong>Layout Map:</strong> Information about the memory layout. The <code class="docutils literal notranslate"><span class="pre">layout_map</span></code> template takes a permutation of the value from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of dimensions of the storage. The values indicate the order of the dimensions by decreasing strides. For instance a C array <code class="docutils literal notranslate"><span class="pre">X[i][j][k]</span></code> layout would be equivalent to <code class="docutils literal notranslate"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code>. The dimension with stride 1 has the highest index. A Fortran style array <code class="docutils literal notranslate"><span class="pre">X[i][j][k]</span></code> layout would be equivalent to <code class="docutils literal notranslate"><span class="pre">layout_map&lt;2,</span> <span class="pre">1,</span> <span class="pre">0&gt;</span></code>. There is also the possibility to mask dimensions. This means that the storage appears as n-dimensional but the masked dimensions are ignored. For instance a <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> with <code class="docutils literal notranslate"><span class="pre">layout_map&lt;1,</span> <span class="pre">-1,</span> <span class="pre">0&gt;</span></code> describes a 3-dimensional storage but the j dimension is masked. In this case the storage behave as a 3D array whose sizes are <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">1,</span> <span class="pre">L)</span></code>, when accessing an element <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code>, the <code class="docutils literal notranslate"><span class="pre">j</span></code> index is ignored. There are not bound checks for masked dimensions. The reason is that this use case is designed to allow implementing planes with an orientation to be used in stencils.</li>
<li><strong>Alignment:</strong> Information about the alignment in terms of number of bytes. There is the possibility to provide information about how the data points should be aligned in memory. The alignment is enforced to the first elements in the inner region of the dimension with stride one. This provides a huge performance gain for some architectures (e.g., GPUs). The storage module combines the alignment, layout, and halo information in order to align the non-halo data points of the stride-one dimension in memory. The legacy x86 <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> uses no alignment (<code class="docutils literal notranslate"><span class="pre">alignment&lt;1&gt;</span></code>) by default. The CUDA <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> uses a default alignment of 32 data elements (<code class="docutils literal notranslate"><span class="pre">alignment&lt;32&gt;</span></code>), the MC <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> defaults to <code class="docutils literal notranslate"><span class="pre">alignment&lt;8&gt;</span></code>.</li>
<li><strong>Halo:</strong> The halo information has to be passed as type information to the storage info. Reason for this is that the proper alignment can only be computed with given halo information. The storage info object provides aligned data points (non-halo points) for the stride 1 dimension. The halo information is given as follows: <code class="docutils literal notranslate"><span class="pre">halo&lt;Sizes...&gt;</span></code> where sizes is the halo size at both ends of the corresponding dimension, in terms of element sizes. E.g., <code class="docutils literal notranslate"><span class="pre">halo&lt;2,</span> <span class="pre">4,</span> <span class="pre">0&gt;</span></code> is a halo of size 2 in direction I+ and I-, halo of size 4 in direction J+ and J-, and no halo in K.</li>
</ul>
<p><strong>Example</strong>:
In the following example a storage info object with
Id 0,
2 dimensions,
I-first layout,
halo I size of 1,
halo J size of 0,
and alignment 8 is created.
Please note that the size of the halo has to be added to the arguments that are passed to the constructor.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">storage_info_interface</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">alignment</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 4 data points + 2 halo points in I, 3 data points and 0 halo points in J</span>
</pre></div>
</div>
<p>A visual representation of the storage info is given in <a class="reference internal" href="#fig-storage-info-example"><span class="std std-numref">Fig. 4</span></a>.</p>
<div class="figure" id="id26">
<span id="fig-storage-info-example"></span><a class="reference internal image-reference" href="../_images/storage_info_example.png"><img alt="../_images/storage_info_example.png" src="../_images/storage_info_example.png" style="width: 524.0px; height: 246.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Example storage info.</span></p>
</div>
<p><strong>Interface</strong>: The <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> object provides methods for querying following information:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">dim()</span> <span class="pre">const</span></code>: get the aligned size of a dimension. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;dims()</span> <span class="pre">const</span></code>: return the array of (aligned) dims. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">stride()</span> <span class="pre">const</span></code>: get aligned the stride of dimension.</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;strides()</span> <span class="pre">const</span></code>: return the array of (aligned) strides.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">unaligned_dim()</span> <span class="pre">const</span></code>: get the unaligned size of a dimension. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">unaligned_stride()</span> <span class="pre">const</span></code>: get the unaligned stride of dimension. (Deprecated - Does not really make sense.)</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">begin()</span> <span class="pre">const</span></code>: retrieve the position of the first non halo point in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">end()</span> <span class="pre">const</span></code>: retrieve the position of the last non halo point in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_begin()</span> <span class="pre">const</span></code>: retrieve the position of the first point (can also be a halo point) in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_end()</span> <span class="pre">const</span></code>: retrieve the position of the last point (can also be a halo point) in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">length()</span> <span class="pre">const</span></code>: retrieve the total number of data points (excluding padding, halo, initial offset) in dimension <cite>D</cite> (<cite>equivalent to end&lt;D&gt;()-begin&lt;D&gt;()+1</cite>).</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_length()</span> <span class="pre">const</span></code>: retrieve the total number of data points (excluding padding, initial offset) in dimension <cite>D</cite> (<cite>equivalent to total_end&lt;D&gt;()-total_begin&lt;D&gt;()+1</cite>).</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">padded_total_length()</span> <span class="pre">const</span></code>: retrieve the total number of data points in dimension <cite>D</cite>, including eventual padding.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;typename...</span> <span class="pre">Ints&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">index(Ints...</span> <span class="pre">idx)</span> <span class="pre">const</span></code>: retrieve the array index of a given coordinate.</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">index(gridtools::array&lt;int,</span> <span class="pre">ndims&gt;</span> <span class="pre">const</span> <span class="pre">&amp;offsets)</span> <span class="pre">const</span></code>: retrieve an offset (or index) when given an array of offsets in I, J, K, etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">get_initial_offset()</span></code>: initial offset that is used in order to provide proper alignment.</li>
</ul>
</div>
<div class="section" id="data-store">
<span id="id4"></span><h3>Data Store<a class="headerlink" href="#data-store" title="Permalink to this headline">¶</a></h3>
<p>Once the <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> object is created a <code class="docutils literal notranslate"><span class="pre">data_store</span></code> can be created. A <code class="docutils literal notranslate"><span class="pre">data_store</span></code> is keeping together the <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> object, a data type and the actual memory allocation (see also <a class="reference internal" href="#fig-data-store"><span class="std std-numref">Fig. 5</span></a>). The main purpose of the <code class="docutils literal notranslate"><span class="pre">data_store</span></code> is to provide means for synchronizing, keeping consistency, cleaning up memory, etc. A <code class="docutils literal notranslate"><span class="pre">data_store</span></code> can be copied and moved (shallow copy), but the underlying allocated storage in not copied (no deep-copy). When copying a <code class="docutils literal notranslate"><span class="pre">data_store</span></code> both instances will point to the same data. Basically it has the same behaviour as a shared pointer.</p>
<div class="figure" id="id27">
<span id="fig-data-store"></span><a class="reference internal image-reference" href="../_images/data_store.png"><img alt="../_images/data_store.png" src="../_images/data_store.png" style="width: 348.8px; height: 360.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text"><a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> and associated compile-time data.</span></p>
</div>
<p><strong>Example</strong>:
Following codes snippets show how <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> can be created. At first the user has to identify if the memory management is
done externally or not. If it is done externally the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> won’t allocate nor deallocate the memory. The standard use-case is to
use managed <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a>. The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> can be initialized with a value or lambda and can optionally be named by passing an additional  string.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">storage_info_interface</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">alignment</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">data_store</span><span class="o">&lt;</span><span class="n">host_storage</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 4 data points + 2 halo points in I, 3 data points and 0 halo points in J</span>

<span class="c1">// standard use cases</span>
<span class="n">data_store_t</span> <span class="nf">ds1</span><span class="p">(</span><span class="n">si</span><span class="p">);</span> <span class="c1">// create a data store without a name (will allocate memory internally)</span>
<span class="n">data_store_t</span> <span class="nf">ds2</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="s">&quot;ds2&quot;</span><span class="p">);</span> <span class="c1">// create a data store with a name (will allocate memory internally)</span>
<span class="n">data_store_t</span> <span class="nf">ds3</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s">&quot;ds3&quot;</span><span class="p">);</span> <span class="c1">// create a named and value initialized data store</span>
<span class="n">data_store_t</span> <span class="nf">ds4</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">;</span> <span class="p">},</span> <span class="s">&quot;ds4&quot;</span><span class="p">);</span> <span class="c1">// create a named and lambda initialized data store</span>

<span class="c1">// copying a data store</span>
<span class="n">ds2</span> <span class="o">=</span> <span class="n">ds1</span><span class="p">;</span> <span class="c1">// ds2 will deallocate the previously allocated memory and will point to the same data as ds1.</span>

<span class="c1">// external pointer use case</span>
<span class="kt">double</span><span class="o">*</span> <span class="n">external_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">si</span><span class="p">.</span><span class="n">padded_total_length</span><span class="p">()];</span>
<span class="n">data_store_t</span> <span class="nf">ds_ext</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">external_ptr</span><span class="p">);</span> <span class="c1">// create a data store that is not managing the memory</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="p">[]</span> <span class="n">external_ptr</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Interface</strong>:
The <code class="docutils literal notranslate"><span class="pre">data_store</span></code> object provides methods for performing following things:</p>
<ul class="simple">
<li><cite>void allocate(StorageInfo const &amp;info)</cite>: allocate the needed memory. this will instantiate a storage instance.</li>
<li><cite>void reset()</cite>: reset the data_store. maybe deallocates memory.</li>
<li><cite>template &lt;int D&gt; int dim() const</cite>: function to retrieve the (aligned) size of a dimension.</li>
<li><cite>template &lt;int D&gt; int unaligned_dim() const</cite>: get the unaligned size of a dimension.</li>
<li><cite>int padded_total_length() const</cite>: retrieve the total number of data points.</li>
<li><cite>int total_length() const</cite>: retrieve the total number of data points (excluding padding, initial offset).</li>
<li><cite>int length() const</cite>: retrieve the total number of data points (excluding padding, halo, initial offset).</li>
<li><cite>std::shared_ptr&lt;storage_t&gt; get_storage_ptr() const</cite>: retrieve a pointer to the underlying storage instance.</li>
<li><cite>std::shared_ptr&lt;storage_info_t const&gt; get_storage_info_ptr() const</cite>: retrieve a pointer to the underlying storage_info instance.</li>
<li><cite>bool valid() const</cite>: check if underlying storage info and storage is valid.</li>
<li><cite>void clone_to_device() const</cite>: clone underlying storage to device. This function can also be called with host only storages but of course no operation is triggered.</li>
<li><cite>void clone_from_device() const</cite>: clone underlying storage from device. This function can also be called with host only storages but of course no operation is triggered.</li>
<li><cite>void sync() const</cite>: synchronize underlying storage.</li>
<li><cite>void reactivate_device_write_views() const</cite>: reactivate all device read write views to storage.</li>
<li><cite>void reactivate_host_write_views() const</cite>: reactivate all host read write views to storage.</li>
<li><cite>std::string const &amp;name() const</cite>: retrieve the name of the storage.</li>
<li><cite>const array&lt;uint_t, ndims&gt; &amp;dims() const</cite>: return the array of (aligned) dims.</li>
<li><cite>const array&lt;uint_t, ndims&gt; &amp;strides() const</cite>: return the array of (aligned) strides.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> cannot be used to modify or access the data.
In order to do so we use the view concept.</p>
</div>
</div>
<div class="section" id="data-view">
<span id="id5"></span><h3>Data View<a class="headerlink" href="#data-view" title="Permalink to this headline">¶</a></h3>
<p>The view provides means to modify the data stored in a <code class="docutils literal notranslate"><span class="pre">data_store</span></code>.
Views can be generated (at the moment) for both Host (CPU) and Device (GPU).
Internally the view is a very simple struct that contains a pointer to the
data and provides an <code class="docutils literal notranslate"><span class="pre">operator()(...)</span></code> in order to access and modify the data
at a given coordinate. The view can be created in a read only mode or read-write. The read-only views
can be beneficial because read only views do not trigger synchronizations with the devices.</p>
<p><strong>Example</strong>:</p>
<p>Following example shows the instantiation of a <code class="docutils literal notranslate"><span class="pre">data_store</span></code> and a corresponding host and device view.
The host view can be used when the data is modified on a host. Device views can be passed to device
code only. For instance if the user creates a device view to a <code class="docutils literal notranslate"><span class="pre">cuda_storage</span></code> the device view can be passed
to a kernel and used inside the kernel to access the data in a convenient way.
In case of a <code class="docutils literal notranslate"><span class="pre">host_storage</span></code> there is no device view available.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">View</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">kernel</span><span class="p">(</span><span class="n">View</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// set (0, 0) to 3.1415</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// instantiate a data_store</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">cuda_storage_info</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">data_store</span><span class="o">&lt;</span><span class="n">cuda_storage</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">ds</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>

<span class="c1">// create a view to ds (data_store)</span>
<span class="k">auto</span> <span class="n">host_view_ds</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span> <span class="c1">// read write view</span>
<span class="c1">// set (0, 10) to 3.1415</span>
<span class="n">host_view_ds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
<span class="c1">// synchronize the data store</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>
<span class="c1">// create a device view</span>
<span class="k">auto</span> <span class="n">device_view_ds</span> <span class="o">=</span> <span class="nl">make_device_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span> <span class="c1">// read write view</span>
<span class="c1">// call kernel</span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">device_view_ds</span><span class="p">);</span>
<span class="c1">// synchronize the data store</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>
<span class="c1">// reactivate the host view</span>
<span class="n">ds</span><span class="p">.</span><span class="n">reactivate_host_write_views</span><span class="p">();</span>
<span class="c1">// expect (0, 0) == (0, 10)</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">host_view_ds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">host_view_ds</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p><strong>View validity</strong>:</p>
<p>Views can become invalid. For instance it can happen that the user is creating a read write host view as
a first step. If the user is creating a device view without synchronizing before the data would become inconsistent.
Reason for this is because the internal state machine assumes that there will be a modification whenever a read write
view is created. The validity and consistency of a view can be checked easily. If views should be reused after a
synchronization they have to be activated manually via a call to <code class="docutils literal notranslate"><span class="pre">reactivate_host_views()</span></code> or <code class="docutils literal notranslate"><span class="pre">reactivate_device_views()</span></code>. The view consistency can always be checked with a call to <code class="docutils literal notranslate"><span class="pre">check_consistency(DataStore,</span> <span class="pre">DataView)</span></code>.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">auto</span> <span class="n">host_view_ds</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">ro_host_view_ds</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="o">&lt;</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_only</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
<span class="c1">// check if view is consistent</span>
<span class="n">assert</span><span class="p">(</span><span class="n">check_consistency</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ro_host_view_ds</span><span class="p">));</span>
<span class="n">assert</span><span class="p">(</span><span class="n">check_consistency</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">host_view_ds</span><span class="p">));</span>
<span class="c1">// some modification on host side</span>
<span class="p">...</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span>
<span class="c1">// the read-write view cannot be used anymore without activation</span>
<span class="n">assert</span><span class="p">(</span><span class="n">check_consistency</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ro_host_view_ds</span><span class="p">));</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">check_consistency</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">host_view_ds</span><span class="p">));</span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">device_view_ds</span> <span class="o">=</span> <span class="nl">make_device_view</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
<span class="c1">// some modification on device side</span>
<span class="p">...</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span>
<span class="c1">// both write views are in an inconsistent state and cannot be used</span>
<span class="c1">// read only view can be used (ro_host_view_ds)</span>
<span class="n">ds</span><span class="p">.</span><span class="n">reactivate_device_views</span><span class="p">();</span>
<span class="c1">// device_view_ds is in a consistent state,</span>
<span class="c1">// host_view_ds is in an inconsistent state</span>
<span class="c1">// ro_host_view_ds is in an inconsistent state</span>
<span class="c1">// some modification on device side</span>
<span class="p">...</span>
<span class="n">ds</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span>
<span class="c1">// both write views are in an inconsistent state and cannot be used</span>
<span class="c1">// read only view can be used (ro_host_view_ds)</span>
<span class="n">ds</span><span class="p">.</span><span class="n">reactivate_host_views</span><span class="p">();</span>
<span class="c1">// device_view_ds is in an inconsistent state,</span>
<span class="c1">// host_view_ds is in a consistent state</span>
<span class="c1">// ro_host_view_ds is in a consistent state</span>
<span class="c1">// some modification on host side</span>
</pre></div>
</div>
<p><strong>Interface</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">data_view</span></code> construction is usually performed with specific <cite>makers</cite> and the use of <code class="docutils literal notranslate"><span class="pre">auto</span></code>, as</p>
<p>Access is either <code class="docutils literal notranslate"><span class="pre">access_mode::read_only</span></code> or <code class="docutils literal notranslate"><span class="pre">access_mode::read_write</span></code> and the definitions are found in <code class="docutils literal notranslate"><span class="pre">storage/common/definitions.hpp</span></code>. <code class="docutils literal notranslate"><span class="pre">view1</span></code> can be used by a host thread to access data elements, since the view <cite>points</cite> to host memory. <code class="docutils literal notranslate"><span class="pre">view2</span></code> is a view that can be passed to a CUDA kernel, for instance, since it points to GPU memory, so that the kernel can use <code class="docutils literal notranslate"><span class="pre">view::operator()</span></code> to access data elements.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">data_view</span></code> object provides methods for performing following things:</p>
<ul class="simple">
<li><cite>bool valid() const</cite>: Check if view contains valid pointers, and simple state machine checks. Be aware that this is not a full check. In order to check if a view is in a consistent state use check_consistency function.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">dim()</span> <span class="pre">const</span></code>: get the aligned size of a dimension. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;dims()</span> <span class="pre">const</span></code>: return the array of (aligned) dims. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">stride()</span> <span class="pre">const</span></code>: get aligned the stride of dimension.</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span> <span class="pre">const</span> <span class="pre">array&lt;uint_t,</span> <span class="pre">ndims&gt;</span> <span class="pre">&amp;strides()</span> <span class="pre">const</span></code>: return the array of (aligned) strides.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;int</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">int</span> <span class="pre">unaligned_dim()</span> <span class="pre">const</span></code>: get the unaligned size of a dimension. (Deprecated.)</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">begin()</span> <span class="pre">const</span></code>: retrieve the position of the first non halo point in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">end()</span> <span class="pre">const</span></code>: retrieve the position of the last non halo point in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_begin()</span> <span class="pre">const</span></code>: retrieve the position of the first point (can also be a halo point) in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_end()</span> <span class="pre">const</span></code>: retrieve the position of the last point (can also be a halo point) in dimension <cite>D</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">length()</span> <span class="pre">const</span></code>: retrieve the total number of data points (excluding padding, halo, initial offset) in dimension <cite>D</cite> (<cite>equivalent to end&lt;D&gt;()-begin&lt;D&gt;()+1</cite>).</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">total_length()</span> <span class="pre">const</span></code>: retrieve the total number of data points (excluding padding, initial offset) in dimension <cite>D</cite> (<cite>equivalent to total_end&lt;D&gt;()-total_begin&lt;D&gt;()+1</cite>).</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;uint_t</span> <span class="pre">D&gt;</span> <span class="pre">constexpr</span> <span class="pre">uint_t</span> <span class="pre">padded_total_length()</span> <span class="pre">const</span></code>: retrieve the total number of data points in dimension <cite>D</cite>, including eventual padding.</li>
<li><cite>constexpr int padded_total_length() const</cite>: retrieve the total number of data points.</li>
<li><cite>constexpr int total_length() const</cite>: retrieve the total number of data points (excluding padding, initial offset).</li>
<li><cite>constexpr int length() const</cite>: retrieve the total number of data points (excluding padding, halo, initial offset).</li>
<li><cite>template &lt;typename… Coords&gt; data_t&amp; operator()(Coords… c) const</cite>: used to access elements. E.g., view(0, 0, 2) will return the third element.</li>
<li><cite>bool check_consistency(DataStore const&amp;, DataView const&amp;)</cite>: perform a full check if the given view can be used to modify or access the data in a proper way.</li>
</ul>
</div>
<div class="section" id="storage-facility">
<h3>Storage Facility<a class="headerlink" href="#storage-facility" title="Permalink to this headline">¶</a></h3>
<p>Writing the types all the time is cumbersome and unneeded. To get rid of this effort the storage module provides
a <code class="docutils literal notranslate"><span class="pre">storage-facility</span></code> that provides the correct types for a chosen computation <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>.</p>
<p>The only header that has to be included to use the storage infrastructure is <code class="docutils literal notranslate"><span class="pre">storage/storage-facility.hpp</span></code>. This provides
the <code class="docutils literal notranslate"><span class="pre">storage-facility</span></code> which returns the correct types for the chosen <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="c1">// get the correct 3D layouted and aligned storage info suitable for the chosen backend</span>
<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;::</span><span class="n">storage_info_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// get a data store suitable for the chosen backend</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">si</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">ds</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">backend_t</span></code> specifies the <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> that will execute the computation, see
<a class="reference internal" href="#backend-selection"><span class="std std-ref">Selecting the Backend</span></a>.</p>
<p><strong>Interface</strong>:</p>
<p>Following type queries are available:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">storage_info_t&lt;Id,</span> <span class="pre">Dims,</span> <span class="pre">Halo&gt;</span></code>: Retrieve an n-dimensional storage info with the correct layout and memory alignment.</li>
<li><code class="docutils literal notranslate"><span class="pre">custom_layout_storage_info_t&lt;Id,</span> <span class="pre">LayoutMap,</span> <span class="pre">Halo&gt;</span></code>: Retrieve an storage info with a specific memory layout.</li>
<li><code class="docutils literal notranslate"><span class="pre">special_storage_info_t&lt;Id,</span> <span class="pre">Selector,</span> <span class="pre">Halo&gt;</span></code>: Retrieve an storage info with a masked dimensions. The selector defines which dimensions are masked (e.g., <code class="docutils literal notranslate"><span class="pre">selector&lt;1,</span> <span class="pre">0,</span> <span class="pre">1&gt;</span></code> I and K is not masked, J dimension is masked).</li>
<li><code class="docutils literal notranslate"><span class="pre">data_store_t</span> <span class="pre">&lt;ValueType,</span> <span class="pre">StorageInfo&gt;</span></code>: Get a <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> type that contains a suitable storage type.</li>
</ul>
</div>
</div>
<div class="section" id="dsl-introduction">
<h2>DSL Introduction<a class="headerlink" href="#dsl-introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>Using GridTools<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>TODO: Explain the different modules and how to use
them, i.e. reference the main headers of each components</p>
</div>
<div class="section" id="syntax-compile-time-protections">
<h3>Syntax Compile-Time Protections<a class="headerlink" href="#syntax-compile-time-protections" title="Permalink to this headline">¶</a></h3>
<p>TODO: explain the errors obtained with GT_STATIC_ASSERT</p>
</div>
</div>
<div class="section" id="stencil-operators">
<span id="id7"></span><h2>Stencil Operators<a class="headerlink" href="#stencil-operators" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><em>Stencil operators</em> are the equivalent of <cite>functors</cite> in regular C++</dt>
<dd>code, or they may be considered to be the <cite>GridTools functions</cite>. They
are assumed to have no side-effects and no status (this is why they are marked as <cite>static</cite>). As functions they have an
<cite>interface</cite> and an <cite>implementation</cite>. The interface informs both the caller,
on the order and types of arguments that have to be passed to it, and
the implementation, on the names and types of the symbols available
to it.</dd>
</dl>
<p>The stencil operator specifies the computation to be performed in each
point of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> of the stencil
<a class="reference internal" href="../glossary/glossary.html#term-computation"><span class="xref std std-term">Computation</span></a>. In the
implementation, a point of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> at
which the stencil operator is called is referred to as <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.</p>
<p>A stencil operator is a <cite>class</cite>, or a <cite>struct</cite>, with the following
public properties:</p>
<ul class="simple">
<li>A list of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> types that are associated to the
[Data Field](data field)s the stencil operator will access in its
implementation.</li>
<li>A <cite>param_list</cite> listing all the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> types defined above</li>
<li>A set of <em>static template member functions</em> named <cite>apply</cite>, also
referred to as <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Methods</span></a>. To run on GPUs the function should
also be a GT_FUNCTION</li>
</ul>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Add reference to GT_FUNCTION</p>
</div>
<p>See the <a class="reference internal" href="#stencil-operator-example"><span class="std std-ref">Example</span></a> for a concrete usage of the syntax of the stencil operators.</p>
<div class="section" id="accessor-type">
<h3>Accessor Type<a class="headerlink" href="#accessor-type" title="Permalink to this headline">¶</a></h3>
<p>There are two kinds of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>:</p>
<ul class="simple">
<li><a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Regular Accessors</span></a>, or simply <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>, indicate an access to a regular <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> of a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>.</li>
<li><a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessors</span></a> indicate that the data to be referred does not participate in the iteration and always point to a same <em>read only</em> datum to be used in the operator.</li>
</ul>
<p>An <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> type is a <cite>using</cite> statement with this form</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">name</span> <span class="o">=</span> <span class="k">accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">intent</span><span class="p">,</span> <span class="p">[</span><span class="n">location_type</span><span class="p">,]</span> <span class="k">extent</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">name</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>where</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">name</span></code> is the name associated to the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> and will be used in the
implementation of the stencil operator.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> names are
technically optional, since their types can be substituted in all
occurrences of their names. It is anyway part of the GridTools syntax,
since a version not using them would be largely unreadable and very
difficult to manage.</p>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">I</span></code> is an integer index. The indices of the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> in a given
stencil operators <em>must</em> be ranging from 0 to N - 1, where N is the
number of <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> used by the stencil operator. No index can be
replicated. If these rules are not followed the compilation
fails. For <a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessors</span></a> this is the only argument.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">intent</span></code> indicates the type of access the stencil operator makes to
the data associated to the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>. Possible values are</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">intent::in</span></code> to specify <em>read-only</em> access</li>
<li><code class="docutils literal notranslate"><span class="pre">intent::inout</span></code> to specify <em>read-write</em> access. The <code class="docutils literal notranslate"><span class="pre">extent</span></code> for <code class="docutils literal notranslate"><span class="pre">inout</span></code> must be made of all zeros (see next points)</li>
</ol>
<p>Alternatively, the abbreviations <code class="docutils literal notranslate"><span class="pre">in_accessor</span></code> our <code class="docutils literal notranslate"><span class="pre">inout_accessor</span></code> can be used respectively.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">extent</span></code> defines the maximum offsets at which the implementation
will access data around the <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>. Extents are
templates that takes a list of pairs of integer numbers. Every pair
identify a dimension of the iteration space. The first number (&lt;=0)
indicates the offset in the direction of <em>decreasing</em> indices (also
called <em>minus direction</em>), while the second (&gt;=0) indicates the
offset in the direction of <em>increasing</em> indices (also called <em>plus
direction</em>). For example <code class="docutils literal notranslate"><span class="pre">extent&lt;-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">-2,</span> <span class="pre">1&gt;</span></code> specifies an
access of one element in the direction of decreasing indices (-1)
and one in the direction of increasing indices (+1) in the first
dimension; two elements in the plus direction (+2) and no elements
in the minus direction (0) in the second dimension, and finally two
elements in the minus direction and one in the plus for the third
dimension. All the numbers are <em>defaulted to 0</em>, so that <code class="docutils literal notranslate"><span class="pre">extent&lt;&gt;</span></code> is
a valid extent. <code class="docutils literal notranslate"><span class="pre">extent&lt;&gt;</span></code> is also the default extent of an <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>
and can be omitted if the last template argument takes also the
default value (see next point).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extent</span></a> with smaller
offsets than the ones the implementation is using is undefined behavior, i.e. it might
result in errors at runtime, while extents bigger that the one actually accessed
by the implementation will result in performance loss.</p>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">N</span></code> identifies the number of dimensions of the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a>.
By default this value is set to 3.</p>
</li>
</ul>
</div>
<div class="section" id="accessor-aliases">
<h3>Accessor Aliases<a class="headerlink" href="#accessor-aliases" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> alias is a regular <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> which has an offset set at compile-time.
For instance, say you have a 4 dimensional <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a>, where the last dimension refers to the
3 component u, v, w of a vector field, e.g. the wind-speed.
This vector field is accessed via an <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> called <code class="docutils literal notranslate"><span class="pre">vel</span></code></p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vel</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>For convenience we can introduce an alias to the <code class="docutils literal notranslate"><span class="pre">w</span></code> component</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">w</span> <span class="o">=</span> <span class="n">alias</span><span class="o">&lt;</span><span class="n">vel</span><span class="p">,</span> <span class="k">dimension</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;&gt;::</span><span class="n">set</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The line above sets the fourth offset at compile-time to the value 2, so that we have
the following equivalency:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">()</span> <span class="o">==</span> <span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>which may contribute to considerably lighten the notation in complicated expressions.
Note that you can still access the other dimensions with an offset, by using the alias. So that</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="k">dimension</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">w</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">vel</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="param-list">
<h3><cite>param_list</cite><a class="headerlink" href="#param-list" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">param_list</span></code> is a <cite>using</cite> statement like the following</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">accessor_list</span><span class="o">&lt;</span><span class="n">_accessors_</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">_accessors_</span></code> is a comma separated list of all the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>
specified before.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is necessary since C++ cannot infer what types have been defined as <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>.</p>
</div>
</div>
<div class="section" id="apply-method">
<span id="stencil-operators-apply-method"></span><h3><cite>Apply</cite>-Method<a class="headerlink" href="#apply-method" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">apply</span></code> methods takes at most two(2) arguments, the
type of the first one is the template type and it is usually called
<code class="docutils literal notranslate"><span class="pre">eval</span></code>. The second argument of the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> is a <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a>. Multiple versions of the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> can
be defined in the same <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a> with different <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical
Intervals</span></a>. The return type is void.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">apply</span></code> method can be defined with a single template argument, so to
skip the vertical region. In this case there could be <em>only one</em>
<a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> implementation in the stencil operator that will be
called for each point of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>.</p>
<p>The implementation is specified in the body of the <code class="docutils literal notranslate"><span class="pre">apply</span></code> methods. The
stencil operators can have other member functions that can be called
from the <code class="docutils literal notranslate"><span class="pre">apply</span></code>
methods.</p>
<p>Let us assume the <code class="docutils literal notranslate"><span class="pre">apply</span></code> methods has the following signature:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Eval</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span>
<span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Eval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eval</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
</pre></div>
</div>
<p>The way to access data corresponding to a certain data field passed to
it, is to indicate the corresponding <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> as argument to the
<code class="docutils literal notranslate"><span class="pre">eval</span></code> argument, as follow:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">accessor_name</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The parentheses after <code class="docutils literal notranslate"><span class="pre">accessor_name</span></code> indicate the default constructor
of the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>. This is a technicality necessary to make the
syntax legal in C++.</p>
</div>
<p>The previous syntax is said to <em>evaluate the :term:`Accessor` at the
:term:`Iteration Point`</em>.</p>
<p>For Regular Grids values can be accessed at offsets (relative to the
evaluation point) passing to the constructor
of the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> a sequence of integer indices, as follows:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">accessor_name</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>This means to access an element at an offset of 1 in the first
dimension (plus direction) of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>, and an offset of 1 in the minus direction
in the third dimension. A way to think of it is to consider the point
of evaluation as a triplet <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code>, and those offsets are
added to the current index coordinates to identifying the actual value
to access.</p>
<p>The evaluation returns a reference to the value for <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> with
<code class="docutils literal notranslate"><span class="pre">inout</span></code> intent, and a const reference for <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> with <code class="docutils literal notranslate"><span class="pre">in</span></code> intent.</p>
<p>The next example takes the difference between two value in the first
dimension and assign it to the output field:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">())</span> <span class="o">-</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>When using expressions, the previous example can be simplified to
read:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">()</span> <span class="o">-</span> <span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<span id="stencil-operator-example"></span><h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">flx_function</span> <span class="p">{</span>

    <span class="k">using</span> <span class="n">out</span> <span class="o">=</span> <span class="k">accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">intent</span><span class="o">::</span><span class="n">inout</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">in</span>  <span class="o">=</span> <span class="k">accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">intent</span><span class="o">::</span><span class="n">in</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">lap</span> <span class="o">=</span> <span class="k">accessor</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">intent</span><span class="o">::</span><span class="n">in</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">accessor_list</span><span class="o">&lt;</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">lap</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">full_interval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="expressions">
<h3>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<p>The <cite>apply</cite>-method example provided <a class="reference internal" href="#stencil-operator-example"><span class="std std-ref">above</span></a> showed the basic syntax to access data.
We can notice that the <code class="docutils literal notranslate"><span class="pre">eval</span></code> keyword is repeated several times, which is somehow
tedious, especially when the expression is complicated it becomes quickly very hard to read.
It is possible to embed the expressions in a single eval, i.e.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">expressions</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is achieved by using the expressions namespace, in which the operations <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>,
<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">pow&lt;&gt;</span></code> are
overloaded, and generate an expression to be evaluated. An example of its
usage, demonstrating its effectiveness, can be found in the
shallow water example.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">add reference to shallow water</p>
</div>
<p>It is possible also to instantiate a compile time expression to be lazily evaluated,
useful for instance if we want to evaluate it multiple times</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">expressions</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">out</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">in</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
<span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">())</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="execution-model">
<span id="id8"></span><h2>Execution Model<a class="headerlink" href="#execution-model" title="Permalink to this headline">¶</a></h2>
<p>Stencil operations are executed in a three dimensional index
space. This means that the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>
is three dimensional. The first two dimensions of the iteration space,
usually referred to as <cite>I</cite> and <cite>J</cite> dimensions identify the <cite>IJ</cite>
plane. There is no prescription on how the stencil operators in
different points of the <cite>IJ</cite> plane will be executed. Stencil operators
in the third dimension of the iteration space, usually referred as <cite>K</cite>
or vertical dimension, can have prescribed order of executions. There
are three different ways of executing on the <cite>K</cite> dimension:</p>
<ul class="simple">
<li><cite>forward</cite>: The computation at index <cite>k</cite> in the vertical dimension is executed
after index <cite>k-1</cite>;</li>
<li><cite>backward</cite>: The computation at index <cite>k</cite> in the vertical dimension is
executed after index <cite>k+1</cite>;</li>
<li><cite>parallel</cite>: No order is specified and execution can happen concurrently.</li>
</ul>
<p>An execution strategy for a computation is indicated by <code class="docutils literal notranslate"><span class="pre">execute::order()</span></code>,
where <cite>order</cite> is one of the <cite>K</cite> dimension execution orders: <code class="docutils literal notranslate"><span class="pre">forward</span></code>, <code class="docutils literal notranslate"><span class="pre">backward</span></code>, <code class="docutils literal notranslate"><span class="pre">parallel</span></code>.</p>
<p>The parallel execution policy allows for tuning the degree of parallelism (in the CUDA backend), by selecting
<code class="docutils literal notranslate"><span class="pre">execute::parallel_block&lt;vertical_block_size&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">vertical_block_size</span></code> describes the dimension of CUDA block
in the vertical (a too high value e.g. each k-level in a separate CUDA-thread might result in a too low instruction level
parallelism and therefore in non-optimal performance).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The option to specify the vertical block size will most likely be moved to the backend in the future,
see <a class="reference internal" href="#backend-selection"><span class="std std-ref">Selecting the Backend</span></a>.</p>
</div>
</div>
<div class="section" id="stencil-composition">
<span id="id9"></span><h2>Stencil Composition<a class="headerlink" href="#stencil-composition" title="Permalink to this headline">¶</a></h2>
<div class="section" id="preparing-arguments-storage-placeholders">
<span id="placeholders"></span><h3>Preparing Arguments: Storage Placeholders<a class="headerlink" href="#preparing-arguments-storage-placeholders" title="Permalink to this headline">¶</a></h3>
<p>To allow naming arguments, that are passed to stencil computations, at compile
time, <cite>GridTools</cite> uses <cite>storage placeholders</cite>. The storage placeholders are pairs of
an integer identifier and a storage type (a <cite>GridTools</cite> <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> type).</p>
<p>For example</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">p_in</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">p_out</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>defines two placeholders named <cite>p_in</cite> and <cite>p_out</cite>. Note that the identifier,
that is, the first argument passed to <cite>arg</cite>, must be unique in the computation using it.</p>
<p>A second placeholder type for temporary data exists that can be defined in
exactly the same way:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">p_tmp</span> <span class="o">=</span> <span class="k">tmp_arg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you define multiple placeholders with the same ID, they can not be
distinguished by <cite>GridTools</cite> even if they have different names or storage types!
Further, <cite>arg</cite> and <cite>tmp_arg</cite> arguments must not share their identifiers
either. So be careful when choosing your placeholder IDs.</p>
</div>
<p>The placeholders can be used as arguments to certain <cite>GridTools</cite> functions. There are
two use cases: first, they might define the argument types of a returned
object, e.g., in</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">stage</span> <span class="o">=</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">some_stage</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_in</span><span class="p">(),</span> <span class="n">p_tmp</span><span class="p">(),</span> <span class="n">p_out</span><span class="p">());</span>
</pre></div>
</div>
<p>they define the argument names and types that the returned stage accepts (see
further below for documentation of the <cite>make_stage</cite> function). The second use
case is binding run-time values to previously declared arguments, e.g.,</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">computation</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">output_data</span><span class="p">);</span>
</pre></div>
</div>
<p>runs a computation on <cite>input_data</cite> and <cite>output_data</cite>. Storages must only be
assigned to <cite>arg</cite> placeholders, all data for the <cite>tmp_arg</cite> arguments is managed
by <cite>GridTools</cite>.</p>
</div>
<div class="section" id="defining-the-iteration-space-the-grid">
<span id="defining-iteration-space"></span><h3>Defining the Iteration Space: the Grid<a class="headerlink" href="#defining-the-iteration-space-the-grid" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a> describe operations on a single <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.
The <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> defines on which points the operator should be applied. In this section
we cover how to define the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> with the <code class="docutils literal notranslate"><span class="pre">grid</span></code> object.</p>
<p><cite>GridTools</cite> offers a set of functions which ease the construction of the <code class="docutils literal notranslate"><span class="pre">grid</span></code>:</p>
<dl class="function">
<dt id="_CPPv39make_gridiii">
<span id="_CPPv29make_gridiii"></span><span id="make_grid__i.i.i"></span>grid <code class="descname">make_grid</code><span class="sig-paren">(</span>int <em>size_i</em>, int <em>size_j</em>, int <em>size_k</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39make_gridiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The simplest <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> will iterate the cube defined by the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Intervals</span></a>
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">size_i-1]</span></code>, <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">size_j-1]</span></code>, <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">size_k-1]</span></code></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39make_grid15halo_descriptor15halo_descriptori">
<span id="_CPPv29make_grid15halo_descriptor15halo_descriptori"></span><span id="make_grid__halo_descriptor.halo_descriptor.i"></span>grid <code class="descname">make_grid</code><span class="sig-paren">(</span>halo_descriptor <em>halo_i</em>, halo_descriptor <em>halo_j</em>, int <em>size_z</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39make_grid15halo_descriptor15halo_descriptori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>For finer control of the iteration space a <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptor</span></a> can be passed for the horizontal directions (<code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>).
The 3rd and 4th argument of the <code class="docutils literal notranslate"><span class="pre">halo_descriptor</span></code> define the start and the endpoint of the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only the 3rd and the 4th argument in the halo descriptor is used the stencil-composition,
but we kept the same implementation we had in other parts of GridTools to avoid introducing too many concepts.
This will be improved in the future.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The vertical dimension cannot be defined with a <code class="docutils literal notranslate"><span class="pre">halo_descriptor</span></code>, see <a class="reference internal" href="#vertical-regions"><span class="std std-ref">next section</span></a>.</p>
</div>
</div>
<div class="section" id="vertical-regions-and-vertical-boundary-conditions">
<span id="vertical-regions"></span><h3>Vertical Regions and Vertical Boundary Conditions<a class="headerlink" href="#vertical-regions-and-vertical-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, the <cite>GridTools</cite> <a class="reference internal" href="../glossary/glossary.html#term-execution-model"><span class="xref std std-term">Execution Model</span></a>
allows to be sequential in the vertical dimension (<code class="docutils literal notranslate"><span class="pre">k</span></code>). Additionally, <cite>GridTools</cite>
offers the possibility to split the vertical dimension into vertical regions,
where stencils can perform different operations. Typical applications of this pattern are models which define
terrain-following coordinates close to the earth surface and flat-coordinates in upper
levels of the atmosphere. Another use-case are vertical boundary-conditions which can
be directly integrated into the stencil operation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the following we will distinguish two concepts: first <a class="reference internal" href="../glossary/glossary.html#term-vertical-region"><span class="xref std std-term">Vertical Regions</span></a> are non-overlapping
subsets of the vertical <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a> with run-time defined sizes; second <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a> (or just <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Interval</span></a>)
are compile-time defined descriptions from one vertical level (not every vertical level can be selected, see below) to another.</p>
</div>
<div class="section" id="default-interval">
<h4>Default Interval<a class="headerlink" href="#default-interval" title="Permalink to this headline">¶</a></h4>
<p>In simple applications, where all vertical levels should be treated equally, <cite>GridTools</cite> allows to
use a default <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> which covers the full vertical region. In this case the <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a>
should be defined without specifying an <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> and the iteration space can be defined as explained
in the <a class="reference internal" href="#defining-iteration-space"><span class="std std-ref">previous section</span></a>.</p>
</div>
<div class="section" id="defining-vertical-intervals">
<h4>Defining Vertical Intervals<a class="headerlink" href="#defining-vertical-intervals" title="Permalink to this headline">¶</a></h4>
<p><cite>GridTools</cite> allows to split the full vertical iteration space into regions. The number of vertical regions needs to be specified at
compile-time, while the size of each region can be defined at run-time.</p>
<p>For defining a computation with more than a single vertical region we need to define an <code class="docutils literal notranslate"><span class="pre">axis</span></code> first.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">my_axis_t</span> <span class="o">=</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <cite>N</cite> describes the number of vertical regions.</p>
<p>At runtime the axis is instantiated with the sizes of each region,</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">my_axis_t</span> <span class="n">my_axis</span><span class="p">{</span><span class="n">N0</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="p">...};</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">Nx</span></code> are the sizes of region <code class="docutils literal notranslate"><span class="pre">x</span></code>. With our axis object we can now generate a grid with one of the following
signatures</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">grid</span> <span class="n">make_grid</span><span class="p">(</span><span class="kt">int</span> <span class="n">size_i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">my_axis</span><span class="p">)</span>
<span class="k">grid</span> <span class="n">make_grid</span><span class="p">(</span><span class="k">halo_descriptor</span> <span class="n">halo_i</span><span class="p">,</span> <span class="k">halo_descriptor</span> <span class="n">halo_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">my_axis</span><span class="p">)</span>
</pre></div>
</div>
<p>Each region already defines a <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> which can be queried from the axis by</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">first_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">second_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">full_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">full_interval</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Intervals</span></a> are compile time object, i.e. C++ types. These <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Intervals</span></a>
are used for defining which <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> version of the stencil operator should be used during the iteration.</p>
<p><a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> provides meta-functions which allow to define modified <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Intervals</span></a></p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">interval::first_level</span></code>, which is the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> (a C++ type) describing the first level of the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a></li>
<li><code class="docutils literal notranslate"><span class="pre">interval::last_level</span></code>, which is <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> describing the last level of the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a></li>
<li><code class="docutils literal notranslate"><span class="pre">interval::modify&lt;begin,</span> <span class="pre">end&gt;</span></code>, which is an <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> extended (<code class="docutils literal notranslate"><span class="pre">begin</span></code> &lt; 0) or shrunk (<code class="docutils literal notranslate"><span class="pre">begin</span></code> &gt; 0) at at the beginning of the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a>, and extended (<code class="docutils literal notranslate"><span class="pre">end</span></code> &gt; 0) or shrunk (<code class="docutils literal notranslate"><span class="pre">end</span></code> &lt; 0) at the end of the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">interval::shift&lt;value&gt;</span></code>, which is the <a class="reference internal" href="../glossary/glossary.html#term-interval"><span class="xref std std-term">Interval</span></a> shifted by <code class="docutils literal notranslate"><span class="pre">value</span></code>, i.e. it is a shortcut for <code class="docutils literal notranslate"><span class="pre">modify&lt;value,</span> <span class="pre">value&gt;</span></code>.</li>
</ul>
<p>Examples:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">axis_t</span> <span class="o">=</span> <span class="n">axis</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// axis with 2 vertical regions</span>
<span class="n">axis_t</span> <span class="nf">my_axis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// iteration space spans 5 + 10 levels</span>

<span class="k">using</span> <span class="n">first_interval</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// interval [0, 4]</span>
<span class="k">using</span> <span class="n">second_interval</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval1</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// [5, 14]</span>
<span class="k">using</span> <span class="n">full_interval</span> <span class="o">=</span> <span class="n">my_axis_t</span><span class="o">::</span><span class="n">full_interval</span><span class="p">;</span>         <span class="c1">// [0, 14]</span>

<span class="k">using</span> <span class="n">first_level</span> <span class="o">=</span> <span class="n">full_interval</span><span class="o">::</span><span class="n">first_level</span><span class="p">;</span>         <span class="c1">// [0]</span>
<span class="k">using</span> <span class="n">last_level</span> <span class="o">=</span> <span class="n">full_interval</span><span class="o">::</span><span class="n">last_level</span><span class="p">;</span>           <span class="c1">// [14]</span>
<span class="k">using</span> <span class="n">a_middle_level</span> <span class="o">=</span> <span class="n">second_interval</span><span class="o">::</span><span class="n">first_level</span><span class="p">;</span>    <span class="c1">// [5]</span>

<span class="k">using</span> <span class="n">a_middle_interval</span> <span class="o">=</span> <span class="n">a_middle_level</span><span class="o">::</span><span class="n">modify</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// [4, 5]</span>
<span class="k">using</span> <span class="n">a_middle_interval2</span> <span class="o">=</span> <span class="n">a_middle_interval</span><span class="o">::</span><span class="n">shift</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// [5, 6]</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-functionality-for-vertical-intervals">
<span id="vertical-regions-advanced"></span><h4>Advanced Functionality for Vertical Intervals<a class="headerlink" href="#advanced-functionality-for-vertical-intervals" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">axis</span></code> type has two additional template parameters to change defaults</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">the code block needs to be updated once ExtraOffsetsAroundFullInterval is removed</p>
</div>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">NIntervals</span><span class="p">,</span> <span class="n">int_t</span> <span class="n">ExtraOffsetsAroundFullInterval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">int_t</span> <span class="n">LevelOffsetLimit</span> <span class="o">=</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">axis</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">LevelOffsetLimit</span></code>, defines how many levels around a vertical region can be addressed. Increasing this value could have negative implications on compile-time.</li>
</ul>
</div>
</div>
<div class="section" id="composition-of-stencils">
<span id="id10"></span><h3>Composition of Stencils<a class="headerlink" href="#composition-of-stencils" title="Permalink to this headline">¶</a></h3>
<p>The main component of <cite>GridTools</cite> provide the capability of composing different
<a class="reference internal" href="../glossary/glossary.html#term-elementary-stencil"><span class="xref std std-term">Elementary Stencils</span></a>. An <a class="reference internal" href="../glossary/glossary.html#term-elementary-stencil"><span class="xref std std-term">Elementary Stencil</span></a> is the application of a single
<a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a> to an <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration
Space</span></a>. The ability to fuse multiple <a class="reference internal" href="../glossary/glossary.html#term-elementary-stencil"><span class="xref std std-term">Elementary Stencils</span></a>
allows the <cite>GridTools</cite> library to improve the memory locality of the computation by
taking advantage of the produce consumer relations. In <cite>GridTools</cite> terminology we use
the term <a class="reference internal" href="../glossary/glossary.html#term-stage"><span class="xref std std-term">Stage</span></a> to refer to an <a class="reference internal" href="../glossary/glossary.html#term-elementary-stencil"><span class="xref std std-term">Elementary Stencil</span></a> when it is composed with
other operations.</p>
<p>The result of a composition is a <a class="reference internal" href="../glossary/glossary.html#term-multi-stage-computation"><span class="xref std std-term">Multi-Stage Computation</span></a>, also called <cite>multi-stage stencil</cite> or
simply <cite>stencil</cite>. For reason of uniformity, a <a class="reference internal" href="../glossary/glossary.html#term-multi-stage-computation"><span class="xref std std-term">Multi-Stage Computation</span></a> with a
singe <a class="reference internal" href="../glossary/glossary.html#term-stage"><span class="xref std std-term">Stage</span></a>, is still called a multi-stage, since the composition is generally
assumed to take a list of stages, even if the stage is just one.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This decision put the emphasis on the fact that composition
is considered the main feature of <cite>GridTools</cite>. If your application
is made of a simple stencil, or stencils that cannot be
composed (see below), then <cite>GridTools</cite> may not be the right solution
for you.</p>
</div>
<p><cite>GridTools</cite> allows multi-stage computations to be composed. The final composition,
with the addition of a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a> is simply called a <cite>GridTools</cite>
<a class="reference internal" href="../glossary/glossary.html#term-computation"><span class="xref std std-term">Computation</span></a>, or simply <a class="reference internal" href="../glossary/glossary.html#term-computation"><span class="xref std std-term">Computation</span></a>.</p>
<p>Before entering the details of what can be composed and what not, let
us show first an example of a stencil composition: a simple horizontal
diffusion stencil.</p>
<p>First we need to specify the stages. A stage is specified by
indicating a <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a> and some
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a> to its arguments. The placeholders are
aliases to the actual arguments and are used to compute the data
dependencies of the computation independently of the actual data
fields that will be accessed by the computation. The syntax for
specifying a stage uses a helper function called <cite>make_stage</cite>:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">stage</span> <span class="o">=</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">plc0</span><span class="p">(),</span> <span class="n">plc1</span><span class="p">(),</span> <span class="p">...);</span>
</pre></div>
</div>
<p>Where the <cite>operator</cite> is the stencil operator of the stage and the <cite>plc0</cite>,
<cite>plc1</cite>, … are the placeholders. The number and the intent of the placeholders
depend on the <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operator</span></a>.</p>
<p>A multi-stage computation is a concatenation of stages, plus the indication of
the <a class="reference internal" href="../glossary/glossary.html#term-execution-order"><span class="xref std std-term">Execution Order</span></a> to be used for all the stages as in
the following example for a diffusion operator.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">multi_stage</span> <span class="o">=</span> <span class="nl">make_multistage</span><span class="p">(</span>
    <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
    <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not possible to make a multi-stage computation with stages of different
<a class="reference internal" href="../glossary/glossary.html#term-execution-order"><span class="xref std std-term">Execution Orders</span></a>.</p>
</div>
<p>The data-dependence analysis of <cite>GridTools</cite> will determine the producer consumer
relations and the <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extents</span></a> at which each data field will be accessed. This
information is then passed to the architecture specific backend for the
execution.</p>
<p>Before the computation can be executed, a <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>, specifying
the <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>, must be provided. The final example is:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">backend_t</span></code> specifies the <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> that will execute the computation.</p>
<p>The execution of the stages are assumed to happen one after the other in the
program order. This is quite important, since the data dependency analysis is
performed with this assumption. Some architectures provide different types of
synchronization, and a user may gain a little more performance if they are more
specific in the expression of the dependencies. For instance, we can assume
the <cite>flx_operator</cite> and <cite>fly_operator</cite> do not have producer-consumer
dependencies the user can specify that they are independent:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="n">make_independent</span><span class="p">(</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">())),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">make_independent</span></code> does not have impact on the data-dependency analysis but,
potentially, only on the execution schedule.</p>
<p>In general <code class="docutils literal notranslate"><span class="pre">make_computation</span></code> has the following signature:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">grid</span><span class="p">,</span> <span class="n">multi_stage0</span><span class="p">,</span> <span class="n">other_multi_stages</span><span class="p">...);</span>
</pre></div>
</div>
<p>A computation can then incorporate multiple multi-stage computations and they
may have different execution policies. This is very useful for implementing
computations that require two vertical swipes, one ascending and one
descending, but has to be used with care. Before explaining the rules for using
this feature, we provide a simple example of the syntax in the vertical
advection example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">vertical_advection</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">forward_op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_utens_stage</span><span class="p">(),</span> <span class="n">p_wcon</span><span class="p">()),</span>
    <span class="p">),</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">backward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">backward_op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_utens_stage</span><span class="p">(),</span> <span class="n">p_u_pos</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>This option is particularly useful on multi-core machines with caches, since
the backend there can actively pass information between the two stages thus
improving substantially the performance.</p>
<p>Again the multi-stages in the same computation will be executed logically in
program order. Two multi-stage computations can be concatenated if the outputs
of the stages that are used as input of the following obey the following rule:
Let <cite>u</cite> be the output of a stage <cite>S0</cite> that is input the stage <cite>S1</cite>. The <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extent</span></a>
at which <cite>u</cite> is accessed by <cite>S1</cite> must be the point-<a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extent</span></a> in the IJ plane, that is the access
of <cite>u</cite> is point-wise, so no offsets of <cite>u</cite> can be accessed. This is because the
parallel execution of the stages can produce non deterministic results
otherwise. Certain backends do not fuse multiple multi-stage computations, so
this effect could be not visible, but for portability, it is important that
this rule is understood.</p>
<p>To execute a given <a class="reference internal" href="../glossary/glossary.html#term-multi-stage-computation"><span class="xref std std-term">Multi-Stage Computation</span></a>, the
<cite>run</cite> method has to be called. Data has to be assigned to each non-temporary
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholder</span></a>.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">horizontal_diffusion</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">,</span> <span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No data can be assigned to temporary fields (i.e., <cite>tmp_arg</cite>
<a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a>). Storage for all temporary arguments is
managed by <cite>GridTools</cite>.</p>
</div>
<p>In case that the stencil is always run on the same data fields, you can also
assign those fields to the respective placeholders directly in the
<code class="docutils literal notranslate"><span class="pre">make_computation</span></code> call, i.e. at definition time instead of run time, e.g.:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">horizontal_diffusion</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="n">p_out</span><span class="p">()</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">,</span> <span class="c1">// data assignment happens here</span>
    <span class="n">p_in</span><span class="p">()</span> <span class="o">=</span> <span class="n">in_data</span><span class="p">,</span> <span class="c1">// and here</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_lap</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
        <span class="n">make_independent</span><span class="p">(</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">flx_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">()),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">fly_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_fly</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_lap</span><span class="p">())),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">out_operator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">(),</span> <span class="n">p_flx</span><span class="p">(),</span> <span class="n">p_fly</span><span class="p">())</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">horizontal_diffusion</span><span class="p">.</span><span class="n">run</span><span class="p">()</span> <span class="c1">// no data has to be specified here</span>
</pre></div>
</div>
<p>You can mix the two patterns, that is, assign data to some placeholders at
definition time and to some at run time. But each placeholder needs exactly one
data assignment, either inside <code class="docutils literal notranslate"><span class="pre">make_computation</span></code> or inside the <code class="docutils literal notranslate"><span class="pre">run</span></code>
method. It is therefore not possible to override definition-time assignments
present in <code class="docutils literal notranslate"><span class="pre">make_computation</span></code> at run time in the <code class="docutils literal notranslate"><span class="pre">run</span></code> method.</p>
<p>There are other details that pertain <a class="reference internal" href="../glossary/glossary.html#term-placeholder"><span class="xref std std-term">Placeholders</span></a>,
<a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a> and also other <cite>GridTools</cite>
constructs that can greatly improve performance of the computations, especially
<a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a>.</p>
</div>
<div class="section" id="selecting-the-backend">
<span id="backend-selection"></span><h3>Selecting the Backend<a class="headerlink" href="#selecting-the-backend" title="Permalink to this headline">¶</a></h3>
<p>One of the key concepts of <cite>GridTools</cite> is portability between different target architectures.
Stencil operators are written and composed in an architecture-independent way and then instantiated
for a given <code class="docutils literal notranslate"><span class="pre">backend</span></code>. The <code class="docutils literal notranslate"><span class="pre">backend</span></code> is a tag type with a <code class="docutils literal notranslate"><span class="pre">target</span></code> argument with the following possible values:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">target::cuda</span></code>: a GPU-enabled backend for NVIDIA GPUs</li>
<li><code class="docutils literal notranslate"><span class="pre">target::mc</span></code>: a backend for modern CPUs with long vector-length.</li>
<li><code class="docutils literal notranslate"><span class="pre">target::x86</span></code>: a legacy CPU-backend with focus on caching of vertical stencils, likely to be removed in the future.</li>
</ul>
<p>Currently we recommend one of the following two backends for optimal performance</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>for GPUs or</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target</span><span class="o">::</span><span class="n">mc</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>for modern CPUs or Xeon Phis.</p>
</div>
</div>
<div class="section" id="advanced-functionality">
<h2>Advanced Functionality<a class="headerlink" href="#advanced-functionality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="stencil-functions">
<span id="id11"></span><h3>Stencil Functions<a class="headerlink" href="#stencil-functions" title="Permalink to this headline">¶</a></h3>
<p>Stencil functions offer the possibility to call <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a> from other <a class="reference internal" href="../glossary/glossary.html#term-stencil-operator"><span class="xref std std-term">Stencil Operators</span></a>.
To use stencil functions the header</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/stencil-composition/stencil-functions/stencil-functions.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>needs to be included.
Two variants are available: functional calls which return a value and procedural calls with side-effect on the given arguments (<a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a>).</p>
<div class="section" id="function-calls-call">
<h4>Function Calls: <cite>call&lt;&gt;</cite><a class="headerlink" href="#function-calls-call" title="Permalink to this headline">¶</a></h4>
<p>The basic syntax for function calls is as follows</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="k">call</span><span class="o">&lt;</span><span class="n">stencil_operator</span><span class="p">,</span> <span class="n">vertical_interval</span><span class="p">,</span> <span class="n">return_value_type</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">accessors</span><span class="p">...);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">stencil_operator</span></code> is the operator to be called, <code class="docutils literal notranslate"><span class="pre">vertical_interval</span></code> the <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> where the operator
will be applied and <code class="docutils literal notranslate"><span class="pre">return_value_type</span></code> the type of the return value for the function call. The <code class="docutils literal notranslate"><span class="pre">return_value_type</span></code> will be automatically deduced
from the first <code class="docutils literal notranslate"><span class="pre">accessor</span></code> if not specified explicitly. The context object <code class="docutils literal notranslate"><span class="pre">eval</span></code> has to be passed as the first argument to <code class="docutils literal notranslate"><span class="pre">with</span></code>, followed by
the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> which are arguments of the operator.</p>
<p>The operator needs to have exactly one <code class="docutils literal notranslate"><span class="pre">inout</span></code>-<a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> which will be the return value of the function call.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Interval</span></a> needs to be one which appears in a <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> overload of the called operator.</p>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessors</span></a> which are passed in the function call can have offsets in the usual way. Additionally the whole operator can be shifted to be executed
on a different grid point, by specifying a relative location with <code class="docutils literal notranslate"><span class="pre">at</span></code>:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">call</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">at</span><span class="o">&lt;</span><span class="n">offset_i</span><span class="p">,</span> <span class="n">offset_j</span><span class="p">,</span> <span class="n">offset_k</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(...);</span>
</pre></div>
</div>
</div>
<div class="section" id="procedure-calls-call-proc">
<h4>Procedure Calls: <cite>call_proc&lt;&gt;</cite><a class="headerlink" href="#procedure-calls-call-proc" title="Permalink to this headline">¶</a></h4>
<p>Procedural calls work in the same way as function calls, but all <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a>, which are <code class="docutils literal notranslate"><span class="pre">inout</span></code> in the operator, can be modified.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">call_proc</span><span class="o">&lt;</span><span class="n">stencil_operator</span><span class="p">,</span> <span class="n">vertical_interval</span><span class="o">&gt;::</span><span class="k">at</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">accessors</span><span class="p">...);</span>
</pre></div>
</div>
<p>Also offsets and <code class="docutils literal notranslate"><span class="pre">at</span></code> work in the same way as for function calls.</p>
<p>An example for using stencil functions can be found in the regression test <cite>horizontal_diffusion_functions.cpp</cite>.</p>
</div>
</div>
<div class="section" id="software-managed-caches">
<span id="caches"></span><h3>Software-Managed Caches<a class="headerlink" href="#software-managed-caches" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a> are syntax elements that are used
to describe data reuse pattern of the stencil computations.
They are an essential functionality of the <cite>GridTools</cite> in order
to deliver an efficient implementation of memory bound codes,
since the library uses
this information to allocate cached fields in a fast on-chip
scratch-pad memory.</p>
<p>In computing architectures like NVIDIA GPUs, where the use of
the different on-chip memory hierarchy must be explicitly
declared using the CUDA programming model, the use of <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed
Caches</span></a> of <cite>GridTools</cite> increases the data locality of stencil algorithms
and provides a significant performance speedup.</p>
<p>While the library is capable of exploiting several on-chip memory layers
(like texture cache, const cache, shared memory, and registers of NVIDIA GPUs)
the <cite>GridTools</cite> language is abstracting these underlying memory layers and
exposes syntax elements that are computing architecture agnostic.</p>
<p>Therefore the <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Cache</span></a> syntax should be used by the
user to describe <em>only</em> data reuse patterns, and not type of
on-chip memory that should be exploited (which is a decision delegated to
the computing architecture backend of the library).</p>
<p>An example of the syntax for caching certain fields of a
computation is shown below</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
   <span class="k">grid</span><span class="p">,</span>
   <span class="nl">make_multistage</span><span class="p">(</span>
       <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>
       <span class="nl">define_caches</span><span class="p">(</span><span class="k">cache</span><span class="o">&lt;</span><span class="nn">cache_type</span><span class="o">::</span><span class="n">ij</span><span class="p">,</span> <span class="nn">cache_io_policy</span><span class="o">::</span><span class="k">local</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">())),</span>
       <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
       <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_f1</span><span class="p">(),</span> <span class="n">p_f2</span><span class="p">())</span>
   <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> DSL elements are enclosed into a <code class="docutils literal notranslate"><span class="pre">define_caches</span></code> construct,
that accept any number of <code class="docutils literal notranslate"><span class="pre">cache</span></code> constructs. At the same time, each
<code class="docutils literal notranslate"><span class="pre">cache</span></code> construct can specify multiple fields that shared the same
access pattern.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is important to note that the <code class="docutils literal notranslate"><span class="pre">cache</span></code> specifications
are prescribing the behavior of the library: if a <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a>
is specified, a <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> will be used. In the rare case of
using too many <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Caches</span></a> a decrease in performance might be
observed due to saturation of available resources</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cache</span></code> construct adheres to the following syntax:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">cache</span><span class="o">&lt;</span><span class="nn">cache_type</span><span class="p">,</span> <span class="nn">cache_io_policy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_args</span><span class="p">...)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_args...</span></code> is a list of placeholders for which the specified caching
should be used.
Full examples on <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> usages can be found in the source code in the
<a class="reference external" href="https://github.com/eth-cscs/gridtools/blob/master/gt_examples/stencil-composition/horizontal_diffusion_limited.cpp">horizontal diffusion</a>
and
<a class="reference external" href="https://github.com/eth-cscs/gridtools/blob/master/regression/vertical_advection_dycore.cpp">vertical advection</a>.</p>
<p>We now describe the details of each element of the <code class="docutils literal notranslate"><span class="pre">cache</span></code> constructs.</p>
<div class="section" id="cache-type">
<span id="id12"></span><h4>Cache Type<a class="headerlink" href="#cache-type" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">cache_type</span></code> describes the type of access pattern present in our stencil for the field being cached. It’s
value can be one of the following (where we indicate the basic mean of implementation on the GPUs, so that the user can understand the amount of resources involved):</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">IJ</span></code>: cache data fields whose access pattern lies in the ij-plane, i.e. only offsets of the type <cite>i ± X</cite> or <cite>j ± Y</cite> are allowed (the GPU backend will cache these fields in shared memory).</li>
<li><code class="docutils literal notranslate"><span class="pre">K</span></code>: cache data field whose access pattern is restricted to the
k-direction, i.e. only offsets of the type <cite>k ± Z</cite> (the GPU backend will cache these fields in registers).</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An error in the specification of the <code class="docutils literal notranslate"><span class="pre">cache_type</span></code>, for example using <code class="docutils literal notranslate"><span class="pre">IJ</span></code> for a field that is accessed with k offsets will lead to compile time errors.</p>
</div>
</div>
<div class="section" id="cache-policy">
<span id="id13"></span><h4>Cache Policy<a class="headerlink" href="#cache-policy" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">cache_policy</span></code> specifies a synchronization policy between the data in the <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> and the data in main memory. A scratch-pad can be used
in order to allocate temporary computations that do not require data persistency across multiple stencils. However often the data that is
being cached is already present in main memory fields. In this case, the <a class="reference internal" href="../glossary/glossary.html#term-software-managed-cache"><span class="xref std std-term">Software-Managed Caches</span></a> of <cite>GridTools</cite> gives the possibility
to specify a <a class="reference internal" href="../glossary/glossary.html#term-cache-policy"><span class="xref std std-term">Cache Policy</span></a> that allows to synchronize the main memory with the cached field.
The possible values are:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">fill</span></code>: fill the scratch-pad buffer with data from main memory field before use.</li>
<li><code class="docutils literal notranslate"><span class="pre">flush</span></code>: After the execution of the stencil operators the data in the <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> is written back into the main memory fields.</li>
<li><code class="docutils literal notranslate"><span class="pre">fill_and_flush</span></code>: The combination of <code class="docutils literal notranslate"><span class="pre">fill</span></code> and <code class="docutils literal notranslate"><span class="pre">flush</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">local</span></code>: The scratch-pad data is not persistent and only available within the scope of a multi-stage.</li>
</ol>
<blockquote>
<div><a class="reference internal" href="#fig-kcache-ex"><span class="std std-numref">Fig. 6</span></a> graphically depicts an example of all the ordered operations that are executed when a <code class="docutils literal notranslate"><span class="pre">fill_and_flush</span></code>
<a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> is used in a forward vertical loop.</div></blockquote>
<div class="figure" id="id28">
<span id="fig-kcache-ex"></span><a class="reference internal image-reference" href="../_images/kcache_ex.png"><img alt="../_images/kcache_ex.png" src="../_images/kcache_ex.png" style="width: 759.5px; height: 420.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Representation of an implementation for a <code class="docutils literal notranslate"><span class="pre">cache&lt;cache_type::k,</span> <span class="pre">cache_io_policy::fill_and_flush&gt;</span></code> that is used within a
stencil with <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extent</span></a> <code class="docutils literal notranslate"><span class="pre">&lt;-2,</span> <span class="pre">1&gt;</span></code> in the vertical dimension and implemented as a ring-buffer with 4 levels (in order to allocate all possible offsetted accesses). The three operations
are triggered automatically by the library for a <cite>fill_and_flush</cite> <a class="reference internal" href="../glossary/glossary.html#term-cache"><span class="xref std std-term">Cache</span></a> when the vertical loop transition from level 9 to level 10.</span></p>
</div>
</div>
</div>
<div class="section" id="conditionals">
<span id="id14"></span><h3>Conditionals<a class="headerlink" href="#conditionals" title="Permalink to this headline">¶</a></h3>
<p>Conditionals introduce two new syntactic elements in the computation grammar,
namely <cite>if_</cite> and <cite>switch_</cite>.  These implement run-time branches in the
computation tree, i.e. one computation or another can be chosen based on the
value of a runtime variable.  Note that this is just syntactic sugar, as you
could instantiate all the possible combinations of the computation tree and
then choose which one to execute by querying the value of a runtime condition.
This would work in the same way as the solution we will describe next, but it
would create a code of an unmanageable size most of the time: suppose that
inside a computation with 10 stages you want to choose among 5 possible
versions of the last stage. You would have to create 5 different computations,
in which the only difference is in the last stage, while the rest is repeated.
This would be tedious and error-prone.</p>
<p>The syntax we expose for <cite>if_</cite> statements is reported in the following example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="k">if_</span><span class="p">([</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">flag</span><span class="p">;</span> <span class="p">},</span>
        <span class="nl">make_multistage</span><span class="p">(</span>
            <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())</span>
        <span class="p">),</span>
        <span class="nl">make_multistage</span><span class="p">(</span>
            <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The correct way to interpret this syntax is that the call to <cite>if_</cite> returns one
multistage o the other based on the return value of the predicate attached to
<cite>flag</cite>.</p>
<p>The value of the condition is evaluated at every execution of <code class="docutils literal notranslate"><span class="pre">comp.run()</span></code>.</p>
<p>The conditionals can also be nested:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">cond</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">cond2</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="n">comp</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="k">if_</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span>
        <span class="nl">make_multistage</span><span class="p">(</span>
            <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
            <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())</span>
        <span class="p">),</span>
        <span class="k">if_</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span>
            <span class="nl">make_multistage</span><span class="p">(</span>
                <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
                <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())</span>
            <span class="p">),</span>
            <span class="nl">make_multistage</span><span class="p">(</span>
                <span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
                <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>The other syntactic element we introduce is a <cite>switch_</cite>, and its use is
exemplified in the following snippet</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">p</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">comp_</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="k">grid</span><span class="p">,</span>
    <span class="nl">make_multistage</span><span class="p">(</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_tmp</span><span class="p">(),</span> <span class="n">p_in</span><span class="p">()),</span>
    <span class="p">),</span>
    <span class="k">switch_</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span>
        <span class="k">case_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
            <span class="nl">make_multistage</span><span class="p">(</span><span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
                <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_tmp</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="k">case_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
            <span class="nl">make_multistage</span><span class="p">(</span><span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
                <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_tmp</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="k">case_</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span>
            <span class="nl">make_multistage</span><span class="p">(</span><span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span>
                <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_out</span><span class="p">(),</span> <span class="n">p_tmp</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As for the <cite>if_</cite> statement, the condition function is evaluated at every call
to <code class="docutils literal notranslate"><span class="pre">comp.run()</span></code>, and the multistage executed in calls depends on the value of
the condition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also <cite>switch_</cite> can be nested, as the <cite>if_</cite>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The effect of having different branches is that all the possibilities get
compiled, and only one gets chosen at each run. Therefore having lot of
branches can increase dramatically the compilation times, you should not abuse
of this feature.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently there is a limitation. The different branches in the computation
must use the same placeholders.</p>
</div>
</div>
<div class="section" id="expandable-parameters">
<span id="id15"></span><h3>Expandable Parameters<a class="headerlink" href="#expandable-parameters" title="Permalink to this headline">¶</a></h3>
<p>Expandable parameters implement a “single stencil multiple storages” pattern.
They are useful when we have a vector of storages which have the same
storage info, and we want to perform the same operation with all of them
(a typical situation when implementing e.g. time differentiation schemes).
Normally this could be achieved by creating a loop and running multiple computations,
but this solution would be inefficient. A more efficient solution is provided
through the expandable parameters API.</p>
<p>The user must collect the storage pointers in a <code class="docutils literal notranslate"><span class="pre">`std::vector`</span></code></p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">storage_t</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">storage1</span><span class="p">,</span> <span class="n">storage2</span><span class="p">,</span> <span class="n">storage3</span><span class="p">,</span> <span class="n">storage4</span><span class="p">,</span> <span class="n">storage5</span><span class="p">,</span> <span class="n">storage6</span><span class="p">,</span> <span class="n">storage7</span><span class="p">,</span> <span class="n">storage8</span><span class="p">};</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> is then used as a storage type with no differences with respect to
the regular storages.</p>
<p>The implementation requires the user to specify an integer <code class="docutils literal notranslate"><span class="pre">`expand_factor`</span></code> when defining the computation:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">comp_</span> <span class="o">=</span> <span class="nl">make_expandable_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>
       <span class="k">expand_factor</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span>
       <span class="n">domain_</span><span class="p">,</span>
       <span class="n">grid_</span><span class="p">,</span>
       <span class="nl">make_multistage</span><span class="p">(</span><span class="k">execute</span><span class="o">::</span><span class="k">forward</span><span class="p">(),</span> <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">functor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">())));</span>
</pre></div>
</div>
<p>The vector of
storages is then partitioned into chunks of <code class="docutils literal notranslate"><span class="pre">expand_factor</span></code> size (with a remainder). Each
chunk is unrolled within a computation, and for each chunk a different computation is
instantiated. The remainder elements are then processed one by one.</p>
<p>Summing up, the only differences with respect to the case without expandable parameters are:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">make_expandable_computation</span></code> has to be used instead of <code class="docutils literal notranslate"><span class="pre">make_computation</span></code></li>
<li>an <code class="docutils literal notranslate"><span class="pre">expand_factor</span></code> has to be passed to the <code class="docutils literal notranslate"><span class="pre">make_expandable_computation</span></code>, defining the size of the chunks of</li>
<li>expandable parameters should be unrolled in each computation.</li>
<li>a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> of storage pointers has to be used instead of a single storage.</li>
</ul>
<p>All the rest is managed by <cite>GridTools</cite>, so that the user is not exposed to the complexity of the
unrolling, he can reuse the code when the expand factor changes, and he can resize dynamically the expandable
parameters vector, for instance by adding or removing elements.</p>
</div>
<div class="section" id="global-parameters-and-accessors">
<span id="global-accessor"></span><h3>Global Parameters and Accessors<a class="headerlink" href="#global-parameters-and-accessors" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessors</span></a> are accessing read-only data which is independent of the current <a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>.
For this reason, intent, <a class="reference internal" href="../glossary/glossary.html#term-extent"><span class="xref std std-term">Extents</span></a> and offsets cannot be specified for a <a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessor</span></a>.
Here the term <cite>global</cite> means that the data is the same for the whole <a class="reference internal" href="../glossary/glossary.html#term-iteration-space"><span class="xref std std-term">Iteration Space</span></a>. An example can be
a constant scalar parameter that you want to pass to the functor, or a user defined struct containing
various configuration options.</p>
<p>The API allows the user to define an arbitrary object to act as a <cite>global parameter</cite> as long as it is trivially copyable.
To create a global parameter from a user-defined object, we pass the object to <code class="docutils literal notranslate"><span class="pre">make_global_parameter()</span></code></p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">my_global_parameter</span> <span class="o">=</span> <span class="n">backend_t</span><span class="o">::</span><span class="nl">make_global_parameter</span><span class="p">(</span><span class="n">my_object</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the object is read-only only during the execution of a computation, but can be modified
in between executions with</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">backend_t</span><span class="o">::</span><span class="nl">update_global_parameter</span><span class="p">(</span><span class="n">my_global_parameter</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor</span></a> associated with a global parameter must be a <a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessor</span></a></p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">global_acc</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Calling <code class="docutils literal notranslate"><span class="pre">eval</span></code> on the <a class="reference internal" href="../glossary/glossary.html#term-global-accessor"><span class="xref std std-term">Global Accessor</span></a> returns the user defined data structure. Supposing that
this data structure contains a user function called <code class="docutils literal notranslate"><span class="pre">ordinal</span></code>, returning an integer, we can write
in the do method</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">ordinal_</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">global_boundary</span><span class="p">()).</span><span class="n">ordinal</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All the member functions defined in the user-defined
data structure must be labeled with GT_FUNCTION, in
order for them to be callable from devices.</p>
</div>
<p>There is a special case for which we have a dedicated API: i.e. when the user defined object
(the global parameter)
defines the parenthesis operator <code class="docutils literal notranslate"><span class="pre">operator()</span></code>, and we want to call that operator from the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a>.
In that case the <a class="reference internal" href="../glossary/glossary.html#term-accessor"><span class="xref std std-term">Accessor’s</span></a> parenthesis operator can be used and the arguments will be
automatically forwarded to the global parameter. An example is the case in which we want to pass
a small matrix as a global parameter:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">global_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="boundary-conditions">
<span id="id16"></span><h2>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id17">
<h3>Introduction<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>The boundary condition module in <cite>GridTools</cite> is designed following the
principle that boundary conditions can be arbitrarily complex, so we
want the user to be able to specify any boundary condition code to set
up their problems.</p>
</div>
<div class="section" id="preliminaries">
<h3>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h3>
<p>One main concept that is needed for the boundary condition is the one
of <cite>direction</cite>.</p>
<p>In a 3D regular grid, which is where this implementation of the
boundary condition library applies, we associate a 3D axis system,
and the cell indices (i, j, k) naturally lie on it. With this axis
system the concept of “vector” can be defined to indicate
distances and directions. Direction is the one thing we need
here. Instead of using unitary vectors to indicate directions, as
it is usually the case for euclidean spaces, we use vectors whose
components are -1, 0, and 1.  For example, <span class="math notranslate nohighlight">\((1, 1, 1)\)</span> is the
direction indicated by the unit vector <span class="math notranslate nohighlight">\((1, 1, 1)/\sqrt3\)</span>.
If we take the center of a 3D grid, then we can define 26
different directions <span class="math notranslate nohighlight">\(\{(i, j, k): i, j, k \in \{-1, 0, 1\}\}\setminus\{(0, 0, 0)\}\)</span>
that identify the different faces, edges and corners of the cube to
which the grid is topologically analogous with.</p>
<p>The main idea is that a boundary condition class specializes
<cite>operator()</cite> on a <cite>direction</cite>, or a subset of directions, and then
perform the user specified computation on the boundaries on those
directions.</p>
<p>The user can define their own boundary condition classes and perform
specific computation in each direction. For this reason <cite>GridTools</cite> provides
a <code class="docutils literal notranslate"><span class="pre">direction</span></code> type which can take three direction values, that are
indicated as <code class="docutils literal notranslate"><span class="pre">minus_</span></code>, <code class="docutils literal notranslate"><span class="pre">plus_</span></code> and <code class="docutils literal notranslate"><span class="pre">zero_</span></code>, which are values of an
<code class="docutils literal notranslate"><span class="pre">enum</span></code> called <code class="docutils literal notranslate"><span class="pre">sign</span></code>.</p>
</div>
<div class="section" id="boundary-condition-class">
<span id="boundary-conditions-class"></span><h3>Boundary Condition Class<a class="headerlink" href="#boundary-condition-class" title="Permalink to this headline">¶</a></h3>
<p>The boundary condition class is a regular class which need to be copy
constructible, and whose member functions should be decorated with the
<code class="docutils literal notranslate"><span class="pre">GT_FUNCTION</span></code> keyword to enable accelerators. It must not contain references to data that may be not available on the target device where the boundary conditions are applied.</p>
<p>The boundary condition class provides overloads for the <code class="docutils literal notranslate"><span class="pre">operator()</span></code>
which take as first argument a <code class="docutils literal notranslate"><span class="pre">direction</span></code> object, a number of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data
Stores</span></a> that are the inputs, and three integer values that will contains the
coordinate indices of the cell that is being iterated on.</p>
<p>All overloads must have the same number of arguments: the first argument is the direction over which the overload will be applied to, then there is the list of <a class="reference internal" href="../glossary/glossary.html#term-data-view"><span class="xref std std-term">Data Views</span></a> that will be accessed by the boundary class, and finally three integers that contains the indices of the element being accessed in the call.
It is standard practice to let the view types be template
arguments. For instance, here a class that applies a copy-boundary
condition (copy the second view into the first one) for all direction
apart all directions for which the third component is <code class="docutils literal notranslate"><span class="pre">minus_</span></code>:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">example_bc</span> <span class="p">{</span>
   <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>

   <span class="cp">GT_FUNCTION</span>
   <span class="nf">example_bc</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Direction</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField1</span><span class="o">&gt;</span>
   <span class="cp">GT_FUNCTION</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Direction</span><span class="p">,</span>
                               <span class="n">DataField0</span> <span class="o">&amp;</span><span class="n">data_field0</span><span class="p">,</span> <span class="n">DataField1</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">data_field1</span><span class="p">,</span>
                               <span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">j</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>
   <span class="p">{</span>
     <span class="n">data_field0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">data_field1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">sign</span> <span class="n">I</span><span class="p">,</span> <span class="k">sign</span> <span class="n">J</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DataField1</span><span class="o">&gt;</span>
   <span class="cp">GT_FUNCTION</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">direction</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">minus_</span><span class="o">&gt;</span><span class="p">,</span>
                               <span class="n">DataField0</span> <span class="o">&amp;</span><span class="n">data_field0</span><span class="p">,</span> <span class="n">DataField1</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span>
                               <span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">j</span><span class="p">,</span>  <span class="kt">unsigned</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span>
   <span class="p">{</span>
     <span class="n">data_field0</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><cite>operator()</cite> of the boundary class is called by the library, on the 26 directions, and got each value in the data that correspond to each direction. In the previous example, each direction in which the third component is <code class="docutils literal notranslate"><span class="pre">minus</span></code> will select the specialized overload, while all other directions select the first implementation.</p>
</div>
<div class="section" id="boundary-condition-application">
<h3>Boundary Condition Application<a class="headerlink" href="#boundary-condition-application" title="Permalink to this headline">¶</a></h3>
<p>To apply the above boundary conditions class to the data fields, we
need to construct the boundary object, but also to specify the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>
regions. The <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> regions are specified using
<a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptors</span></a>.</p>
<p>To do this we need an array of <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptors</span></a> initialized with the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information of the data fields.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fifth number, namely the total length, in the <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo
Descriptor</span></a> is not used by the boundary condition application module,
but we kept the same implementation we had in other parts of <cite>GridTools</cite> to
avoid introducing too many concepts. This will be improved
in the future.</p>
</div>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halos</span><span class="p">;</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d2</span><span class="p">);</span>
<span class="n">halos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d3</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d3</span><span class="p">);</span>
</pre></div>
</div>
<p>After this is done we can apply the boundary condition by, as in this
example, constructing the boundary object and applying it to the data
fields. The number of data fields to pass is equal to the number of
fields the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads of the boundary class require.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">boundary</span><span class="o">&lt;</span><span class="n">example_bc</span><span class="p">,</span> <span class="n">backend_t</span><span class="o">::</span><span class="n">backend_id_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">halos</span><span class="p">,</span> <span class="n">example_bc</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
      <span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">out_s</span><span class="p">,</span> <span class="n">in_s</span><span class="p">);</span>
</pre></div>
</div>
<p>As can be noted, the <code class="docutils literal notranslate"><span class="pre">backend</span></code> is also needed to select the proper
implementation of the boundary application algorithm (see <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>). <code class="docutils literal notranslate"><span class="pre">out_s</span></code> and
<code class="docutils literal notranslate"><span class="pre">in_s</span></code> are the two data fields passed to the application. The fact
that the first is the output and second is the input derives from the
signature of the overloads of <code class="docutils literal notranslate"><span class="pre">operator()</span></code>, and it is user defined.</p>
</div>
<div class="section" id="boundary-predication">
<h3>Boundary Predication<a class="headerlink" href="#boundary-predication" title="Permalink to this headline">¶</a></h3>
<p>Predication is an additional feature to control the boundary
application.  The predicate type have to be specified as template
argument of the boundary class, and the instantiated object of that
type passed as third argument of the boundary class constructor, as in
the following example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">boundary</span><span class="o">&lt;</span><span class="n">direction_bc_input</span><span class="o">&lt;</span><span class="n">uint_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">backend_t</span><span class="o">::</span><span class="n">backend_id_t</span><span class="p">,</span> <span class="n">predicate_t</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">halos</span><span class="p">,</span> <span class="n">direction_bc_input</span><span class="o">&lt;</span><span class="n">uint_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="n">predicate_t</span><span class="p">{}).</span><span class="n">apply</span><span class="p">(</span><span class="n">out_s</span><span class="p">,</span> <span class="n">in_s</span><span class="p">);</span>
</pre></div>
</div>
<p>The predicate must obey a fixed interface, that is, it has to accept
as argument a <code class="docutils literal notranslate"><span class="pre">direction</span></code> object, so that the user can, at runtime,
disable some <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads. This can be very useful when
the user is running on a parallel domain decomposed domain, and only
the global boundaries need to updated with the boundary conditions
application and the rest should have their <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a> updated from
neighbors.</p>
</div>
<div class="section" id="provided-boundary-conditions">
<span id="id18"></span><h3>Provided Boundary Conditions<a class="headerlink" href="#provided-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> provides few boundary application classes for some common cases. They are</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">copy_boundary</span></code> to copy the last field of the argument list of <cite>apply</cite> into the other ones;</li>
<li><code class="docutils literal notranslate"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span> <span class="pre">value_boundary</span></code> to set the boundary to a value for all the data fields provided;</li>
<li><code class="docutils literal notranslate"><span class="pre">zero_boundary</span></code> to set the boundary to the default constructed value type of the data fields (usually a zero) for the input fields.</li>
</ul>
</div>
</div>
<div class="section" id="halo-exchanges">
<span id="id19"></span><h2>Halo Exchanges<a class="headerlink" href="#halo-exchanges" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id20">
<h3>Introduction<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>The communication module in <cite>GridTools</cite> is dubbed <a class="reference internal" href="../glossary/glossary.html#term-gcl"><span class="xref std std-term">GCL</span></a>. It’s a low level
halo-update interface for 3D fields that takes 3D arrays of some
types, and the descriptions of the halos, and perform the exchanges in
a scalable way.</p>
<p>It is low-level because the requirements from which it was initially
designed, required easy interoperability with C and Fortran, so the API
takes pointers and sizes. The sizes are specified by
<code class="docutils literal notranslate"><span class="pre">halo-descriptors</span></code>, which are lousily inspired by the BLAS description
of dimensions of matrices. A new, more modern set of interfaces are
being implemented, to serve more general cases, such as higher
dimensions and other grids.</p>
<p>We first start with some preliminaries and then discuss the main
interfaces.</p>
</div>
<div class="section" id="id21">
<h3>Preliminaries<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<div class="section" id="processor-grid">
<h4>Processor Grid<a class="headerlink" href="#processor-grid" title="Permalink to this headline">¶</a></h4>
<p>The processor grid is a concept that describe a 3D lattice of
computing elements (you may think at those as MPI tasks). The
identifiers of them are tuples of indices. This naturally maps to a 3D
decomposition of a data field.</p>
</div>
<div class="section" id="layout-map">
<h4>Layout Map<a class="headerlink" href="#layout-map" title="Permalink to this headline">¶</a></h4>
<p>The communication layer needs two <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Maps</span></a>:
one for describing the data, and one for the
processor grid. For the user, the dimensions of the data are always
indicated as first, second, and third (or i, j, k), it is the
<a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> that indicates the stride orders, as in the following example:</p>
<p>For instance:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="c1">//         i, j, k</span>
<span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> indicates that the first dimension in the data (i) is the
second in the increasing stride order, while the second (j) has the
biggest stride, and last dimension (k) is the one with stride 1. The
largest strides are associated to smaller indices, so that
<code class="docutils literal notranslate"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code> corresponds to a C-layout, while
<code class="docutils literal notranslate"><span class="pre">layout_map&lt;2,</span> <span class="pre">1,</span> <span class="pre">0&gt;</span></code> to a Fortran layout.</p>
<p>The second template <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> in the <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a>
pattern is the map between data coordinates and the processor
grid coordinates.</p>
<p>The following layout specification</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>would mean: The first dimension in data matches with the second
dimension of the computing grid, the second dimension of the data to
the first of the processing grid, and the third one to the third
one. This is rarely different from <code class="docutils literal notranslate"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code>, so it can
generally be ignored, but we give an example to clarify its meaning.</p>
<p>Suppose the processor grid (domain decomposition sizes) has size PIxPJx1. Now, we want
to say that the first dimension on data ‘extends’ to the
computing grid on (or that the first dimension in the data corresponds
to) the first dimension in the computing grid. Let’s consider a 2x1
process grid, and the first dimension of the data being the rows (i)
and the second the column (j). In this case we are assuming a
distribution like in <a class="reference internal" href="#fig-dist1"><span class="std std-numref">Fig. 7</span></a>.</p>
<div class="figure" id="id29">
<span id="fig-dist1"></span><a class="reference internal image-reference" href="../_images/dist1.png"><img alt="../_images/dist1.png" src="../_images/dist1.png" style="width: 624.4000000000001px; height: 405.20000000000005px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Example data distribution among two processes.</span></p>
</div>
<p>In this case the map between data and the processor grid is:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="c1">// The 3rd dimension stride is 1</span>
</pre></div>
</div>
<p>On the other hand, having specified</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for this map, would imply a layout/distribution like the following <a class="reference internal" href="#fig-dist2"><span class="std std-numref">Fig. 8</span></a>.</p>
<div class="figure" id="id30">
<span id="fig-dist2"></span><a class="reference internal image-reference" href="../_images/dist2.png"><img alt="../_images/dist2.png" src="../_images/dist2.png" style="width: 447.6px; height: 464.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Example data distribution among two processes.</span></p>
</div>
<p>Where the second dimension in the data correspond to the fist
dimension in the processor grid. Again, the data coordinates
ordering is the one the user choose to be the logical order in the
application, not the increasing stride order.</p>
</div>
<div class="section" id="halo-descriptor">
<span id="id22"></span><h4>Halo Descriptor<a class="headerlink" href="#halo-descriptor" title="Permalink to this headline">¶</a></h4>
<p>Given  a  dimension of  the  data  (array), the  communication  module
requires the user to describe  it using the <code class="docutils literal notranslate"><span class="pre">halo_descriptor</span></code> class,
which takes five integers.</p>
<p>Consider a dimension which has <code class="docutils literal notranslate"><span class="pre">minus</span></code> halo lines on one side, and
<code class="docutils literal notranslate"><span class="pre">plus</span></code> halo lines on the other (The minus and plus indicate the sides
close to index 0 and the last index of the dimension,
respectively). The beginning of the inner region is marked by <code class="docutils literal notranslate"><span class="pre">begin</span></code>
and its ending by <code class="docutils literal notranslate"><span class="pre">end</span></code>. The end is inclusive, meaning that the index
specified by it, is part of the inner region. Another value is
necessary, which has to be larger than <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">begin</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">minus</span> <span class="pre">+</span> <span class="pre">plus</span></code>, and
is the <code class="docutils literal notranslate"><span class="pre">total_length</span></code>. This parameter is the equivalent of the
“leading dimension” in BLAS. With these five numbers we can describe
arbitrary dimensions, with paddings on the left and on the right, such
as the example in <a class="reference internal" href="#fig-halo-descriptor"><span class="std std-numref">Fig. 9</span></a>.</p>
<div class="figure" id="id31">
<span id="fig-halo-descriptor"></span><a class="reference internal image-reference" href="../_images/halo_descriptor.png"><img alt="../_images/halo_descriptor.png" src="../_images/halo_descriptor.png" style="width: 480.5px; height: 284.5px;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Example halo descriptor with one halo point on the left and two on the right.</span></p>
</div>
<p>The interface for specifying a halo descriptor is fairly simple, where
the name of arguments should be self-explanatory:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">halo_descriptor</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">minus</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">plus</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">begin</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">total_length</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="gcl-communication-module">
<span id="id23"></span><h3>GCL Communication Module<a class="headerlink" href="#gcl-communication-module" title="Permalink to this headline">¶</a></h3>
<p>Now we are ready to describe the <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> patterns objects. The first one is <code class="docutils literal notranslate"><span class="pre">halo_exchange_dynamic_ut</span></code>. The <code class="docutils literal notranslate"><span class="pre">ut</span></code> suffix stands for <code class="docutils literal notranslate"><span class="pre">uniform</span> <span class="pre">types</span></code>, meaning that the data fields that this object will manage must all store the same value types, that are declared at instantiation time. The type of the object is defined as in this example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pattern_type</span> <span class="o">=</span> <span class="nl">halo_exchange_dynamic_ut</span><span class="o">&lt;</span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span>
                     <span class="n">ayout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">gcl_cpu</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The template arguments are:</p>
<ol class="arabic simple">
<li>the layout if the data;</li>
<li>the mapping between the data dimensions and processing <a class="reference internal" href="../glossary/glossary.html#term-grid"><span class="xref std std-term">Grid</span></a>, as described above (leave it as <code class="docutils literal notranslate"><span class="pre">layout_map&lt;0,</span> <span class="pre">1,</span> <span class="pre">2&gt;</span></code> if in doubt);</li>
<li>the type of the values to be exchanged;</li>
<li>the number of dimensions of the data/processing grid, and it has to be set to 3 (the GCL was designed to work with other dimensionalities, but the version in <cite>GridTools</cite> is a stripped down version waiting for the next more general interfaces);</li>
<li>the place where the data live. The options for this arguments are <code class="docutils literal notranslate"><span class="pre">gcl_gpu</span></code>, <code class="docutils literal notranslate"><span class="pre">gcl_cpu</span></code> and <code class="docutils literal notranslate"><span class="pre">gcl_mc</span></code>.</li>
</ol>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> object can be instantiated as:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">pattern_type</span> <span class="nf">he</span><span class="p">(</span><span class="n">pattern_type</span><span class="o">::</span><span class="n">grid_type</span><span class="o">::</span><span class="n">period_type</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span> <span class="n">CartComm</span><span class="p">);</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">period_type</span></code> indicate whether the corresponding dimension is
periodic or not, and CartComm if the MPI communicator describing the
computing grid.</p>
<p>After the object has been instantiated, the
user registers the halos for the corresponding dimension and the five
numbers we described above, for the three dimensions (0 is the first
dimension).</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus0</span><span class="p">,</span> <span class="n">plus0</span><span class="p">,</span> <span class="n">begin0</span><span class="p">,</span> <span class="n">end0</span><span class="p">,</span> <span class="n">len0</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus1</span><span class="p">,</span> <span class="n">plus1</span><span class="p">,</span> <span class="n">begin1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">add_halo</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minus2</span><span class="p">,</span> <span class="n">plus2</span><span class="p">,</span> <span class="n">begin2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">len2</span><span class="p">);</span>
</pre></div>
</div>
<p>When the registration is done a setup function must be called before
running data exchange. The argument in the set up function is the
maximum number of data arrays that the pattern will exchange in a
single step. In this example we set it to 3, so that exchanging more
than 3 fields will lead to a runtime error. The code looks like:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we are ready to exchange the data, by passing (up to) three
pointers to the data to pack, then calling exchange and then unpack
into the destination data, as in the following example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">array0</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array3</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">start_exchange</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">array0</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array3</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, the pointers can be put in a <code class="docutils literal notranslate"><span class="pre">std::vector&lt;value_type*&gt;</span></code> so that the code would look like:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">vector_of_pointers</span><span class="p">);</span>
<span class="n">he</span><span class="p">.</span><span class="n">start_exchange</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">vector_of_pointers</span><span class="p">);</span>
</pre></div>
</div>
<p>An alternative pattern is:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pattern_type</span> <span class="o">=</span> <span class="nl">halo_exchange_generic</span><span class="o">&lt;</span><span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">arch_type</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the <a class="reference internal" href="../glossary/glossary.html#term-layout-map"><span class="xref std std-term">Layout Map</span></a> in the type is the mapping of dimensions to the
computing grid, 3 is the number of dimensions, and arch_type is either
<code class="docutils literal notranslate"><span class="pre">gcl_gpu</span></code>, <code class="docutils literal notranslate"><span class="pre">gcl_cpu</span></code> or <code class="docutils literal notranslate"><span class="pre">gcl_mc</span></code>.</p>
<p>The construction of the object is identical to the previous one, but
the set-up somewhat more complex now, since we have to indicate the
maximum sizes and number of fields we will exchange using this object.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halo_dsc</span><span class="p">;</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">,</span> <span class="n">DIM1</span> <span class="o">+</span> <span class="n">H1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H1</span><span class="p">);</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">DIM2</span> <span class="o">+</span> <span class="n">H2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H2</span><span class="p">);</span>
<span class="n">halo_dsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">halo_descriptor</span><span class="p">(</span><span class="n">H3</span><span class="p">,</span> <span class="n">H3</span><span class="p">,</span> <span class="n">H3</span><span class="p">,</span> <span class="n">DIM3</span> <span class="o">+</span> <span class="n">H3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIM3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H3</span><span class="p">);</span>

<span class="n">he</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// maximum number of fields</span>
         <span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">layoutmap</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">,</span> <span class="n">halo_dsc</span><span class="p">),</span>
         <span class="k">sizeof</span><span class="p">(</span><span class="n">biggest_type_to_be_used</span><span class="p">));</span> <span class="c1">// Estimates the sizes</span>
</pre></div>
</div>
<p>The halo descriptors above indicate the largest arrays the user will
exchange, while the <code class="docutils literal notranslate"><span class="pre">field_on_the_fly</span></code> specify a type and layout
(and mandatory traits). The type does not have any effect here, and
neither the layout. The traits are important, and the halos are
essential.  With this pattern, the user needs to indicate what is the
size of the largest value type they will exchange.</p>
<p>When using the pattern, each data field should be wrapped into a
<code class="docutils literal notranslate"><span class="pre">field_on_the_fly</span></code> object, such as</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type1</span><span class="p">,</span> <span class="n">layoutmap1</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field1</span><span class="p">(</span>
    <span class="n">ptr1</span><span class="p">,</span> <span class="n">halo_dsc1</span><span class="p">);</span>
<span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type2</span><span class="p">,</span> <span class="n">layoutmap2</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field2</span><span class="p">(</span>
    <span class="n">ptr2</span><span class="p">,</span> <span class="n">halo_dsc2</span><span class="p">);</span>
<span class="k">field_on_the_fly</span><span class="o">&lt;</span><span class="n">value_type3</span><span class="p">,</span> <span class="n">layoutmap3</span><span class="p">,</span> <span class="n">pattern_type</span><span class="o">::</span><span class="n">traits</span><span class="o">&gt;</span> <span class="n">field3</span><span class="p">(</span>
    <span class="n">ptr3</span><span class="p">,</span> <span class="n">halo_dsc3</span><span class="p">);</span>
</pre></div>
</div>
<p>Now each field can have different types and layouts, and halo
descriptors. The exchange happens very similarly as before:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">he</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">);</span>

<span class="n">he</span><span class="p">.</span><span class="n">exchange</span><span class="p">();</span>

<span class="n">he</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,</span> <span class="n">field3</span><span class="p">);</span>
</pre></div>
</div>
<p>The interface accepting an <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> also works in case all the
fields have the same type.</p>
</div>
</div>
<div class="section" id="distributed-boundary-conditions">
<span id="id24"></span><h2>Distributed Boundary Conditions<a class="headerlink" href="#distributed-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="design-principles">
<h3>Design Principles:<a class="headerlink" href="#design-principles" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>When doing expandable parameters, the user may want to apply BCs and perform communications on a sub-set of the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> collected in these data representations. For this reason an interface for applying distributed boundary conditions takes single data-stores only.</li>
<li>The user may want to apply different BCs to the same data-store at different times during an executions, so the binding between BCs and data-stores should be done at member-function level, not at class level, in order to remove the need for instantiation of heavy objects like <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-updates.</li>
<li>The same holds for the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> to be exchanged: we need to plug the <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> at the last minute before doing the packing/unpacking and boundary apply. The requirement given by the underlying communication layer is that the number of data fields to be exchanged must be less than or equal to the maximum number of data fields specified at construction time.</li>
<li>The <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> patterns are quite heavy objects so they have to be constructed and passed around as references. The <code class="docutils literal notranslate"><span class="pre">setup</span></code> needs to be executed only once to prevent memory leaks.</li>
<li>The <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information for communication could be derived by a <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> class, but there may be cases in which a separate <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> information can be provided, and different <code class="docutils literal notranslate"><span class="pre">storage_info</span></code> s (with different indices, for instance) may have the same communication requirements (for instance in cases of implicit staggering). For this reason the <cite>halo_descriptor</cite> is passed explicitly to the distributed boundary construction interface.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">value_type</span></code> should be passed as an additional template parameter to the distributed boundaries interfaces. The <code class="docutils literal notranslate"><span class="pre">value_type</span></code> is used to compute the sizes of the buffers and the data movement operations needed by communication.</li>
</ul>
</div>
<div class="section" id="communication-traits">
<h3>Communication Traits<a class="headerlink" href="#communication-traits" title="Permalink to this headline">¶</a></h3>
<p>Communication traits helps the distributed boundary condition interface to customize itself to the need of the user. A general communication traits class is available in <code class="docutils literal notranslate"><span class="pre">distributed-boundaries/comm_traits.hpp</span></code>. The traits required by the distributed boundaries interface, as provided by <cite>GridTools</cite>, are listed below here.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">StorageType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arch</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">comm_traits</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">proc_layout</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Lauyout of the processing grid to relate the data layout to the distribution of data</span>
  <span class="k">using</span> <span class="n">proc_grid_type</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Type of the computing grid</span>
  <span class="k">using</span> <span class="n">comm_arch_type</span> <span class="o">=</span> <span class="n">Arch</span><span class="p">;</span> <span class="c1">// Architecture for the communication pattern</span>
  <span class="n">compute_arch</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Architecture of the stencil/boundary condition backend</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">version</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Packing/Unpacking version</span>
  <span class="k">using</span> <span class="n">data_layout</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">StorageType</span><span class="o">::</span><span class="n">storage_info_t</span><span class="o">::</span><span class="n">layout_t</span><span class="p">;</span> <span class="c1">// Layout of data</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">StorageType</span><span class="o">::</span><span class="n">data_t</span><span class="p">;</span> <span class="c1">// Value Type</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="binding-boundaries-and-communication">
<h3>Binding Boundaries and Communication<a class="headerlink" href="#binding-boundaries-and-communication" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> provides a facility for applying boundary conditions. The distributed boundaries interfaces uses this facility underneath. The boundary application in <cite>GridTools</cite> accept specific boundary classes that specify how to deal with boundaries in different directions and predicated to deal with periodicity and domain decomposition. The latter will be dealt by the distributed boundary interfaces (refer to the boundary condition interfaces for more details).</p>
<p>The distributed boundaries interface require a user to specify which <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> required communication and which require also boundary conditions, and in the latter case what boundary functions to use.</p>
<p>The way of specifying this is through the function <code class="docutils literal notranslate"><span class="pre">bind_bc</span></code> which has the following signature:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">unspecified_type</span> <span class="n">x</span> <span class="o">=</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">boundary_class</span><span class="p">,</span> <span class="n">data_stores</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>The number of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> is dictated by the <code class="docutils literal notranslate"><span class="pre">boundary_class::operator()</span></code>, that is user defined (or provided by <cite>GridTools</cite>).</p>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> specified in the function call will be passed to the <code class="docutils literal notranslate"><span class="pre">boundary_class</span></code> and also used in <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operations.</p>
<p>However, some data fields used in boundary conditions may be read-only and should not be passed to the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operation, both for avoiding unnecessary operations and to limit the amount of memory used by the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update layer. For this reason the <code class="docutils literal notranslate"><span class="pre">data_store``s</span> <span class="pre">passed</span> <span class="pre">the</span> <span class="pre">the</span> <span class="pre">``bind_bc</span></code> can actually be <code class="docutils literal notranslate"><span class="pre">std::placeholders</span></code>. Only the actual <code class="docutils literal notranslate"><span class="pre">data_store``s</span> <span class="pre">specified</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``binc_bc</span></code> call will be passed to the communication layer. To bind the <code class="docutils literal notranslate"><span class="pre">placeholders</span></code> to actual <code class="docutils literal notranslate"><span class="pre">data_store``s</span> <span class="pre">the</span> <span class="pre">user</span> <span class="pre">must</span> <span class="pre">bind</span> <span class="pre">then</span> <span class="pre">using</span> <span class="pre">``.associate(data_stores...)</span></code> with the same mechanism used in <code class="docutils literal notranslate"><span class="pre">std::bind</span></code> as in the following example, in which <code class="docutils literal notranslate"><span class="pre">data_store</span></code> <code class="docutils literal notranslate"><span class="pre">c</span></code> is associated to placeholder <code class="docutils literal notranslate"><span class="pre">_1</span></code>.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="distributed-boundaries">
<h3>Distributed Boundaries<a class="headerlink" href="#distributed-boundaries" title="Permalink to this headline">¶</a></h3>
<p>The distributed boundaries class takes as template argument the communication traits. In the next example we use the communication traits class provided by <cite>GridTools</cite>, and <code class="docutils literal notranslate"><span class="pre">communication_arch</span></code> is one of the <a class="reference internal" href="../glossary/glossary.html#term-gcl"><span class="xref std std-term">GCL</span></a> specifiers of where the data accessed by a <a class="reference internal" href="../glossary/glossary.html#term-halo-exchange"><span class="xref std std-term">Halo Exchange</span></a> object reside.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">dbs_t</span> <span class="o">=</span> <span class="n">distributed_boundaries</span><span class="o">&lt;</span><span class="n">comm_traits</span><span class="o">&lt;</span><span class="n">storage_type</span><span class="p">,</span> <span class="n">communication_arch</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>During construction more information is required about the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> structure. We use here the usual <a class="reference internal" href="../glossary/glossary.html#term-halo-descriptor"><span class="xref std std-term">Halo Descriptor</span></a>.</p>
<p>The user needs also to indicate which dimensions are periodic (refer to <a class="reference internal" href="#gcl-communication-module"><span class="std std-ref">GCL Communication Module</span></a> for more information), and this is dome using another <cite>GridTools</cite> facility which is the <code class="docutils literal notranslate"><span class="pre">boollist</span></code>. Finally, to let the library compute the right amount of memory to allocate before hand, the maximum number of fields to be exchanged in one call have to be specified. The code showing an example of how to do it follows:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="k">halo_descriptor</span> <span class="n">di</span><span class="p">{</span><span class="n">halo_sx0</span><span class="p">,</span> <span class="n">halo_dx0</span><span class="p">,</span> <span class="n">begin0</span><span class="p">,</span> <span class="n">end0</span><span class="p">,</span> <span class="n">len0</span><span class="p">};</span>
<span class="k">halo_descriptor</span> <span class="n">dj</span><span class="p">{</span><span class="n">halo_sx1</span><span class="p">,</span> <span class="n">halo_dx1</span><span class="p">,</span> <span class="n">begin1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">len1</span><span class="p">};</span>
<span class="k">halo_descriptor</span> <span class="n">dk</span><span class="p">{</span><span class="n">halo_sx2</span><span class="p">,</span> <span class="n">halo_dx2</span><span class="p">,</span> <span class="n">begin2</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">len2</span><span class="p">};</span>
<span class="n">array</span><span class="o">&lt;</span><span class="k">halo_descriptor</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">halos</span><span class="p">{</span><span class="n">di</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">dk</span><span class="p">};</span>

<span class="n">boollist</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">periodicity</span><span class="p">{</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">};</span> <span class="c1">// b0, b1, b2 are booleans. If true it will indicate that the corresponding dimension is periodic across the grid of processors.</span>

<span class="kt">int</span> <span class="n">max_ds</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// maximum number of data stores to be used in a halo_update operation</span>

<span class="n">dbs_t</span> <span class="n">dbs</span><span class="p">{</span><span class="n">halos</span><span class="p">,</span> <span class="n">periodicity</span><span class="p">,</span> <span class="n">max_ds</span><span class="p">,</span> <span class="n">MPI_COMMUNICATOR</span><span class="p">};</span>
</pre></div>
</div>
<p>Above here the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> are the local <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> sizes, which are usually the tiles of a domain decomposed <cite>global domain</cite>, which has <cite>global boundaries</cite>. The idea is to apply the boundary conditions to the global boundaries while performing <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updates for the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> regions between sub-domains of the domain decomposed global domain.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">distributed_boundary</span></code> object allows the user to query the properties of the grid of processes, for instance the coordinates of the current process and the size of the computing grid..</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">,</span> <span class="n">pk</span><span class="p">;</span>
<span class="n">cabc</span><span class="p">.</span><span class="n">proc_grid</span><span class="p">().</span><span class="n">coords</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">,</span> <span class="n">pk</span><span class="p">);</span> <span class="c1">// Coordinates of current process</span>
<span class="kt">int</span> <span class="n">PI</span><span class="p">,</span> <span class="n">PJ</span><span class="p">,</span> <span class="n">PK</span><span class="p">;</span>
<span class="n">cabc</span><span class="p">.</span><span class="n">proc_grid</span><span class="p">().</span><span class="n">dims</span><span class="p">(</span><span class="n">PI</span><span class="p">,</span> <span class="n">PJ</span><span class="p">,</span> <span class="n">PK</span><span class="p">);</span> <span class="c1">// Sizes of the current grid of processes</span>
</pre></div>
</div>
<p>When invoking the boundary application and <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-update operations the user calls the <code class="docutils literal notranslate"><span class="pre">exchange</span></code> member of <code class="docutils literal notranslate"><span class="pre">distributed_boundaries</span></code>. The arguments of <code class="docutils literal notranslate"><span class="pre">exchange</span></code> are either <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> stores or <code class="docutils literal notranslate"><span class="pre">bind_bc</span></code> objects which associate a boundary condition to <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a>. The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> passed directly to the <code class="docutils literal notranslate"><span class="pre">exchange</span></code> methods have their <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updates according to the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> and periodicity information specified at <code class="docutils literal notranslate"><span class="pre">distributed_boundaries</span></code> object construction. The <code class="docutils literal notranslate"><span class="pre">bind_bc</span></code> arguments are treated differently.</p>
<p><code class="docutils literal notranslate"><span class="pre">bind_bc</span></code> accepts as first argument a boundary condition object and a list of fields that will be passed to it, for instance:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>This line will tell the distributed boundary object to apply copy boundary conditions and so copy the boundary of <code class="docutils literal notranslate"><span class="pre">b</span></code> in the boundary of <code class="docutils literal notranslate"><span class="pre">a</span></code>, according to the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> and periodicity specification. The boundaries that are not at the global boundary, though, will undergo <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>-updates through the communication module.</p>
<p>In the copy boundary, though, the second argument <code class="docutils literal notranslate"><span class="pre">b</span></code> is read-only, and most likely you would not need to update its <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>. <code class="docutils literal notranslate"><span class="pre">distributed_boundaries</span></code> allows to explicitly skip some fields from being updated by using <code class="docutils literal notranslate"><span class="pre">std::placeholders</span></code> and the <code class="docutils literal notranslate"><span class="pre">associate</span></code> member function, as follow:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">a</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the field <code class="docutils literal notranslate"><span class="pre">b</span></code> will not be passed to the communication module, but it will only be used by the <code class="docutils literal notranslate"><span class="pre">copy_boundary</span></code> object.</p>
<p>The next example, shows two boundary applications using a fixed value on <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal notranslate"><span class="pre">a</span></code> and a <code class="docutils literal notranslate"><span class="pre">copy_boundary</span></code> to copy the value of <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal notranslate"><span class="pre">c</span></code> into <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Store</span></a> <code class="docutils literal notranslate"><span class="pre">b</span></code> (refer to <a class="reference internal" href="#gcl-communication-module"><span class="std std-ref">GCL Communication Module</span></a>). Data store <code class="docutils literal notranslate"><span class="pre">c</span></code> will not be used in <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> update operation, but only as source of data for the <code class="docutils literal notranslate"><span class="pre">copy_boundary</span></code>. Three fields will have their <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updated by the next example, namely <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code>:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">cabc</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">bind_bc</span><span class="p">(</span><span class="n">value_boundary</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">3.14</span><span class="p">},</span> <span class="n">a</span><span class="p">),</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
<p>An additional facility provided is an alternative to the <code class="docutils literal notranslate"><span class="pre">exchange</span></code> method. This is used to skip the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> updates altogether, and it is called <code class="docutils literal notranslate"><span class="pre">boundary_only</span></code>, and the code to use it is identical to the previous example, barring the function name:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">cabc</span><span class="p">.</span><span class="n">boundary_only</span><span class="p">(</span><span class="n">bind_bc</span><span class="p">(</span><span class="n">value_boundary</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="mf">3.14</span><span class="p">},</span> <span class="n">a</span><span class="p">),</span> <span class="n">bind_bc</span><span class="p">(</span><span class="n">copy_boundary</span><span class="p">{},</span> <span class="n">b</span><span class="p">,</span> <span class="n">_1</span><span class="p">).</span><span class="n">associate</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="data-management">
<h2>Data Management<a class="headerlink" href="#data-management" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="interfacing-to-other-programming-languages">
<h2>Interfacing to Other Programming Languages<a class="headerlink" href="#interfacing-to-other-programming-languages" title="Permalink to this headline">¶</a></h2>
<p><cite>GridTools</cite> provides an easy macro interface to generate bindings to C and Fortran.</p>
<p>Suppose, the user wants to export the function <code class="docutils literal notranslate"><span class="pre">add_impl</span></code>.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add_impl</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The macros <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_*</span></code> provide ways to generate bindings to functions. The different
flavours of this macro are explained below. The macro generates a wrapper around the function
<code class="docutils literal notranslate"><span class="pre">add_impl</span></code> which is called <code class="docutils literal notranslate"><span class="pre">add</span></code> and registers the function to be exported.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/c_bindings/export.hpp&gt;</span><span class="cp"></span>
<span class="n">GT_EXPORT_BINDING_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The user can generate a C header and a Fortran module that matches this header by
adding a call to <code class="docutils literal notranslate"><span class="pre">gt_add_bindings_library</span></code> in his CMake project:</p>
<div class="highlight-CMake notranslate"><div class="highlight"><pre><span></span><span class="nb">find_package</span><span class="p">(</span><span class="s">GridTools</span> <span class="s">REQUIRED</span><span class="p">)</span>
<span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_MODULE_PATH</span> <span class="s2">&quot;${GridTools_MODULE_PATH}&quot;</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">gt_bindings</span><span class="p">)</span>
<span class="nb">gt_add_bindings_library</span><span class="p">(</span><span class="s">add_lib</span> <span class="s">SOURCES</span> <span class="s">add.cpp</span><span class="p">)</span>
</pre></div>
</div>
<p>This will generate a library <code class="docutils literal notranslate"><span class="pre">add_lib</span></code> which contains the exported symbol <code class="docutils literal notranslate"><span class="pre">add</span></code>,
and it will generate a target <code class="docutils literal notranslate"><span class="pre">add_lib_declarations</span></code> that generates the files
<code class="docutils literal notranslate"><span class="pre">add_lib.h</span></code> and <code class="docutils literal notranslate"><span class="pre">add_lib.f90</span></code> containing the bindings that can be used from C
and Fortran.</p>
<p>The C header contains the exported function (boilerplate code removed):</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>The generated Fortran module contains the corresponding declaration:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">add_lib</span>
<span class="k">implicit none</span>
<span class="k">  interface</span>
<span class="k">    </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="k">function </span><span class="n">add</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
      <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
    <span class="k">end function</span>
<span class="k">  end interface</span>
<span class="k">end</span>
</pre></div>
</div>
<div class="section" id="exporting-functions-with-no-array-type-arguments">
<h3>Exporting functions with no array-type arguments<a class="headerlink" href="#exporting-functions-with-no-array-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>There exist various flavours of these macros. Functions which are non-templated or fully-specialized
can be exported with <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING</span></code>, for example:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add_impl</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="n">GT_EXPORT_BINDING_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">add_impl</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
<span class="n">GT_EXPORT_BINDING</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">add_impl</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>All functions exist in two flavours: Either you can pass the number of arguments as part of the name
of the macro (<code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_2</span></code> stands for two arguments), or you can pass it as a first argument
to the generic <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING</span></code>. The first flavours exist for up to 9 arguments.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_X</span></code> requires a name and a function pointer as its arguments.
A lambda cannot be passed as function pointer; thus, the type of the arguments cannot be
deduced. In such cases, the functions can be exported with <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_WITH_SIGNATURE_X</span></code>,
which additionally takes the function type as an argument:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">GT_EXPORT_BINDING_WITH_SIGNATURE_2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>Templated functions can be exported for a given set of specializations using
<code class="docutils literal notranslate"><span class="pre">GT_EXPORT_GENERIC_BINDING_X</span></code>. In addition to the function name and the function pointer, it takes a list of
overloads for which the bindings are generated:</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">GT_EXPORT_GENERIC_BINDING</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add_impl</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
</pre></div>
</div>
<p>In the generated Fortran module, generic bindings will produce an interface combining the different
overloads:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="k">function </span><span class="n">add_f0</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">    </span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
  <span class="k">end function</span>
<span class="k">  </span><span class="kt">real</span><span class="p">(</span><span class="kt">c_double</span><span class="p">)</span> <span class="k">function </span><span class="n">add_f1</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">    </span><span class="kt">real</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">arg1</span>
  <span class="k">end function</span>
<span class="k">end interface</span>
<span class="k">interface </span><span class="n">add</span>
  <span class="k">procedure </span><span class="n">add_f0</span><span class="p">,</span> <span class="n">add_f1</span>
<span class="k">end interface</span>
</pre></div>
</div>
</div>
<div class="section" id="complex-types">
<h3>Complex types<a class="headerlink" href="#complex-types" title="Permalink to this headline">¶</a></h3>
<p>Only a limited set of types can be passed from Fortran / C through the C bindings interface to C++,
namely integral and floating point types, booleans and pointers to those types.</p>
<p>Array references, <cite>GridTools</cite> storages, and any type that is <cite>fortran_array_bindable</cite>
appear as <code class="docutils literal notranslate"><span class="pre">gt_fortran_array_descriptor</span></code> in the C bindings. This structure allows
the user to describe the data that needs to be passed to C++.</p>
<p>It is possible to write bindings to functions that accept or return other types.
During the generation process, they are replaced with pointers to the type <code class="docutils literal notranslate"><span class="pre">gt_handle</span></code>.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">make_vector_impl</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">use_vector_impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">GT_EXPORT_BINDING_0</span><span class="p">(</span><span class="n">make_vector</span><span class="p">,</span> <span class="n">make_vector_impl</span><span class="p">);</span>
<span class="n">GT_EXPORT_BINDING_1</span><span class="p">(</span><span class="n">use_vector</span><span class="p">,</span> <span class="n">use_vector_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The code above will generate the following signatures in the C-header:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">gt_handle</span><span class="o">*</span> <span class="nf">make_vector</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">use_vector</span><span class="p">(</span><span class="n">gt_handle</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The user needs to make sure that the types that stand behind <code class="docutils literal notranslate"><span class="pre">gt_handle</span></code> match, otherwise
an exception will be thrown.</p>
</div>
<div class="section" id="exporting-functions-with-array-type-arguments-to-fortran">
<h3>Exporting functions with array-type arguments to Fortran<a class="headerlink" href="#exporting-functions-with-array-type-arguments-to-fortran" title="Permalink to this headline">¶</a></h3>
<p>Special macros exist to export function that take array-like arguments to Fortran. While the normal
macros export such arguments as <code class="docutils literal notranslate"><span class="pre">gt_fortran_array_descriptor</span></code>, the “wrapped” macros create
additional wrappers around the functions that fill the structures themselves.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dummy_impl</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="p">{}</span>
<span class="n">GT_EXPORT_BINDING_WRAPPED_1</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">dummy_impl</span><span class="p">);</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">dummy_impl</span></code> is taking a reference to an array. When exporting this function with
<code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_WRAPPED_X</span></code>, an additional wrapper is generated in the Fortran bindings:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">add_lib</span>
<span class="k">implicit none</span>
<span class="k">  interface</span>
<span class="k">    subroutine </span><span class="n">dummy_impl</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dummy&quot;</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="k">use </span><span class="n">array_descriptor</span>
      <span class="k">type</span><span class="p">(</span><span class="n">gt_fortran_array_descriptor</span><span class="p">)</span> <span class="kd">::</span> <span class="n">arg0</span>
    <span class="k">end subroutine</span>
<span class="k">  end interface</span>
<span class="k">contains</span>
<span class="k">    subroutine </span><span class="n">dummy</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span>
      <span class="k">use </span><span class="nb">iso_c_binding</span>
<span class="nb">      </span><span class="k">use </span><span class="n">array_descriptor</span>
      <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">dimension</span><span class="p">(:,:),</span> <span class="k">target</span> <span class="kd">::</span> <span class="n">arg0</span>
      <span class="k">type</span><span class="p">(</span><span class="n">gt_fortran_array_descriptor</span><span class="p">)</span> <span class="kd">::</span> <span class="n">descriptor0</span>

      <span class="n">descriptor0</span><span class="p">%</span><span class="n">rank</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="k">type</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="nb">shape</span><span class="p">(</span><span class="n">arg0</span><span class="p">),</span> <span class="p">&amp;</span>
        <span class="nb">shape</span><span class="p">(</span><span class="n">descriptor0</span><span class="p">%</span><span class="n">dims</span><span class="p">),</span> <span class="p">(</span><span class="o">/</span><span class="mi">0</span><span class="o">/</span><span class="p">))</span>
      <span class="n">descriptor0</span><span class="p">%</span><span class="k">data</span> <span class="o">=</span> <span class="nb">c_loc</span><span class="p">(</span><span class="n">arg0</span><span class="p">(</span><span class="nb">lbound</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">lbound</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

      <span class="k">call </span><span class="n">dummy_impl</span><span class="p">(</span><span class="n">descriptor0</span><span class="p">)</span>
    <span class="k">end subroutine</span>
<span class="k">end</span>
</pre></div>
</div>
<p>This allows to call the Fortran function <code class="docutils literal notranslate"><span class="pre">dummy</span></code> in a convenient way:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span> <span class="k">dimension</span><span class="p">(:,</span> <span class="p">:)</span> <span class="kd">::</span> <span class="n">some_array</span>
<span class="k">call </span><span class="n">dummy</span><span class="p">(</span><span class="n">some_array</span><span class="p">)</span>
</pre></div>
</div>
<p>The bindings will take care that the rank matches and it will infer the size of the array automatically.</p>
<p>All additional macros behave as mentioned above, namely <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_WITH_SIGNATURE_WRAPPED</span></code>,
and <code class="docutils literal notranslate"><span class="pre">GT_EXPORT_BINDING_GENERIC_WRAPPED</span></code>.</p>
<p>Data types need to be <cite>fortran_array_wrappable</cite> in order to be compatible with these macros. Natively, only
C arrays and <code class="docutils literal notranslate"><span class="pre">fortran_array_adapter</span></code> are <cite>fortran_array_wrappable</cite>. The latter is an adapter between
Fortran arrays and <cite>GridTools</cite> storages, such that the user can pass a Fortran array to a C++ function,
which then can be transformed into a <cite>GridTools</cite> storage.</p>
<div class="highlight-gridtools notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/interface/fortran_array_adapter.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="n">storage_info</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">layout_map</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">data_store</span><span class="o">&lt;</span><span class="n">host_storage</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">modify_array_impl</span><span class="p">(</span><span class="n">fortran_array_adapter</span><span class="o">&lt;</span><span class="n">data_store_t</span><span class="o">&gt;</span> <span class="n">inout</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data_store_t</span> <span class="n">data_store</span><span class="p">{</span><span class="n">storage_info_t</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">}};</span>
    <span class="n">transform</span><span class="p">(</span><span class="n">data_store</span><span class="p">,</span> <span class="n">inout</span><span class="p">);</span>

    <span class="c1">// use data_store</span>

    <span class="n">transform</span><span class="p">(</span><span class="n">inout</span><span class="p">,</span> <span class="n">data_store</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">GT_EXPORT_BINDING_WRAPPED_1</span><span class="p">(</span><span class="n">modify_array</span><span class="p">,</span> <span class="n">modify_array_impl</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="cmake-usage">
<h3>CMake usage<a class="headerlink" href="#cmake-usage" title="Permalink to this headline">¶</a></h3>
<p>A call to <code class="docutils literal notranslate"><span class="pre">gt_add_bindings_library</span></code> generates the libraries and the headers. By default,
the C header file and the Fortran file is written directly into the source tree. This choice was
taken to improve building in cross-build environments, because the process cannot rely
on generated binaries being executable on the host system. The output folder can be overwritten
by setting <code class="docutils literal notranslate"><span class="pre">FORTRAN_OUTPUT_DIR</span></code> and <code class="docutils literal notranslate"><span class="pre">C_OUTPUT_DIR</span></code>.</p>
<p>By default, the name of the generated Fortran module is set to the name of the library. A different
name can be set with <code class="docutils literal notranslate"><span class="pre">FORTRAN_MODULE_NAME</span></code>.</p>
</div>
</div>
<div class="section" id="benchmarking">
<h2>Benchmarking<a class="headerlink" href="#benchmarking" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../upcoming/upcoming.html" class="btn btn-neutral float-right" title="Upcoming Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../getting_started/getting_started.html" class="btn btn-neutral float-left" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ETH Zurich

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>