<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />

  <link rel="stylesheet" type="text/css" href="template.css" />

   <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />



<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script type='text/javascript' src='menu/js/jquery.cookie.js'></script>
<script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script>
<script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

<link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
<link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
<link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
  
  <script src="script.js"></script>
  
    <script src="jquery.sticky-kit.js "></script>
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc-bootstrap-adaptive-template/template.css" type="text/css" />
</head>
<body>

    
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#installation-and-configuration">Installation and Configuration</a></li>
        <li><a href="#sec:getting_started">Quick Start Guide</a><ul>
        <li><a href="#coordinate-system">Coordinate System</a></li>
        <li><a href="#storages">Storages</a></li>
        <li><a href="#backend">Backend</a></li>
        <li><a href="#memory-layout">Memory layout</a></li>
        <li><a href="#the-storage-type">The storage type</a></li>
        <li><a href="#storage-with-halo">Storage with halo</a></li>
        <li><a href="#stencils">Stencils</a></li>
        <li><a href="#example-naive-2d-laplacian">Example: Naive 2D Laplacian</a></li>
        <li><a href="#first-textitgridtoolsstencil">First <span class="math inline"><em>GridTools</em></span> stencil</a></li>
        <li><a href="#assembling-stencils-smoothing-filter">Assembling stencils: smoothing filter</a></li>
        <li><a href="#do-method-overload">Do-method overload</a></li>
        <li><a href="#textitgridtoolstemporaries"><span class="math inline"><em>GridTools</em></span> temporaries</a></li>
        <li><a href="#functor-calls">Functor calls</a></li>
        <li><a href="#mm">Full code listing</a></li>
        <li><a href="#how-to-pass-the-alpha-global-accessors">How to pass the <span class="math inline"><em>α</em></span>: Global accessors</a></li>
        <li><a href="#distributing-the-work-gcl">Distributing the work: GCL</a></li>
        <li><a href="#boundary-conditions">Boundary conditions</a></li>
        </ul></li>
        <li><a href="#storages-1">Storages</a><ul>
        <li><a href="#simple-use-and-multidimensional-fields">Simple use and multidimensional fields</a></li>
        <li><a href="#ghost-dimensions">Ghost dimensions</a></li>
        <li><a href="#fields">Fields</a></li>
        <li><a href="#gpu-storages">GPU storages</a></li>
        <li><a href="#detailed-storage-configuration">Detailed storage configuration</a></li>
        </ul></li>
        <li><a href="#dsl-introduction">DSL introduction</a><ul>
        <li><a href="#syntax-for-user-operators">Syntax for User Operators</a></li>
        <li><a href="#parallelization-model-stages-and-multistages">Parallelization Model: Stages and MultiStages</a></li>
        <li><a href="#preparing-arguments-storage-placeholders">Preparing arguments: storage placeholders</a></li>
        <li><a href="#vertical-regions-and-vertical-boundary-conditions">Vertical regions and vertical boundary conditions</a></li>
        <li><a href="#use-of-temporaries">Use of temporaries</a></li>
        <li><a href="#composing-stencils">Composing Stencils</a></li>
        <li><a href="#irregular-grids-syntax">Irregular Grids Syntax</a></li>
        </ul></li>
        <li><a href="#stencil-functions">Stencil Functions</a></li>
        <li><a href="#conditional-stencils">Conditional Stencils</a></li>
        <li><a href="#reductions">Reductions</a></li>
        <li><a href="#details-for-performance">Details for performance</a><ul>
        <li><a href="#fusion-and-organization-of-stages">Fusion and organization of stages</a></li>
        <li><a href="#software-managed-caches">Software Managed Caches</a></li>
        <li><a href="#alignment-halo-of-storages">Alignment: halo of storages</a></li>
        <li><a href="#expandable-parameters">Expandable parameters</a></li>
        </ul></li>
        <li><a href="#halo-updates">Halo Updates</a><ul>
        <li><a href="#boundary-conditions-1">Boundary Conditions</a></li>
        <li><a href="#halo-exchanges">Halo Exchanges</a></li>
        </ul></li>
        <li><a href="#data-management">Data management</a></li>
        <li><a href="#interfacing-to-other-programming-languages">Interfacing to other programming languages</a></li>
        <li><a href="#benchmarking-stencils">Benchmarking stencils</a></li>
        <li><a href="#serialbox-and-porting-your-reference-application">SerialBox and porting your reference application</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <link rel="stylesheet" href="highlight.js/color-brewer.min.css">
<script src="highlight.js/highlight.min.js"></script>
<script src="highlight.js/jquery-2.1.3.min.js"></script>
<script src="highlight.js/cpp_gt.js"></script>
<script>
$(function() {
    $("pre > code").each(function(i, block) {
        var codeClass = $(this).parent().attr("class");
        if (codeClass == null || codeClass === "") {
            $(this).addClass("hljs");
        } else {
            var map = {
                js: "javascript"
            };
            if (map[codeClass]) {
                codeClass = map[codeClass];
            }
            $(this).addClass(codeClass);
            hljs.highlightBlock(this);
        }
    });
});
</script>
<h1 id="installation-and-configuration">Installation and Configuration</h1>
<h1 id="sec:getting_started">Quick Start Guide</h1>
<p>This chapter describes how to use <span class="math inline"><em>GridTools</em></span> to solve a (simple) PDE. We will use the fourth-order horizontal smoothing filter example from with small modifications to explain the necessary steps to assemble a stencil from scratch. We will not go into details in this chapter but refer to latter chapters for more details.</p>
<p>Our example PDE is given by <br /><span class="math display">$$\label{eq:getting_started:examplepde}
\frac{\partial \phi}{\partial t} =\begin{cases}
- \alpha \nabla^4 \phi &amp; z \leq z_\text{max}\\
0 &amp; z &gt; z_0
\end{cases}$$</span><br /> where <span class="math inline">∇<sup>4</sup></span> is the squared two dimensional horizontal Laplacian and we apply the filter only up to some maximal <span class="math inline"><em>z</em><sub>0</sub></span> (to make the example more interesting). The filter is calculated in two steps: first we calculate the Laplacian of <span class="math inline"><em>ϕ</em></span></p>
<p><br /><span class="math display">$$L = \Delta \phi = \left( \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right) \phi$$</span><br /></p>
<p>then we calculate the Laplacian of <span class="math inline"><em>L</em></span></p>
<p><br /><span class="math display">−<em>α</em>∇<sup>4</sup><em>ϕ</em> = −<em>α</em><em>Δ</em><em>L</em></span><br /></p>
<p>In the following we will walk through the following steps:</p>
<ul>
<li><p>The <span class="math inline"><em>GridTools</em></span> coordinate system and its notation.</p></li>
<li><p>Storages: how does <span class="math inline"><em>GridTools</em></span> manage the input and output fields.</p></li>
<li><p>The first stencil: calculating <span class="math inline"><em>L</em></span>, the second order Laplacian of <span class="math inline"><em>ϕ</em></span>.</p></li>
<li><p>The final stencil: function calls, Do-method overloads and temporaries</p></li>
<li><p>MISSING: How to pass the <span class="math inline"><em>α</em></span>: Global accessors</p></li>
<li><p>MISSING: Distributing the work over multiple nodes: GCL</p></li>
<li><p>MISSING: Boundaries</p></li>
</ul>
<h2 id="coordinate-system">Coordinate System</h2>
<p>For a finite difference discretization we restrict the field <span class="math inline"><em>ϕ</em> ∈ ℝ<sup>3</sup></span> to a discrete grid. We use the notation <span class="math inline"><em>i</em> = <em>x</em><sub><em>i</em></sub></span> and <span class="math inline"><em>j</em> = <em>y</em><sub><em>j</em></sub></span> for the horizontal dimension and <span class="math inline"><em>k</em> = <em>z</em><sub><em>k</em></sub></span> for the vertical dimension, where <span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub></span> are the <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span> coordinates restricted on the grid. The <em>computation domain</em> is defined by all grid points in our domain of interest <br /><span class="math display"><em>Λ</em> = (<em>i</em>, <em>j</em>, <em>k</em>) with <em>i</em> ∈ {0…<em>N</em><sub><em>i</em></sub> − 1},<em>j</em> ∈ {0…<em>N</em><sub><em>j</em></sub> − 1},<em>k</em> ∈ {0…<em>N</em><sub><em>k</em></sub> − 1}</span><br /></p>
<p><span class="math inline"><em>GridTools</em></span> supports any number of dimension, however it will treat one dimension, here the <span class="math inline"><em>k</em></span>, dimension differently: the <span class="math inline"><em>i</em><em>j</em></span>-plane is executed in parallel while the computation in <span class="math inline"><em>k</em></span> can be sequential. The consequence is that there must not be a dependency in <span class="math inline"><em>i</em><em>j</em></span> within a stencil while there can be a dependency in <span class="math inline"><em>k</em></span>. For now (this chapter) it is sufficient to just remember that the <span class="math inline"><em>i</em><em>j</em></span>-plane and the <span class="math inline"><em>k</em></span> dimension are treated differently by <span class="math inline"><em>GridTools</em></span>.</p>
<p>The calculation domain is surrounded by a <em>boundary region</em> as depicted in <span>Fig. [fig:getting_started:coordinates]</span>. Computation happens only within the calculation domain but values might be read from grid points in the boundary region.</p>
<div class="figure">
<img src="figures/coordinates.png" alt="Coordinates system" />
<p class="caption">Coordinates system</p>
</div>
<h2 id="storages">Storages</h2>
<p>In this section we will setup the fields for our example: we need a storage for the <span class="math inline"><em>ϕ</em></span>-field (<code>phi_in</code>) and a storage for the output (<code>phi_out</code>).</p>
<p>Storages in <span class="math inline"><em>GridTools</em></span> are n-dimensional array-like objects with the following capabilities:</p>
<ul>
<li><p>access an element with <span class="math inline">(<em>i</em>, <em>j</em>, <em>k</em>)</span> syntax</p></li>
<li><p>copying between CPU memory and a device (e.g. a CUDA capable GPU)</p></li>
</ul>
<h2 id="backend">Backend</h2>
<p>Since the storages (and other things later) depend on the architecture (CPU or GPU) our first step is to define a <em>backend</em> type which typically looks like</p>
<pre class="cpp"><code>using backend_t = backend&lt; Cuda, structured, Block &gt;;</code></pre>
<p>for the CUDA backed or for the CPU backend. The second argument defines the type of the grid, where <code>phi_in</code> refers to a Cartesian grid, see [Chapter [sec:grids]] for details. The last argument defines that blocking should be used in CPU mode (instead of <code>phi_out</code> without blocking). For the CUDA mode <span>``</span> is the only option.</p>
<h2 id="memory-layout">Memory layout</h2>
<p>For efficient memory access the index ordering has to be different for CPUs (<span class="math inline"><em>k</em></span> first) and GPUs (<span class="math inline"><em>i</em></span> first). This is defined with the <span>``</span>. For CUDA we use while we use on the host. We don’t go into more detail here, since this should probably be constructed by the backend (at least for standard use-cases). For now it is enough to know that the first line should be used in GPU mode and the second in CPU mode.</p>
<h2 id="the-storage-type">The storage type</h2>
<p>For each storage type we need to define the type of the data we want to store in the field, e.g. <code>double</code>, and a <code>storage_info</code> type which will hold information about size, alignment, strides etc. The <code>storage_info</code> needs a unique index and a <code>layout_map</code> as defined before. These information are all C++ types, i.e. known at compile-time.</p>
<pre class="cpp"><code>using storage_info_t = backend_t::storage_info&lt; 0, layout_t &gt;;
using storage_t = backend_t::storage_type&lt; double, storage_info_t &gt;::type;</code></pre>
<p>At run-time a <code>storage_info</code> is initialized with the sizes of the field. Then a field can be instantiated with the <code>info</code> object.</p>
<pre class="cpp numberLines"><code>uint_t Ni = 10;
uint_t Nj = 12;
uint_t Nk = 20;

storage_info_t info(Ni, Nj, Nk);

storage_t phi(info, -1., &quot;phi&quot;);
storage_t lap(info, -1., &quot;lap&quot;);</code></pre>
<p>The first argument, the <code>meta</code> object, is mandatory, while the other arguments are optional: a name for the field and an initial value.</p>
<hr />
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>For each <code>meta_storage</code> type you should use only one</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>instantiation. The mapping between a storage and the</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>run-time information in the <code>meta_storage</code> has to be</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>done at compile time via the index. Thus <span class="math inline"><em>GridTools</em></span> cannot</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>distinguish the storages by the run-time sizes passed</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>to the <code>meta_storage</code>.</td>
</tr>
</tbody>
</table>
<hr />
<p>We can now</p>
<ul>
<li><p>retrieve the name of the field,</p></li>
<li><p>read and write values in the field using the parenthesis syntax,</p></li>
<li><p>copy the data to device or back to host (in Cuda mode)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p></li>
</ul>
<h2 id="storage-with-halo">Storage with halo</h2>
<p>It is usually beneficial to align the storage to the location of the first element of the calculation domain. Therefore it is possible to tell the storage about the halo region. Since this will probably change in the new storage design we will leave the documentation of this advanced feature for later.</p>
<h2 id="stencils">Stencils</h2>
<p>A <em>stencil</em> is a kernel that updates array elements according to a fixed access pattern.</p>
<h2 id="example-naive-2d-laplacian">Example: Naive 2D Laplacian</h2>
<p>The simplest discretization of the 2D Laplacian is the finite difference five-point stencil as depicted in <span>Fig. [fig:getting_started:laplacian2D]</span>. For the calculation of the Laplacian at a given grid point we need the value at the grid point itself and its four direct neighbors along the Cartesian axis.</p>
<div class="figure">
<img src="figures/Laplacian2D.png" alt="Access pattern of a 2D Laplacian" />
<p class="caption">Access pattern of a 2D Laplacian</p>
</div>
<p>A naive C++ implementation of the 2D Laplacian stencil is provided in <span>Listing [code:getting_started:cxx_laplacian]</span>.</p>
<p>Apart from the initialization (orange) the stencil implementation consists of 2 main components:</p>
<ul>
<li><p>Loop-logic (green): defines the stencil application domain and loop order</p></li>
<li><p>Update-logic (blue): defines the update formula (here: the 2D Laplacian)</p></li>
</ul>
<p>Special care has to be taken at the boundary of the domain. Since the Laplacian needs the neighboring points we cannot calculate the Laplacian on the boundary layer and have to exclude them from the loop.</p>
<h2 id="first-textitgridtoolsstencil">First <span class="math inline"><em>GridTools</em></span> stencil</h2>
<p>In <span class="math inline"><em>GridTools</em></span> the loop logic and the storage order is implemented (and optimized) by the library while the update function is implemented by the user. The loop logic (for a given architecture) is combined with the user-defined update function at compile-time by template meta-programming (see <span>Sec. [sec:introduction:template_meta_programming]</span>).</p>
<h3 id="update-logic-textitgridtools2d-laplacian">Update-logic: <span class="math inline"><em>GridTools</em></span> 2D Laplacian</h3>
<p>The update-logic is implemented with state-less functors. A <span class="math inline"><em>GridTools</em></span> functor is a <span><code>]{} or [</code></span> providing a <em>static</em> method called <span><code>]{}. The update-logic is implemented in these [</code></span>-methods. As the functors are state-less (no member variables, static methods only) they can be passed by type, i.e. at compile-time, and therefore allow for compile-time optimizations.</p>
<p>In addition to the <span><code>]{}-method, the functor contains [</code></span>s. These two <span><code>]{}s are parameters of the functor, i.e. they are mapped to fields passed to the functor. They contain compile-time information if they are only used as input parameters, like the [</code></span> accessor in the example, or if we want to write into the associated field. Additionally, the <span>``</span> defines which grid-points are needed by the stencil relative to the current point. The format for the extent is</p>
<p>extent<i_minus, i_plus, j_minus, j_plus, k_minus, k_plus></p>
<p>where <span><code>]{} and [</code></span> define an interval on the <span class="math inline"><em>i</em></span>-axis relative to the current position; <span><code>]{} is the negative offset, i.e. zero or a negative number, while [</code></span> is the positive offset. Analogously for <span class="math inline"><em>j</em></span> and <span class="math inline"><em>k</em></span>. In the Laplacian example, <span>Listing [code:getting_started_gtlaplacian]</span>, the first two number in the extent of the <span>``</span> accessor define that we want to access the field at <span class="math inline"><em>i</em> − 1, <em>i</em>, <em>i</em> + 1</span>. The accessor type and the extent is needed for a dependency analysis in the compile-time optimizations for more complex stencils.</p>
<p>The first template argument is an index defining the order of the parameters, i.e. the order in which the fields are passed to the functor. The <span><code>]{} has to defined and stores all accessors in an [</code></span>.</p>
<p>A <span><code>]{} method needs to have two parameters. The first one is a context object [</code></span> that is created and passed to the method by the library on invocation. This object contains, among other things, the index of the active grid point and the mapping of data-pointers to the <span><code>]{}s. The second argument is an interval on the $k$-axis where this implementation should be executed. This allows to apply a different update-logic on intervals by overloading the [</code></span>-method. We will define this interval later.</p>
<p>The body of the <span><code>]{}-method looks quite similar to the one in the naive implementation [Listing \[code:getting\_started:cxx\_laplacian\]]{}, except that each field access has to be wrapped by a call to the context object [</code></span>. This is necessary to map the compile-time parameter, the accessor, to the field, a run-time object.</p>
<h3 id="calling-the-stencil">Calling the stencil</h3>
<p>In the naive implementation, <span>Listing [code:getting_started:cxx_laplacian]</span>, the call to the <span>``</span> is as simple as</p>
<p>int boundary_size = 1; laplacian( lap, phi, boundary_size );</p>
<p>since it contains already all the information: the update-logic <em>and</em> the loop-logic.</p>
<p>The <span class="math inline"><em>GridTools</em></span> stencil, <span>Listing [code:getting_started_gtlaplacian]</span>, does not contain the information about the loop-logic. We have to specify it in an abstract platform-independent syntax, a <em>domain specific embedded language</em> (DSEL), such that the backend can decide on the specific implementation.</p>
<p>For our example it looks as in <span>Listing [code:getting_started:gtlaplacian:make_computation]</span>.</p>
<p>In line [gt_laplacian_setup:arg_phi] and [gt_laplacian_setup:arg_lap] we define placeholders for the fields. In the lines [gt_laplacian_setup:domain:start]-[gt_laplacian_setup:domain:end] the fields, i.e. the storages, are attached to these placeholders in the <span>``</span>.</p>
<p>In lines [gt_laplacian_setup:grid:start] to [gt_laplacian_setup:grid:end] we setup the physical dimension of the problem. First we define which points on the <span class="math inline"><em>i</em></span> and the <span class="math inline"><em>j</em></span>-axis belong to the computational domain and which points belong to the boundary (or a padding region). For now it is enough to know that these lines define an axis with a boundary of size 1 surrounding the <span class="math inline"><em>i</em><em>j</em></span>-plane. In the next lines the layers in <span class="math inline"><em>k</em></span> are defined. In this case we have only one interval. We will discuss the details later.</p>
<p>In lines [gt_laplacian_setup:computation:start] to [gt_laplacian_setup:computation:end] we create the stencil object. We pass the domain (the mapping between placeholders and storages), the grid (the information about the loop bounds) and a <span><code>]{}. The [</code></span> contains a <span>``</span>, our Laplacian functor.</p>
<p>In more complex codes we can combine multiple <span class="math inline"><em>k</em></span>-independent stages in a <span><code>]{}. If we have a $k$-dependency we have to split the computation in multiple [</code></span>s.</p>
<p>The statement <span><code>]{} defines that we want to iterate over $k$ in a forward manner, i.e. starting from the smallest $k$-value to the largest. Other options are [</code></span> and <span><code>]{}[^2]. For performance reason one should use [</code></span> whenever possible.</p>
<p>The next lines [gt_laplacian_setup:ready] and [gt_laplacian_setup:steady] are mandatory: we allocate temporary storages (in our case we don’t use any) and copy the fields to the device (if we use the CUDA backend).</p>
<p>Line [gt_laplacian_setup:run] is self-explanatory: the stencil is executed.</p>
<p>In the last line we free temporary storages and copy modified fields back to the host.</p>
<p>In a more realistic application the <span><code>]{} will be called multiple times. If one wants to inspect the fields between runs (and before the [</code></span>) one has to manually copy the data back from device.</p>
<h3 id="full-textitgridtoolslaplacian">Full <span class="math inline"><em>GridTools</em></span> Laplacian</h3>
<h2 id="assembling-stencils-smoothing-filter">Assembling stencils: smoothing filter</h2>
<p>In the preceding section we saw how a first simple <span class="math inline"><em>GridTools</em></span> stencil is defined and executed. In this section we will use this stencil to compute the example PDE . A naive implementation could look as in <span>Listing [code:getting_started:naive_smoothing]</span>.</p>
<p>For the <span class="math inline"><em>GridTools</em></span> implementation we will learn three things in this section: how to define special regions in the <span class="math inline"><em>k</em></span>-direction; how to use <span class="math inline"><em>GridTools</em></span> temporaries and how to call functors from functors.</p>
<h2 id="do-method-overload">Do-method overload</h2>
<p>Our first <span class="math inline"><em>GridTools</em></span> implementation will be very close to the naive implementation: we will call two times the Laplacian functor from the previous section and store the result in two extra fields. Then we will call a third functor to compute the final result. This functor, see <span>Listing [code:getting_started:gt_smoothing_version1]</span> shows how we can specialize the computation in the <span class="math inline"><em>k</em></span>-direction. We define two intervals, the <span><code>]{} and the [</code></span>, and provide an overload of the <span>``</span>-method for each interval.</p>
<p>The intervals are defined as</p>
<p>Since we are working currently on a nicer API to define the intervals we don’t want to describe the (non-trivial) details now. In short: the first entry in the level is a so-called <span><code>]{}, an abstraction to tell that we want to split the axis here. The second entry is an offset relative to the splitter. At runtime we assign an index of the k-axis to the splitters. Then the [</code></span> corresponds to the index in the <span><code>]{} entry. Additionally we have to define an [</code></span> such that all intervals are a strict subset of the <span>``</span>.</p>
<p>Finally, the call to <span>``</span> looks as follows<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>In this version we needed to explicitly allocate the temporary fields <span><code>]{} and [</code></span>. In the next section we will learn about <span class="math inline"><em>GridTools</em></span> temporaries.</p>
<h2 id="textitgridtoolstemporaries"><span class="math inline"><em>GridTools</em></span> temporaries</h2>
<p><em><span class="math inline"><em>GridTools</em></span> temporary storages</em> are storages with the lifetime of the <span><code>]{}, i.e. they can be used by different stages assembled in one [</code></span> call. This is exactly what we need for the <span><code>]{} and [</code></span> fields.</p>
<p>Note that we did not allocate the temporaries explicitly and we cannot access them from outside of the computation. Therefore it might be necessary sometimes to replace a temporary with a normal storage for debugging.</p>
<p>To use temporary storages we don’t need to change the functors or the <span><code>]{}. We just have to replace the type of the *arg* from a normal storage type to a temporary storage type. We don’t need the explicit instantiations any more and we can leave out pointers to storages when we build the domain. The new code looks as follows The temporary storages are allocated in the [</code></span> call and freed in <span>``</span>. Besides the simplifications in the code (no explicit storage needed), the concept of temporaries allows <span class="math inline"><em>GridTools</em></span> to apply optimization. Since the temporaries, by definition, are only visible inside a computation, <span class="math inline"><em>GridTools</em></span> is free to remove them if it does not break the semantics of the algorithm.</p>
<h2 id="functor-calls">Functor calls</h2>
<p>The next feature we want to use is the <em>function call</em>. This will allow us to get rid of the temporaries. In a first step we remove only one of the temporaries. Instead of calling the Laplacian twice from the <span><code>]{} we will move one of the calls into the smoothing functor. The new smoothing functor looks as follows In [</code></span> we specify the functor and the <span><code>]{}-method overload we want to apply. In [</code></span> the <span><code>]{} is passed forward followed by all the input arguments for the functor. The functor in the call is required to have exactly one [</code></span> which will be the return value of the call.</p>
<p>The new setup looks as follows</p>
<p>The attentive reader may have noticed that our first versions did more work than needed: we calculated the Laplacian of the Laplacian of phi (<span class="math inline"><em>Δ</em><em>Δ</em><em>ϕ</em></span>) for all <span class="math inline"><em>k</em></span>-levels, however we used it only for <span class="math inline"><em>k</em> &lt; <em>k</em><sub>max</sub></span>. In this version we do a bit better: we still calculate the Laplacian (<span class="math inline"><em>L</em> = <em>Δ</em><em>ϕ</em></span>) for all levels but we only calculate <span class="math inline"><em>Δ</em><em>L</em></span> for the levels where we need it.</p>
<h4 id="outlook">Outlook</h4>
<p>Eventually we would like to get rid of this problem (and the last temporary) in an elegant way with nested function calls as follows Unfortunately, this is currently not supported in <span class="math inline"><em>GridTools</em></span><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<h2 id="mm">Full code listing</h2>
<p>The full compilable version of the code is given in <a href="#full_lap">Full code listing</a></p>
<pre id="full_lap" class="cpp numberLines"><code>#include &lt;common/defs.hpp&gt;
#include &lt;stencil-composition/stencil-composition.hpp&gt;

using namespace gridtools;
using namespace gridtools::enumtype;
using namespace gridtools::expressions;

constexpr static gridtools::dimension&lt; 1 &gt; i;
constexpr static gridtools::dimension&lt; 2 &gt; j;
constexpr static gridtools::dimension&lt; 3 &gt; k;

#ifdef __CUDACC__
using backend_t = backend&lt; Cuda, structured, Block &gt;;
using layout_t = gridtools::layout_map&lt; 2, 1, 0 &gt;;
#else
using backend_t = backend&lt; Host, structured, Block &gt;;
using layout_t = gridtools::layout_map&lt; 0, 1, 2 &gt;;
#endif

using storage_info_t = backend_t::storage_info&lt; 0, layout_t &gt;;
using storage_t = backend_t::storage_type&lt; double, storage_info_t &gt;::type;
/***/
using lower_domain = interval&lt; level&lt; 0, -1 &gt;, level&lt; 1, -1 &gt; &gt;;
using upper_domain = interval&lt; level&lt; 1, 1 &gt;, level&lt; 2, -1 &gt; &gt;;
using full_domain = interval&lt; level&lt; 0, -1 &gt;, level&lt; 2, -1 &gt; &gt;;

using axis = interval&lt; level&lt; 0, -2 &gt;, level&lt; 2, 1 &gt; &gt;;
/***/
struct lap_function {
    using in = in_accessor&lt; 0, extent&lt; -1, 1, -1, 1 &gt; &gt;;
    using lap = inout_accessor&lt; 1 &gt;;

    using arg_list = boost::mpl::vector&lt; in, lap &gt;;

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, full_domain) {
        eval(lap(i, j, k)) = -4. * eval(in(i, j, k)) /***/
                             + eval(in(i + 1, j, k)) /***/
                             + eval(in(i, j + 1, k)) /***/
                             + eval(in(i - 1, j, k)) /***/
                             + eval(in(i, j - 1, k));
    }
};
/***/
#include &lt;stencil-composition/structured_grids/call_interfaces.hpp&gt;
struct smoothing_function_3 {
    using phi = in_accessor&lt; 0 &gt;;
    using lap = in_accessor&lt; 1, extent&lt; -1, 1, -1, 1 &gt; &gt;;
    using out = inout_accessor&lt; 2 &gt;;

    using arg_list = boost::mpl::vector&lt; phi, lap, out &gt;;

    constexpr static double alpha = 0.5;

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, lower_domain) {
        eval(out(i, j, k)) = eval(phi(i, j, k)) -
                             alpha *                               /***/
                                 call&lt; lap_function, full_domain &gt; /***/
                                 ::with(eval, lap());
    }

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, upper_domain) {
        eval(out(i, j, k)) = eval(phi(i, j, k));
    }
};
/***/
int main() {
    std::unordered_map&lt;int, std::string&gt; x{};

    uint_t Ni = 10;
    uint_t Nj = 12;
    uint_t Nk = 20;
    uint_t kmax = 10;

    storage_info_t info(Ni, Nj, Nk);

    int bs = 2; // boundary size
    halo_descriptor boundary_i(bs, bs, bs, Ni - bs - 1, Ni);
    halo_descriptor boundary_j(bs, bs, bs, Nj - bs - 1, Nj);
    /***/
    using temp_storage_t = /***/
        backend_t::temporary_storage_type&lt; double, storage_info_t &gt;::type;

    storage_t phi(info);
    storage_t phi_new(info);

    using arg_phi = arg&lt; 0, storage_t &gt;;
    using arg_phi_new = arg&lt; 1, storage_t &gt;;
    using arg_lap = arg&lt; 2, temp_storage_t &gt;;

    using arg_list = boost::mpl::vector&lt; arg_phi, arg_phi_new, arg_lap &gt;;
    aggregator_type&lt; arg_list &gt; /** */
        domain(boost::fusion::make_vector(&amp;phi, &amp;phi_new));

    grid&lt; axis &gt; my_grid(boundary_i, boundary_j);
    my_grid.value_list[0] = 0;
    my_grid.value_list[1] = kmax;
    my_grid.value_list[2] = Nk - 1;

    auto smoothing = make_computation&lt; backend_t &gt;(           /***/
        domain,                                               /***/
        my_grid,                                              /***/
        make_multistage(                                      /***/
            execute&lt; forward &gt;(),                             /***/
            make_stage&lt; lap_function &gt;(arg_phi(), arg_lap()), /***/
            make_stage&lt; smoothing_function_3 &gt;(               /***/
                arg_phi(),                                    /***/
                arg_lap(),                                    /***/
                arg_phi_new())                                /***/
            ));                                               /***/
    /***/
    smoothing-&gt;ready();
    smoothing-&gt;steady();

    smoothing-&gt;run();

    smoothing-&gt;finalize();
}</code></pre>
<h2 id="how-to-pass-the-alpha-global-accessors">How to pass the <span class="math inline"><em>α</em></span>: Global accessors</h2>
<h2 id="distributing-the-work-gcl">Distributing the work: GCL</h2>
<h2 id="boundary-conditions">Boundary conditions</h2>
<h1 id="storages-1">Storages</h1>
<h2 id="simple-use-and-multidimensional-fields">Simple use and multidimensional fields</h2>
<h2 id="ghost-dimensions">Ghost dimensions</h2>
<h2 id="fields">Fields</h2>
<h2 id="gpu-storages">GPU storages</h2>
<h2 id="detailed-storage-configuration">Detailed storage configuration</h2>
<h1 id="dsl-introduction">DSL introduction</h1>
<h2 id="syntax-for-user-operators">Syntax for User Operators</h2>
<h3 id="detailed-syntax-dimensions-expressions-offsets-of-accessors">Detailed syntax: , (), dimensions, expressions, offsets of accessors</h3>
<h2 id="parallelization-model-stages-and-multistages">Parallelization Model: Stages and MultiStages</h2>
<h2 id="preparing-arguments-storage-placeholders">Preparing arguments: storage placeholders</h2>
<h2 id="vertical-regions-and-vertical-boundary-conditions">Vertical regions and vertical boundary conditions</h2>
<h2 id="use-of-temporaries">Use of temporaries</h2>
<h2 id="composing-stencils">Composing Stencils</h2>
<h2 id="irregular-grids-syntax">Irregular Grids Syntax</h2>
<h1 id="stencil-functions">Stencil Functions</h1>
<h1 id="conditional-stencils">Conditional Stencils</h1>
<h1 id="reductions">Reductions</h1>
<h1 id="details-for-performance">Details for performance</h1>
<h2 id="fusion-and-organization-of-stages">Fusion and organization of stages</h2>
<h2 id="software-managed-caches">Software Managed Caches</h2>
<p>Software managed caches are a very important functionality of <span class="math inline"><em>GridTools</em></span> in order to exploit performance for stencils on computing architectures, like NVIDIA GPUs, where cache of data is not automatic. A significant optimization of the stencils using <span class="math inline"><em>GridTools</em></span> is achieved by means of an increase of the data locality of the stencil algorithms, for which detecting data reuse patterns and caching the corresponding fields is essential for a good performance.</p>
<p>Since GPUs require to explicit express in the code the use of the different memory hierarchies (i.e. shared memory, registers, texture cache... ) <span class="math inline"><em>GridTools</em></span> provides a special syntax to express the data reuse patterns. The syntax is independent of the type of scratch pad used by the library to store data and depends only on the access patterns of that field by the stencil methods. The main syntax for caching certain fields of a <code>computation</code> is shown below</p>
<pre class="cpp"><code>auto comp = make_computation&lt; BACKEND &gt;(
    domain,
    grid,
    make_multistage(
        execute&lt; forward &gt;(),
        define_caches(cache&lt; IJ, local &gt;(p_f1(), p_f2())),
        make_stage&lt; lap_function &gt;(p_f1(), p_f2(), p_in()),
        make_stage&lt; lap_function &gt;(p_out(), p_f1(), p_f2())
    )
);</code></pre>
<p>The cache DSL elements are enclosed into a <code>define_caches</code> construct, that accept any number of <code>cache</code> constructs. At the same time, each <code>cache</code> construct can specify multiple fields that shared the same access pattern.</p>
<p>The <code>cache</code> construct adheres to the following syntax:</p>
<pre><code>cache&lt; cache_type, io_policy, [interval] &gt;( p_arg) </code></pre>
<p>There are multiple type of caches that can be used for different data reuse pattern situations:</p>
<ol style="list-style-type: decimal">
<li><p>IJ caches: cache fields whose access pattern lies in the IJ-plane</p></li>
<li><p>K caches: cache field whose access pattern is restricted to the K-plane</p></li>
<li><p>bypass: Special cache-type that express null or very little reuse within the stencil</p></li>
</ol>
<p>Additionally the cache</p>
<h2 id="alignment-halo-of-storages">Alignment: halo of storages</h2>
<h2 id="expandable-parameters">Expandable parameters</h2>
<h1 id="halo-updates">Halo Updates</h1>
<h2 id="boundary-conditions-1">Boundary Conditions</h2>
<h2 id="halo-exchanges">Halo Exchanges</h2>
<h1 id="data-management">Data management</h1>
<h1 id="interfacing-to-other-programming-languages">Interfacing to other programming languages</h1>
<h1 id="benchmarking-stencils">Benchmarking stencils</h1>
<h1 id="serialbox-and-porting-your-reference-application">SerialBox and porting your reference application</h1>
<h4 id="regular-accessors">Regular Accessors</h4>
<p>Regular accessors are proxy objects used to access <a href="data%20fields">Data Field</a> with any dimension. The access is performed by specifying increments (offsets) with respect to the current position of the stencil (iteration point).</p>
<p>As described in the <a href="storage">Storage</a> documentation, a data field can be a contiguous array with arbitrary dimension, a vector of multidimensional arrays, or a kind of <em>matrix</em> of multidimensional arrays (possibly with empty elements). In order to avoid ambiguities we called <a href="space%20dimension">Space Dimension</a> the dimension of each multidimensional array (or <em>snapshot</em>), and <a href="field%20dimensions">Field Dimension</a> the dimensions identifying the position of the snapshot inside the vector (or matrix). Since the field dimensions are atmost two, we will identify them as <em>component dimension</em> and <em>snapshot dimension</em>, in line with their most intuitive use case, i.e. a vector representation of a time discretization.</p>
<p>We introduce the accessors syntax with progressively more complex examples to explain how the different dimensions can be accessed.</p>
<h5 id="space-dimensions">Space Dimensions</h5>
<p>Let's start with an arbitrary dimensional array (a single <em>snapshot</em>). The API exposed is very intuitive. Suppose you have as first argument of the functor a 5 (space) dimentional snapshot as an input with null extent called <code>acc</code>. Then the accessor to use is the following:</p>
<pre class="cpp"><code>using acc = accessor&lt;0, enumtype::in, extent&lt;&gt;, 5&gt;;</code></pre>
<p>We can access the 2 extra dimensions by specifying all the offsets</p>
<pre class="cpp"><code>acc(0,0,-1,2,2)</code></pre>
<p>We can also assign a name to a dimension, and increment it using the following syntax, where we ignore the first two <code>0</code>s:</p>
<pre class="cpp"><code>dimension&lt;3&gt; k; dimension&lt;4&gt; c; dimension&lt;5&gt; t;
acc(k-1, c+2, t+2)</code></pre>
<p>In the latter API the order of the arguments is irrelevant</p>
<pre class="cpp"><code>dimension&lt;3&gt; k; dimension&lt;4&gt; c; dimension&lt;5&gt; t;
acc(k-1, t+2, c+2) == acc(c+2, k-1, t+2)</code></pre>
<p>Note that the second notation may greatly improve the readibility of the user functor body by exposing a matlab-like API, especially when high dimensionality is used.</p>
<h5 id="field-dimensions">Field Dimensions</h5>
<p>Specifying an offset for a field dimension works exactly as for the space dimension. So there is no way to distinguish the two only based on the user functor. Whether we are accessing a space dimension or a field dimension will depend only on the storage type which will be bound to the accessor, and not on the accessor itself. So in the example</p>
<pre class="cpp"><code>dimension&lt;3&gt; k; dimension&lt;4&gt; c; dimension&lt;5&gt; t;
acc(k-1, c+2, t+2)</code></pre>
<p><code>c+2</code> may refer to an offset to the 4th dimension or the third components (the indices are zero based) of a vector field, while <code>t+2</code> may refer to the third snapshot of that component. Alternatively, if the storage passed in had 4 space dimensions, the <code>t+2</code> would have indicated the third component.</p>
<h5 id="accessor-alias">Accessor Alias</h5>
<p>An accessor alias is a regular accessor which has an offset set at compile-time. For instance, say you have a vector field in <span class="math inline">$\mathbb R^3$</span> with components h, v, w. This vector field is accessed via an accessor called <code>vec</code></p>
<pre class="cpp"><code>using vec = accessor&lt;0, enumtype::in, extent&lt;&gt;, 4&gt;;</code></pre>
<p>However you may want to be able to refer to the third element of the vector with <code>w</code> sometimes in some expressions. You can do this defining an alias to the third component of the accessor:</p>
<pre class="cpp"><code>using w = alias&lt;vec, dimension&lt;4&gt; &gt;::set&lt;2&gt;;</code></pre>
<p>The line above sets at compile-time the fourth offset to the value 2, so that we have the following equivalency:</p>
<pre class="cpp"><code>w() == vec(0,0,0,2)</code></pre>
<p>which may contribute to considerably lighten the notation in complicated expressions. Note that you can still access the other dimensions with an offset, by using the alias. So that</p>
<pre><code>dimension&lt;1&gt; i;
dimension&lt;4&gt; q;
w(i+1) == vel(i+1, q+2)</code></pre>
<h5 id="expressions">Expressions</h5>
<p>The Do method example provided in [Example] showed the basic syntax to access data.</p>
<pre class="cpp"><code>template &lt; typename Evaluation &gt;
        GT_FUNCTION static void Do(Evaluation &amp;eval) {
            eval(out()) = eval(lap(1, 0, 0)) - eval(lap(0, 0, 0));
            if (eval(out()) * (eval(in(1, 0, 0)) - eval(in(0, 0, 0))) &gt; 0) {
                eval(out()) = 0.;
            }</code></pre>
<p>We can notice that the <code>eval</code> keyword is repeated several times, which is somehow tedious, especially when the expression is complicated it becaomes quickly very hard to read. It is possible to embed the expressions in a single eval, i.e.</p>
<pre class="cpp"><code>using namespace expressions;
template &lt; typename Evaluation &gt;
        GT_FUNCTION static void Do(Evaluation &amp;eval) {
            eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
            if (eval(out() * (in(1, 0, 0) - in(0, 0, 0)) &gt; 0) {
                eval(out()) = 0.;
            }</code></pre>
<p>This is achieved by using the expressions namespace, in which the operations <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>pow&lt;2&gt;</code> are overloaded, and generate an expression to be evaluated. An example of its usage, demonstrating its effectiveness, can be found in the <a href="shallow%20water">Shallow Water</a> example.</p>
<p>It is possible also to instantiate a compile time expression to be lazily evaluated, useful for instance if we want to evaluate it multiple times</p>
<pre class="cpp"><code>using namespace expressions;
constexpr auto cond = out() * (in(1, 0, 0) - in(0, 0, 0);
template &lt; typename Evaluation &gt;
        GT_FUNCTION static void Do(Evaluation &amp;eval) {
            eval(out()) = eval(lap(1, 0, 0) - lap(0, 0, 0));
            if (eval(cond) &gt; 0) {
                eval(out()) = 0.;
            }</code></pre>
<h4 id="vector-accessors">Vector Accessors</h4>
<p>Vector accessors are used when dealing with <a href="expandandable%20parameters">Expandable Parameters</a>, which are sequences of storages on which we want to perform the same operations. They implement a &quot;single stencil multiple storages&quot; pattern, as if the same stencil was applied to all the elements of the vector concurrently.</p>
<p>This &quot;loop&quot; or &quot;vector operation&quot; is completely abstracted away from the API of the user function. The user has to define a <em>vector_accessor</em> as if it was a regular accessor, and the corresponding stencil will be executed multiple times, each time considering different elements in the vector.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>If multiple vector accessors are used in the same</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>stage, the corresponding expandable parameters</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>storage vectors must have the same length</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>We can mix vector accessors with regular accessors.</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>In that case the regular accessor will be the same for</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>all the stage invocations, while the vector accessor</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>will iterate over its components.</td>
</tr>
</tbody>
</table>
<p>For an example of usage of the vector accessor see the <a href="advection%20pdbott%20example">Advection Pdbott</a></p>
<h4 id="global-accessors">Global Accessors</h4>
<p>Global accessors are accessing read-only data which is independent of the current iteration point. For this reason <a href="intents">Intent</a>, <a href="extents">Extent</a> and <a href="offsets">Offset</a> cannot be specified for a global accessor. Here the term &quot;global&quot; means that the data is the same for the whole grid. An example can be a constant scalar parameter that you want to pass to the functor, or a user defined struct containing various configuration options.</p>
<p>The API allows the user to define an arbitrary object deriving from <a href="global%20parameter">Global Parameter</a>, and pass it to the computation. The accessor associated with this global parameter must be a global accessor</p>
<pre class="cpp"><code>    using global_accessor&lt; 0 &gt; global_boundary;</code></pre>
<p>Calling <code>eval</code> on the global accessor returns the user defined data structure. Supposing that this data structure contains a user function called <code>ordinal</code> returning an integer, we can write in the do method</p>
<pre class="cpp"><code>    auto ordinal_ = eval(global_boundary()).ordinal();</code></pre>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>All the member functions defined in the user-defined</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>data structure must be labeled with GT_FUNCTION, in</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>order for them to be callable from devices.</td>
</tr>
</tbody>
</table>
<p>There is a special case for which we have a dedicated API: i.e. when the user defined object (the global parameter) defines parenthesis operator <code>operator()</code>, and we want to call that operator from the Do method. In that case the accessor's parenthesis operator can be used and the arguments will be automatically forwarded to the global parameter. An example is the case in which we want to pass a small matrix as a global parameter:</p>
<pre class="cpp"><code>    using global_accessor&lt; 0 &gt; matrix;
    auto elem = eval(matrix(i,j));</code></pre>
<p>A useful example to understand this use case can be found in the <a href="extended4D%20example">Extended4D</a>.</p>
<h4 id="expandable-parameters-1">Expandable Parameters</h4>
<p>Expandable parameters implement a &quot;single stencil multiple storages&quot; pattern. They are useful when we have a vector of storages which have the same storage info, and we want to perform the same operation with all of them (a typical situation when implementing e.g. time differentiation schemes). Normally this could be achieved by creating a loop and running multiple computations, but this solution would be inefficient. Another possibility would be to create a storage_list, and use the <a href="vector%20accessors">Vector Accessor</a> inside the Do method to manually unroll the loop. This second option is tedious, does not allow dynamic vector length, i.e. it forces the size of the vector to be compile-time known. The expandable parameters API solves this problem elegantly, with a minimal code overhead.</p>
<p>The user must collect the storage pointers in a <code>std::vector</code></p>
<pre class="cpp"><code>        using exp_param_t = std::vector&lt; pointer&lt; storage_t &gt; &gt;;
        exp_param_t list_ = {
            &amp;storage1, &amp;storage2, &amp;storage3, &amp;storage4, &amp;storage5, &amp;storage6, &amp;storage7, &amp;storage8};</code></pre>
<p>This <code>std::vector</code> is then used as a storage type <code>exp_param_t</code> with no differences with respect to the regular storages.</p>
<p>The implementation requires the user to specify an integer <code>expand_factor</code> when defining the computation:</p>
<pre class="cpp"><code>auto comp_ = make_computation&lt; BACKEND &gt;(
        expand_factor&lt;4&gt;,
        domain_,
        grid_,
        make_multistage(enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor &gt;(p())));</code></pre>
<p>The vector of storages is then partitioned into chuncks of <code>expand_factor</code> size (with a remainder). Each chunck is unrolled whithin a computation, and for each chunck a different computation is instantiated. The remainder elements are then processed one by one. More information on how to access the expandable parameter storages inside a computation is given in the <a href="Vector%20Accessors">Vector Accessors</a> session (where also some of the constraints are reported).</p>
<p>Summing up, the only differences with respect to the case without expandable parameters are: - an <code>expand_factor</code> has to be passed to the make_computation, defining the size of the chuncks of expandable parameters we want to unroll in each computation. - a <a href="vector%20accessor">Vector Accessor</a> has to be used instead of a regular one in the Do method - a <code>std::vector</code> of storage pointers has to be used instead of a single storage.</p>
<p>All the rest is managed by <span class="math inline"><em>GridTools</em></span>, so that the user is not exposed to the complexity of the unrolling, he can reuse the code when the expand factor changes, and he can resize dynamically the expandable paramenters vector, for instance by adding or removing elements.</p>
<h4 id="conditionals">Conditionals</h4>
<p>Conditionals introduce two new syntactic elements in the <a href="computation%20grammar">Grammar</a>, namely <code>if_</code> and <code>switch_</code>. These implement run-time branches in the computation tree, i.e. one computation or another can be chosen based on the value of a runtime variable. Note that this is just syntactic sugar, as you could instantiate all the possible combinations of the computation tree and then choose which one to execute by querying the value of a runtime condition. This would work in the same way as the solution we will describe next, but it would create a code of an unmanageable size most of the time: suppose that inside a computation with 10 stages you want to choose among 5 possible versions of the last stage. You would have to create 5 different computations, in which the only difference is in the last stage, while the rest is repeated. This would be tedious and error-prone.</p>
<p>The syntax we expose for <code>if_</code> statements is reported in the following example</p>
<pre class="cpp"><code>   auto cond = new_cond([&amp;flag]() { return flag; });
   auto comp_ = make_computation&lt; BACKEND &gt;(
                domain_,
                grid_,
                if_(cond,
                    make_multistage(enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor0 &gt;(p())),
                    make_multistage(enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor1 &gt;(p()))));</code></pre>
<p>In this example <code>cond</code> is defined as a predicate using the <code>new_cond</code> <span class="math inline"><em>GridTools</em></span> keyword. Note that this code will always only be executed on the host, so the predicate can access values which are available on the host, so captures by reference can be used. The correct way to interpret this syntax is that the call to <code>if_</code> returns one multistage o the other based on the return value of the predicate attached to <code>cond</code>.</p>
<p>The value of <code>cond</code> is evaluated at every execution of the <code>comp_.run()</code> function.</p>
<p>The conditionals can also be nested</p>
<pre class="cpp"><code>   auto cond = new_cond([]() { return false; });
   auto cond2 = new_cond([]() { return true; });
   auto comp_ = make_computation&lt; BACKEND &gt;(
                domain_,
                grid_,
                if_(cond,
                    make_multistage(enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor0 &gt;(p())),
                    if_(cond2,
                        make_multistage(
                            enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor1 &gt;(p())),
                        make_multistage(
                            enumtype::execute&lt; enumtype::forward &gt;(), make_stage&lt; functor2 &gt;(p())))));</code></pre>
<p>The other syntactic element we introduce is a <code>switch_</code>, and its use is exemplified in the following snippet</p>
<pre class="cpp"><code>   auto cond_ = new_switch_variable([&amp;p]() { return p ? 0 : 5; });
   auto comp_ = make_computation&lt; BACKEND &gt;(
       domain_,
       grid_,
       make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
           make_stage&lt; functor0 &gt;(p(), p_tmp()),
           make_stage&lt; functor1 &gt;(p(), p_tmp())),
       switch_(cond_,
           case_(0,
                   make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
                       make_stage&lt; functor1 &gt;(p(), p_tmp()),
                       make_stage&lt; functor2 &gt;(p(), p_tmp()))),
           case_(1,
                   make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
                       make_stage&lt; functor1 &gt;(p(), p_tmp()),
                       make_stage&lt; functor2 &gt;(p(), p_tmp()))),
           case_(2,
                   make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
                       make_stage&lt; functor1 &gt;(p(), p_tmp()),
                       make_stage&lt; functor2 &gt;(p(), p_tmp()))),
           case_(3,
                   make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
                       make_stage&lt; functor1 &gt;(p(), p_tmp()),
                       make_stage&lt; functor2 &gt;(p(), p_tmp()))),
           case_(4,
                   make_multistage(enumtype::execute&lt; enumtype::forward &gt;(),
                       make_stage&lt; functor1 &gt;(p(), p_tmp()),
                       make_stage&lt; functor2 &gt;(p(), p_tmp())))))</code></pre>
<p>As for the <code>if_</code> statement, <code>cond_</code> is evaluated at every call to <code>comp_-&gt;run()</code>, and the multistage executed in the two calls will be different.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>Also <code>switch_</code> can be nested, as the <code>if_</code>.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>The effect of having different branches is that all the</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>possibilities get compiled, and only one gets chosen at</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>each run. Therefore having lot of branches can increase</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>dramatically the compilation times, you should not abuse</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>of this feature.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>Currently there is a limitation. The different branches</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>in the computation must use the same placeholders.</td>
</tr>
</tbody>
</table>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>With the Cuda backend we allocate memory on host and device. In the standard use-cases you don’t need to update the data manually, but you still have the option to do so.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>At this point the reader should be able to complete the missing parts in the setup.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>There are other ways to accomplish this behavior. The extra computation can be avoided by defining the Laplacian only on the interval where we need it; the temporary could be avoided by a bit of code duplication, however there is no good reason to do it.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
