<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />

  <link rel="stylesheet" type="text/css" href="template.css" />

   <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />



<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script type='text/javascript' src='menu/js/jquery.cookie.js'></script>
<script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script>
<script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

<link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
<link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
<link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
  
  <script src="script.js"></script>
  
    <script src="jquery.sticky-kit.js "></script>
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc-bootstrap-adaptive-template/template.css" type="text/css" />
</head>
<body>

    
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#installation-and-configuration">Installation and Configuration</a></li>
        <li><a href="#sec:getting_started">Quick Start Guide</a><ul>
        <li><a href="#coordinate-system">Coordinate System</a></li>
        <li><a href="#storages">Storages</a></li>
        <li><a href="#backend">Backend</a></li>
        <li><a href="#memory-layout">Memory layout</a></li>
        <li><a href="#the-storage-type">The storage type</a></li>
        <li><a href="#storage-with-halo">Storage with halo</a></li>
        <li><a href="#stencils">Stencils</a></li>
        <li><a href="#example-naive-2d-laplacian">Example: Naive 2D Laplacian</a></li>
        <li><a href="#first-textitgridtoolsstencil">First <span class="math inline"><em>GridTools</em></span> stencil</a></li>
        <li><a href="#assembling-stencils-smoothing-filter">Assembling stencils: smoothing filter</a></li>
        <li><a href="#do-method-overload">Do-method overload</a></li>
        <li><a href="#textitgridtoolstemporaries"><span class="math inline"><em>GridTools</em></span> temporaries</a></li>
        <li><a href="#functor-calls">Functor calls</a></li>
        <li><a href="#mm">Full code listing</a></li>
        <li><a href="#how-to-pass-the-alpha-global-accessors">How to pass the <span class="math inline"><em>α</em></span>: Global accessors</a></li>
        <li><a href="#distributing-the-work-gcl">Distributing the work: GCL</a></li>
        <li><a href="#boundary-conditions">Boundary conditions</a></li>
        </ul></li>
        <li><a href="#storages-1">Storages</a><ul>
        <li><a href="#simple-use-and-multidimensional-fields">Simple use and multidimensional fields</a></li>
        <li><a href="#ghost-dimensions">Ghost dimensions</a></li>
        <li><a href="#fields">Fields</a></li>
        <li><a href="#gpu-storages">GPU storages</a></li>
        <li><a href="#detailed-storage-configuration">Detailed storage configuration</a></li>
        </ul></li>
        <li><a href="#dsl-introduction">DSL introduction</a><ul>
        <li><a href="#syntax-for-user-operators">Syntax for User Operators</a></li>
        <li><a href="#parallelization-model-stages-and-multistages">Parallelization Model: Stages and MultiStages</a></li>
        <li><a href="#preparing-arguments-storage-placeholders">Preparing arguments: storage placeholders</a></li>
        <li><a href="#vertical-regions-and-vertical-boundary-conditions">Vertical regions and vertical boundary conditions</a></li>
        <li><a href="#use-of-temporaries">Use of temporaries</a></li>
        <li><a href="#composing-stencils">Composing Stencils</a></li>
        <li><a href="#irregular-grids-syntax">Irregular Grids Syntax</a></li>
        </ul></li>
        <li><a href="#stencil-functions">Stencil Functions</a></li>
        <li><a href="#conditional-stencils">Conditional Stencils</a></li>
        <li><a href="#reductions">Reductions</a></li>
        <li><a href="#details-for-performance">Details for performance</a><ul>
        <li><a href="#fusion-and-organization-of-stages">Fusion and organization of stages</a></li>
        <li><a href="#software-managed-caches">Software Managed Caches</a></li>
        <li><a href="#alignment-halo-of-storages">Alignment: halo of storages</a></li>
        <li><a href="#expandable-parameters">Expandable parameters</a></li>
        </ul></li>
        <li><a href="#halo-updates">Halo Updates</a><ul>
        <li><a href="#boundary-conditions-1">Boundary Conditions</a></li>
        <li><a href="#halo-exchanges">Halo Exchanges</a></li>
        </ul></li>
        <li><a href="#data-management">Data management</a></li>
        <li><a href="#interfacing-to-other-programming-languages">Interfacing to other programming languages</a></li>
        <li><a href="#benchmarking-stencils">Benchmarking stencils</a></li>
        <li><a href="#serialbox-and-porting-your-reference-application">SerialBox and porting your reference application</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <link rel="stylesheet" href="highlight.js/color-brewer.min.css">
<script src="highlight.js/highlight.min.js"></script>
<script src="highlight.js/jquery-2.1.3.min.js"></script>
<script src="highlight.js/cpp_gt.js"></script>
<script>
$(function() {
    $("pre > code").each(function(i, block) {
        var codeClass = $(this).parent().attr("class");
        if (codeClass == null || codeClass === "") {
            $(this).addClass("hljs");
        } else {
            var map = {
                js: "javascript"
            };
            if (map[codeClass]) {
                codeClass = map[codeClass];
            }
            $(this).addClass(codeClass);
            hljs.highlightBlock(this);
        }
    });
});
</script>
<h1 id="installation-and-configuration">Installation and Configuration</h1>
<h1 id="sec:getting_started">Quick Start Guide</h1>
<p>This chapter describes how to use <span class="math inline"><em>GridTools</em></span> to solve a (simple) PDE. We will use the fourth-order horizontal smoothing filter example from with small modifications to explain the necessary steps to assemble a stencil from scratch. We will not go into details in this chapter but refer to latter chapters for more details.</p>
<p>Our example PDE is given by <br /><span class="math display">$$\label{eq:getting_started:examplepde}
\frac{\partial \phi}{\partial t} =\begin{cases}
- \alpha \nabla^4 \phi &amp; z \leq z_\text{max}\\
0 &amp; z &gt; z_0
\end{cases}$$</span><br /> where <span class="math inline">∇<sup>4</sup></span> is the squared two dimensional horizontal Laplacian and we apply the filter only up to some maximal <span class="math inline"><em>z</em><sub>0</sub></span> (to make the example more interesting). The filter is calculated in two steps: first we calculate the Laplacian of <span class="math inline"><em>ϕ</em></span></p>
<p><br /><span class="math display">$$L = \Delta \phi = \left( \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right) \phi$$</span><br /></p>
<p>then we calculate the Laplacian of <span class="math inline"><em>L</em></span></p>
<p><br /><span class="math display">−<em>α</em>∇<sup>4</sup><em>ϕ</em> = −<em>α</em><em>Δ</em><em>L</em></span><br /></p>
<p>In the following we will walk through the following steps:</p>
<ul>
<li><p>The <span class="math inline"><em>GridTools</em></span> coordinate system and its notation.</p></li>
<li><p>Storages: how does <span class="math inline"><em>GridTools</em></span> manage the input and output fields.</p></li>
<li><p>The first stencil: calculating <span class="math inline"><em>L</em></span>, the second order Laplacian of <span class="math inline"><em>ϕ</em></span>.</p></li>
<li><p>The final stencil: function calls, Do-method overloads and temporaries</p></li>
<li><p>MISSING: How to pass the <span class="math inline"><em>α</em></span>: Global accessors</p></li>
<li><p>MISSING: Distributing the work over multiple nodes: GCL</p></li>
<li><p>MISSING: Boundaries</p></li>
</ul>
<h2 id="coordinate-system">Coordinate System</h2>
<p>For a finite difference discretization we restrict the field <span class="math inline"><em>ϕ</em> ∈ ℝ<sup>3</sup></span> to a discrete grid. We use the notation <span class="math inline"><em>i</em> = <em>x</em><sub><em>i</em></sub></span> and <span class="math inline"><em>j</em> = <em>y</em><sub><em>j</em></sub></span> for the horizontal dimension and <span class="math inline"><em>k</em> = <em>z</em><sub><em>k</em></sub></span> for the vertical dimension, where <span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub></span> are the <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span> coordinates restricted on the grid. The <em>computation domain</em> is defined by all grid points in our domain of interest <br /><span class="math display"><em>Λ</em> = (<em>i</em>, <em>j</em>, <em>k</em>) with <em>i</em> ∈ {0…<em>N</em><sub><em>i</em></sub> − 1},<em>j</em> ∈ {0…<em>N</em><sub><em>j</em></sub> − 1},<em>k</em> ∈ {0…<em>N</em><sub><em>k</em></sub> − 1}</span><br /></p>
<p><span class="math inline"><em>GridTools</em></span> supports any number of dimension, however it will treat one dimension, here the <span class="math inline"><em>k</em></span>, dimension differently: the <span class="math inline"><em>i</em><em>j</em></span>-plane is executed in parallel while the computation in <span class="math inline"><em>k</em></span> can be sequential. The consequence is that there must not be a dependency in <span class="math inline"><em>i</em><em>j</em></span> within a stencil while there can be a dependency in <span class="math inline"><em>k</em></span>. For now (this chapter) it is sufficient to just remember that the <span class="math inline"><em>i</em><em>j</em></span>-plane and the <span class="math inline"><em>k</em></span> dimension are treated differently by <span class="math inline"><em>GridTools</em></span>.</p>
<p>The calculation domain is surrounded by a <em>boundary region</em> as depicted in <span>Fig. [fig:getting_started:coordinates]</span>. Computation happens only within the calculation domain but values might be read from grid points in the boundary region.</p>
<div class="figure">
<img src="figures/coordinates.png" alt="Coordinates system" />
<p class="caption">Coordinates system</p>
</div>
<h2 id="storages">Storages</h2>
<p>In this section we will setup the fields for our example: we need a storage for the <span class="math inline"><em>ϕ</em></span>-field (<code>phi_in</code>) and a storage for the output (<code>phi_out</code>).</p>
<p>Storages in <span class="math inline"><em>GridTools</em></span> are n-dimensional array-like objects with the following capabilities:</p>
<ul>
<li><p>access an element with <span class="math inline">(<em>i</em>, <em>j</em>, <em>k</em>)</span> syntax</p></li>
<li><p>copying between CPU memory and a device (e.g. a CUDA capable GPU)</p></li>
</ul>
<h2 id="backend">Backend</h2>
<p>Since the storages (and other things later) depend on the architecture (CPU or GPU) our first step is to define a <em>backend</em> type which typically looks like</p>
<pre class="cpp"><code>using backend_t = backend&lt; Cuda, structured, Block &gt;;</code></pre>
<p>for the CUDA backed or for the CPU backend. The second argument defines the type of the grid, where <code>phi_in</code> refers to a Cartesian grid, see [Chapter [sec:grids]] for details. The last argument defines that blocking should be used in CPU mode (instead of <code>phi_out</code> without blocking). For the CUDA mode <span>``</span> is the only option.</p>
<h2 id="memory-layout">Memory layout</h2>
<p>For efficient memory access the index ordering has to be different for CPUs (<span class="math inline"><em>k</em></span> first) and GPUs (<span class="math inline"><em>i</em></span> first). This is defined with the <span>``</span>. For CUDA we use while we use on the host. We don’t go into more detail here, since this should probably be constructed by the backend (at least for standard use-cases). For now it is enough to know that the first line should be used in GPU mode and the second in CPU mode.</p>
<h2 id="the-storage-type">The storage type</h2>
<p>For each storage type we need to define the type of the data we want to store in the field, e.g. <code>double</code>, and a <code>storage_info</code> type which will hold information about size, alignment, strides etc. The <code>storage_info</code> needs a unique index and a <code>layout_map</code> as defined before. These information are all C++ types, i.e. known at compile-time.</p>
<pre class="cpp"><code>using storage_info_t = backend_t::storage_info&lt; 0, layout_t &gt;;
using storage_t = backend_t::storage_type&lt; double, storage_info_t &gt;::type;</code></pre>
<p>At run-time a <code>storage_info</code> is initialized with the sizes of the field. Then a field can be instantiated with the <code>info</code> object.</p>
<pre class="cpp numberLines"><code>uint_t Ni = 10;
uint_t Nj = 12;
uint_t Nk = 20;

storage_info_t info(Ni, Nj, Nk);

storage_t phi(info, -1., &quot;phi&quot;);
storage_t lap(info, -1., &quot;lap&quot;);</code></pre>
<p>The first argument, the <code>meta</code> object, is mandatory, while the other arguments are optional: a name for the field and an initial value.</p>
<hr />
<table>
<tbody>
<tr class="odd">
<td align="left"><img src="figures/hint.gif" alt="Tip" width="20" height="20" /></td>
<td></td>
</tr>
<tr class="even">
<td align="left"></td>
<td>For each <code>meta_storage</code> type you should use only one</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>instantiation. The mapping between a storage and the</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>run-time information in the <code>meta_storage</code> has to be</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>done at compile time via the index. Thus <span class="math inline"><em>GridTools</em></span> cannot</td>
</tr>
<tr class="even">
<td align="left"></td>
<td>distinguish the storages by the run-time sizes passed</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td>to the <code>meta_storage</code>.</td>
</tr>
</tbody>
</table>
<hr />
<p>We can now</p>
<ul>
<li><p>retrieve the name of the field,</p></li>
<li><p>read and write values in the field using the parenthesis syntax,</p></li>
<li><p>copy the data to device or back to host (in Cuda mode)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p></li>
</ul>
<h2 id="storage-with-halo">Storage with halo</h2>
<p>It is usually beneficial to align the storage to the location of the first element of the calculation domain. Therefore it is possible to tell the storage about the halo region. Since this will probably change in the new storage design we will leave the documentation of this advanced feature for later.</p>
<h2 id="stencils">Stencils</h2>
<p>A <em>stencil</em> is a kernel that updates array elements according to a fixed access pattern.</p>
<h2 id="example-naive-2d-laplacian">Example: Naive 2D Laplacian</h2>
<p>The simplest discretization of the 2D Laplacian is the finite difference five-point stencil as depicted in <span>Fig. [fig:getting_started:laplacian2D]</span>. For the calculation of the Laplacian at a given grid point we need the value at the grid point itself and its four direct neighbors along the Cartesian axis.</p>
<div class="figure">
<img src="figures/Laplacian2D.png" alt="Access pattern of a 2D Laplacian" />
<p class="caption">Access pattern of a 2D Laplacian</p>
</div>
<p>A naive C++ implementation of the 2D Laplacian stencil is provided in <span>Listing [code:getting_started:cxx_laplacian]</span>.</p>
<p>Apart from the initialization (orange) the stencil implementation consists of 2 main components:</p>
<ul>
<li><p>Loop-logic (green): defines the stencil application domain and loop order</p></li>
<li><p>Update-logic (blue): defines the update formula (here: the 2D Laplacian)</p></li>
</ul>
<p>Special care has to be taken at the boundary of the domain. Since the Laplacian needs the neighboring points we cannot calculate the Laplacian on the boundary layer and have to exclude them from the loop.</p>
<h2 id="first-textitgridtoolsstencil">First <span class="math inline"><em>GridTools</em></span> stencil</h2>
<p>In <span class="math inline"><em>GridTools</em></span> the loop logic and the storage order is implemented (and optimized) by the library while the update function is implemented by the user. The loop logic (for a given architecture) is combined with the user-defined update function at compile-time by template meta-programming (see <span>Sec. [sec:introduction:template_meta_programming]</span>).</p>
<h3 id="update-logic-textitgridtools2d-laplacian">Update-logic: <span class="math inline"><em>GridTools</em></span> 2D Laplacian</h3>
<p>The update-logic is implemented with state-less functors. A <span class="math inline"><em>GridTools</em></span> functor is a <span><code>]{} or [</code></span> providing a <em>static</em> method called <span><code>]{}. The update-logic is implemented in these [</code></span>-methods. As the functors are state-less (no member variables, static methods only) they can be passed by type, i.e. at compile-time, and therefore allow for compile-time optimizations.</p>
<p>In addition to the <span><code>]{}-method, the functor contains [</code></span>s. These two <span><code>]{}s are parameters of the functor, i.e. they are mapped to fields passed to the functor. They contain compile-time information if they are only used as input parameters, like the [</code></span> accessor in the example, or if we want to write into the associated field. Additionally, the <span>``</span> defines which grid-points are needed by the stencil relative to the current point. The format for the extent is</p>
<p>extent<i_minus, i_plus, j_minus, j_plus, k_minus, k_plus></p>
<p>where <span><code>]{} and [</code></span> define an interval on the <span class="math inline"><em>i</em></span>-axis relative to the current position; <span><code>]{} is the negative offset, i.e. zero or a negative number, while [</code></span> is the positive offset. Analogously for <span class="math inline"><em>j</em></span> and <span class="math inline"><em>k</em></span>. In the Laplacian example, <span>Listing [code:getting_started_gtlaplacian]</span>, the first two number in the extent of the <span>``</span> accessor define that we want to access the field at <span class="math inline"><em>i</em> − 1, <em>i</em>, <em>i</em> + 1</span>. The accessor type and the extent is needed for a dependency analysis in the compile-time optimizations for more complex stencils.</p>
<p>The first template argument is an index defining the order of the parameters, i.e. the order in which the fields are passed to the functor. The <span><code>]{} has to defined and stores all accessors in an [</code></span>.</p>
<p>A <span><code>]{} method needs to have two parameters. The first one is a context object [</code></span> that is created and passed to the method by the library on invocation. This object contains, among other things, the index of the active grid point and the mapping of data-pointers to the <span><code>]{}s. The second argument is an interval on the $k$-axis where this implementation should be executed. This allows to apply a different update-logic on intervals by overloading the [</code></span>-method. We will define this interval later.</p>
<p>The body of the <span><code>]{}-method looks quite similar to the one in the naive implementation [Listing \[code:getting\_started:cxx\_laplacian\]]{}, except that each field access has to be wrapped by a call to the context object [</code></span>. This is necessary to map the compile-time parameter, the accessor, to the field, a run-time object.</p>
<h3 id="calling-the-stencil">Calling the stencil</h3>
<p>In the naive implementation, <span>Listing [code:getting_started:cxx_laplacian]</span>, the call to the <span>``</span> is as simple as</p>
<p>int boundary_size = 1; laplacian( lap, phi, boundary_size );</p>
<p>since it contains already all the information: the update-logic <em>and</em> the loop-logic.</p>
<p>The <span class="math inline"><em>GridTools</em></span> stencil, <span>Listing [code:getting_started_gtlaplacian]</span>, does not contain the information about the loop-logic. We have to specify it in an abstract platform-independent syntax, a <em>domain specific embedded language</em> (DSEL), such that the backend can decide on the specific implementation.</p>
<p>For our example it looks as in <span>Listing [code:getting_started:gtlaplacian:make_computation]</span>.</p>
<p>In line [gt_laplacian_setup:arg_phi] and [gt_laplacian_setup:arg_lap] we define placeholders for the fields. In the lines [gt_laplacian_setup:domain:start]-[gt_laplacian_setup:domain:end] the fields, i.e. the storages, are attached to these placeholders in the <span>``</span>.</p>
<p>In lines [gt_laplacian_setup:grid:start] to [gt_laplacian_setup:grid:end] we setup the physical dimension of the problem. First we define which points on the <span class="math inline"><em>i</em></span> and the <span class="math inline"><em>j</em></span>-axis belong to the computational domain and which points belong to the boundary (or a padding region). For now it is enough to know that these lines define an axis with a boundary of size 1 surrounding the <span class="math inline"><em>i</em><em>j</em></span>-plane. In the next lines the layers in <span class="math inline"><em>k</em></span> are defined. In this case we have only one interval. We will discuss the details later.</p>
<p>In lines [gt_laplacian_setup:computation:start] to [gt_laplacian_setup:computation:end] we create the stencil object. We pass the domain (the mapping between placeholders and storages), the grid (the information about the loop bounds) and a <span><code>]{}. The [</code></span> contains a <span>``</span>, our Laplacian functor.</p>
<p>In more complex codes we can combine multiple <span class="math inline"><em>k</em></span>-independent stages in a <span><code>]{}. If we have a $k$-dependency we have to split the computation in multiple [</code></span>s.</p>
<p>The statement <span><code>]{} defines that we want to iterate over $k$ in a forward manner, i.e. starting from the smallest $k$-value to the largest. Other options are [</code></span> and <span><code>]{}[^2]. For performance reason one should use [</code></span> whenever possible.</p>
<p>The next lines [gt_laplacian_setup:ready] and [gt_laplacian_setup:steady] are mandatory: we allocate temporary storages (in our case we don’t use any) and copy the fields to the device (if we use the CUDA backend).</p>
<p>Line [gt_laplacian_setup:run] is self-explanatory: the stencil is executed.</p>
<p>In the last line we free temporary storages and copy modified fields back to the host.</p>
<p>In a more realistic application the <span><code>]{} will be called multiple times. If one wants to inspect the fields between runs (and before the [</code></span>) one has to manually copy the data back from device.</p>
<h3 id="full-textitgridtoolslaplacian">Full <span class="math inline"><em>GridTools</em></span> Laplacian</h3>
<h2 id="assembling-stencils-smoothing-filter">Assembling stencils: smoothing filter</h2>
<p>In the preceding section we saw how a first simple <span class="math inline"><em>GridTools</em></span> stencil is defined and executed. In this section we will use this stencil to compute the example PDE . A naive implementation could look as in <span>Listing [code:getting_started:naive_smoothing]</span>.</p>
<p>For the <span class="math inline"><em>GridTools</em></span> implementation we will learn three things in this section: how to define special regions in the <span class="math inline"><em>k</em></span>-direction; how to use <span class="math inline"><em>GridTools</em></span> temporaries and how to call functors from functors.</p>
<h2 id="do-method-overload">Do-method overload</h2>
<p>Our first <span class="math inline"><em>GridTools</em></span> implementation will be very close to the naive implementation: we will call two times the Laplacian functor from the previous section and store the result in two extra fields. Then we will call a third functor to compute the final result. This functor, see <span>Listing [code:getting_started:gt_smoothing_version1]</span> shows how we can specialize the computation in the <span class="math inline"><em>k</em></span>-direction. We define two intervals, the <span><code>]{} and the [</code></span>, and provide an overload of the <span>``</span>-method for each interval.</p>
<p>The intervals are defined as</p>
<p>Since we are working currently on a nicer API to define the intervals we don’t want to describe the (non-trivial) details now. In short: the first entry in the level is a so-called <span><code>]{}, an abstraction to tell that we want to split the axis here. The second entry is an offset relative to the splitter. At runtime we assign an index of the k-axis to the splitters. Then the [</code></span> corresponds to the index in the <span><code>]{} entry. Additionally we have to define an [</code></span> such that all intervals are a strict subset of the <span>``</span>.</p>
<p>Finally, the call to <span>``</span> looks as follows<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>In this version we needed to explicitly allocate the temporary fields <span><code>]{} and [</code></span>. In the next section we will learn about <span class="math inline"><em>GridTools</em></span> temporaries.</p>
<h2 id="textitgridtoolstemporaries"><span class="math inline"><em>GridTools</em></span> temporaries</h2>
<p><em><span class="math inline"><em>GridTools</em></span> temporary storages</em> are storages with the lifetime of the <span><code>]{}, i.e. they can be used by different stages assembled in one [</code></span> call. This is exactly what we need for the <span><code>]{} and [</code></span> fields.</p>
<p>Note that we did not allocate the temporaries explicitly and we cannot access them from outside of the computation. Therefore it might be necessary sometimes to replace a temporary with a normal storage for debugging.</p>
<p>To use temporary storages we don’t need to change the functors or the <span><code>]{}. We just have to replace the type of the *arg* from a normal storage type to a temporary storage type. We don’t need the explicit instantiations any more and we can leave out pointers to storages when we build the domain. The new code looks as follows The temporary storages are allocated in the [</code></span> call and freed in <span>``</span>. Besides the simplifications in the code (no explicit storage needed), the concept of temporaries allows <span class="math inline"><em>GridTools</em></span> to apply optimization. Since the temporaries, by definition, are only visible inside a computation, <span class="math inline"><em>GridTools</em></span> is free to remove them if it does not break the semantics of the algorithm.</p>
<h2 id="functor-calls">Functor calls</h2>
<p>The next feature we want to use is the <em>function call</em>. This will allow us to get rid of the temporaries. In a first step we remove only one of the temporaries. Instead of calling the Laplacian twice from the <span><code>]{} we will move one of the calls into the smoothing functor. The new smoothing functor looks as follows In [</code></span> we specify the functor and the <span><code>]{}-method overload we want to apply. In [</code></span> the <span><code>]{} is passed forward followed by all the input arguments for the functor. The functor in the call is required to have exactly one [</code></span> which will be the return value of the call.</p>
<p>The new setup looks as follows</p>
<p>The attentive reader may have noticed that our first versions did more work than needed: we calculated the Laplacian of the Laplacian of phi (<span class="math inline"><em>Δ</em><em>Δ</em><em>ϕ</em></span>) for all <span class="math inline"><em>k</em></span>-levels, however we used it only for <span class="math inline"><em>k</em> &lt; <em>k</em><sub>max</sub></span>. In this version we do a bit better: we still calculate the Laplacian (<span class="math inline"><em>L</em> = <em>Δ</em><em>ϕ</em></span>) for all levels but we only calculate <span class="math inline"><em>Δ</em><em>L</em></span> for the levels where we need it.</p>
<h4 id="outlook">Outlook</h4>
<p>Eventually we would like to get rid of this problem (and the last temporary) in an elegant way with nested function calls as follows Unfortunately, this is currently not supported in <span class="math inline"><em>GridTools</em></span><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<h2 id="mm">Full code listing</h2>
<p>The full compilable version of the code is given in <a href="#full_lap">Full code listing</a></p>
<pre id="full_lap" class="cpp numberLines"><code>#include &lt;common/defs.hpp&gt;
#include &lt;stencil-composition/stencil-composition.hpp&gt;

using namespace gridtools;
using namespace gridtools::enumtype;
using namespace gridtools::expressions;

constexpr static gridtools::dimension&lt; 1 &gt; i;
constexpr static gridtools::dimension&lt; 2 &gt; j;
constexpr static gridtools::dimension&lt; 3 &gt; k;

#ifdef __CUDACC__
using backend_t = backend&lt; Cuda, structured, Block &gt;;
using layout_t = gridtools::layout_map&lt; 2, 1, 0 &gt;;
#else
using backend_t = backend&lt; Host, structured, Block &gt;;
using layout_t = gridtools::layout_map&lt; 0, 1, 2 &gt;;
#endif

using storage_info_t = backend_t::storage_info&lt; 0, layout_t &gt;;
using storage_t = backend_t::storage_type&lt; double, storage_info_t &gt;::type;
/***/
using lower_domain = interval&lt; level&lt; 0, -1 &gt;, level&lt; 1, -1 &gt; &gt;;
using upper_domain = interval&lt; level&lt; 1, 1 &gt;, level&lt; 2, -1 &gt; &gt;;
using full_domain = interval&lt; level&lt; 0, -1 &gt;, level&lt; 2, -1 &gt; &gt;;

using axis = interval&lt; level&lt; 0, -2 &gt;, level&lt; 2, 1 &gt; &gt;;
/***/
struct lap_function {
    using in = in_accessor&lt; 0, extent&lt; -1, 1, -1, 1 &gt; &gt;;
    using lap = inout_accessor&lt; 1 &gt;;

    using arg_list = boost::mpl::vector&lt; in, lap &gt;;

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, full_domain) {
        eval(lap(i, j, k)) = -4. * eval(in(i, j, k)) /***/
                             + eval(in(i + 1, j, k)) /***/
                             + eval(in(i, j + 1, k)) /***/
                             + eval(in(i - 1, j, k)) /***/
                             + eval(in(i, j - 1, k));
    }
};
/***/
#include &lt;stencil-composition/structured_grids/call_interfaces.hpp&gt;
struct smoothing_function_3 {
    using phi = in_accessor&lt; 0 &gt;;
    using lap = in_accessor&lt; 1, extent&lt; -1, 1, -1, 1 &gt; &gt;;
    using out = inout_accessor&lt; 2 &gt;;

    using arg_list = boost::mpl::vector&lt; phi, lap, out &gt;;

    constexpr static double alpha = 0.5;

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, lower_domain) {
        eval(out(i, j, k)) = eval(phi(i, j, k)) -
                             alpha *                               /***/
                                 call&lt; lap_function, full_domain &gt; /***/
                                 ::with(eval, lap());
    }

    template &lt; typename Evaluation &gt;
    GT_FUNCTION static void Do(Evaluation const &amp;eval, upper_domain) {
        eval(out(i, j, k)) = eval(phi(i, j, k));
    }
};
/***/
int main() {
    uint_t Ni = 10;
    uint_t Nj = 12;
    uint_t Nk = 20;
    uint_t kmax = 10;

    storage_info_t info(Ni, Nj, Nk);

    int bs = 2; // boundary size
    halo_descriptor boundary_i(bs, bs, bs, Ni - bs - 1, Ni);
    halo_descriptor boundary_j(bs, bs, bs, Nj - bs - 1, Nj);
    /***/
    using temp_storage_t = /***/
        backend_t::temporary_storage_type&lt; double, storage_info_t &gt;::type;

    storage_t phi(info);
    storage_t phi_new(info);

    using arg_phi = arg&lt; 0, storage_t &gt;;
    using arg_phi_new = arg&lt; 1, storage_t &gt;;
    using arg_lap = arg&lt; 2, temp_storage_t &gt;;

    using arg_list = boost::mpl::vector&lt; arg_phi, arg_phi_new, arg_lap &gt;;
    aggregator_type&lt; arg_list &gt; /** */
        domain(boost::fusion::make_vector(&amp;phi, &amp;phi_new));

    grid&lt; axis &gt; my_grid(boundary_i, boundary_j);
    my_grid.value_list[0] = 0;
    my_grid.value_list[1] = kmax;
    my_grid.value_list[2] = Nk - 1;

    auto smoothing = make_computation&lt; backend_t &gt;(           /***/
        domain,                                               /***/
        my_grid,                                              /***/
        make_multistage(                                      /***/
            execute&lt; forward &gt;(),                             /***/
            make_stage&lt; lap_function &gt;(arg_phi(), arg_lap()), /***/
            make_stage&lt; smoothing_function_3 &gt;(               /***/
                arg_phi(),                                    /***/
                arg_lap(),                                    /***/
                arg_phi_new())                                /***/
            ));                                               /***/
    /***/
    smoothing-&gt;ready();
    smoothing-&gt;steady();

    smoothing-&gt;run();

    smoothing-&gt;finalize();
}</code></pre>
<h2 id="how-to-pass-the-alpha-global-accessors">How to pass the <span class="math inline"><em>α</em></span>: Global accessors</h2>
<h2 id="distributing-the-work-gcl">Distributing the work: GCL</h2>
<h2 id="boundary-conditions">Boundary conditions</h2>
<h1 id="storages-1">Storages</h1>
<h2 id="simple-use-and-multidimensional-fields">Simple use and multidimensional fields</h2>
<h2 id="ghost-dimensions">Ghost dimensions</h2>
<h2 id="fields">Fields</h2>
<h2 id="gpu-storages">GPU storages</h2>
<h2 id="detailed-storage-configuration">Detailed storage configuration</h2>
<h1 id="dsl-introduction">DSL introduction</h1>
<h2 id="syntax-for-user-operators">Syntax for User Operators</h2>
<h3 id="detailed-syntax-dimensions-expressions-offsets-of-accessors">Detailed syntax: , (), dimensions, expressions, offsets of accessors</h3>
<h2 id="parallelization-model-stages-and-multistages">Parallelization Model: Stages and MultiStages</h2>
<h2 id="preparing-arguments-storage-placeholders">Preparing arguments: storage placeholders</h2>
<h2 id="vertical-regions-and-vertical-boundary-conditions">Vertical regions and vertical boundary conditions</h2>
<h2 id="use-of-temporaries">Use of temporaries</h2>
<h2 id="composing-stencils">Composing Stencils</h2>
<h2 id="irregular-grids-syntax">Irregular Grids Syntax</h2>
<h1 id="stencil-functions">Stencil Functions</h1>
<h1 id="conditional-stencils">Conditional Stencils</h1>
<h1 id="reductions">Reductions</h1>
<h1 id="details-for-performance">Details for performance</h1>
<h2 id="fusion-and-organization-of-stages">Fusion and organization of stages</h2>
<h2 id="software-managed-caches">Software Managed Caches</h2>
<p>Software managed caches are a very important functionality of <span class="math inline"><em>GridTools</em></span> in order to exploit performance for stencils on computing architectures, like NVIDIA GPUs, where cache of data is not automatic. A significant optimization of the stencils using <span class="math inline"><em>GridTools</em></span> is achieved by means of an increase of the data locality of the stencil algorithms, for which detecting data reuse patterns and caching the corresponding fields is essential for a good performance.</p>
<p>Since GPUs require to explicit express in the code the use of the different memory hierarchies (i.e. shared memory, registers, texture cache... ) <span class="math inline"><em>GridTools</em></span> provides a special syntax to express the data reuse patterns. The syntax is independent of the type of scratch pad used by the library to store data and depends only on the access patterns of that field by the stencil methods. The main syntax for caching certain fields of a <code>computation</code> is shown below</p>
<pre class="cpp"><code>auto comp = make_computation&lt; BACKEND &gt;(
    domain,
    grid,
    make_multistage(
        execute&lt; forward &gt;(),
        define_caches(cache&lt; IJ, local &gt;(p_f1(), p_f2())),
        make_stage&lt; lap_function &gt;(p_f1(), p_f2(), p_in()),
        make_stage&lt; lap_function &gt;(p_out(), p_f1(), p_f2())
    )
);</code></pre>
<p>The cache DSL elements are enclosed into a <code>define_caches</code> construct, that accept any number of <code>cache</code> constructs. At the same time, each <code>cache</code> construct can specify multiple fields that shared the same access pattern.</p>
<p>The <code>cache</code> construct adheres to the following syntax:</p>
<pre><code>cache&lt; cache_type, io_policy, [interval] &gt;( p_arg) </code></pre>
<p>There are multiple type of caches that can be used for different data reuse pattern situations:</p>
<ol style="list-style-type: decimal">
<li><p>IJ caches: cache fields whose access pattern lies in the IJ-plane</p></li>
<li><p>K caches: cache field whose access pattern is restricted to the K-plane</p></li>
<li><p>bypass: Special cache-type that express null or very little reuse within the stencil</p></li>
</ol>
<p>Additionally the cache</p>
<h2 id="alignment-halo-of-storages">Alignment: halo of storages</h2>
<h2 id="expandable-parameters">Expandable parameters</h2>
<h1 id="halo-updates">Halo Updates</h1>
<h2 id="boundary-conditions-1">Boundary Conditions</h2>
<h2 id="halo-exchanges">Halo Exchanges</h2>
<h1 id="data-management">Data management</h1>
<h1 id="interfacing-to-other-programming-languages">Interfacing to other programming languages</h1>
<h1 id="benchmarking-stencils">Benchmarking stencils</h1>
<h1 id="serialbox-and-porting-your-reference-application">SerialBox and porting your reference application</h1>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>With the Cuda backend we allocate memory on host and device. In the standard use-cases you don’t need to update the data manually, but you still have the option to do so.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>At this point the reader should be able to complete the missing parts in the setup.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>There are other ways to accomplish this behavior. The extra computation can be avoided by defining the Laplacian only on the interval where we need it; the temporary could be avoided by a bit of code duplication, however there is no good reason to do it.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
