.. _stencil-composition:

Stencil Composition
========================

.. _placeholders:

------------------------------------------
Preparing arguments: storage placeholders
------------------------------------------

.. _vertical_regions:

---------------------------------------------------
Vertical regions and vertical boundary conditions
---------------------------------------------------

-------------------
Use of temporaries
-------------------

The main component of |GT| provide the capability of composing
different `elementary stencils`. An `elementary stencil` is the
application of a single :ref:`stencil operator<stencil_operators>` to an
:term:`iteration space<iterationspace>` . The ability to fuse multiple elementary
stencils allows the |GT| library to improve the memory locality of
the computation by taking advantage of the produce consumer
relations. In |GT| terminology we use the term `stage` to refer to an
elementary stencil i when it is composed with other operations.

The result of a composition is a `multi-stage computation`, also
called `multi-stage stencil` or simply `stencil`. For reason of
uniformity, a multi-stage computation with a singe stage, is still
called a multi-stage, since the composition is generally assumed to
take a list of stages, even if the stage is just one. 

.. note::

 This decision put the emphasis on the fact that composition
 is considered the main feature of |GT|. If your application
 is made of a simple stencil, or stencils that cannot be 
 composed (see below), then |GT| may be not the right solution
 for you.

|GT| allows multi-stage computations to be composed. The final
composition, with the addition of a
:term:`grid<Grid>` and a :term:`data field pack<DataFieldPack>` is simply called a |GT|
`computation`, or simply `computation`.

Before entering the details of what can be composed and what not, let
us show first an example of a stencil composition: a simple horizontal
diffusion stencil.

First we need to specify the stages. A stage is specified by
indicating a :ref:`stencil operator<stencil_operators>` and some
:ref:`placeholders<placeholders>` to its arguments. The placeholders are
alias to the actual arguments and are used to compute the data
dependencies of the computation independently of the actual data
fields that will be accessed by the computation. The syntax for
specifying a stage uses an helper function called ``make_stage``:

.. code-block:: gridtools

 auto stage = make_stage< operator >(plc0(), plc1(), ...);

Where the `operator` is the stencil operator of the stage and the
`plc` s are the placeholders. The number and the intent of the
placeholders depend on the
:ref:`stencil operator interface<stencil_operators>`.

A multi-stage computation is a concatenation of stages, plus the
indication of the [execution strategy](#gridtools-execution-model) to
be used for all the stages as in the following example for a diffusion
operator.  

.. code-block:: gridtools

 auto multi_stage = make_multistage(
    execute< forward >(),
    make_stage< lap_operator >(p_lap(), p_in()),
    make_stage< flx_operator >(p_flx(), p_in(), p_lap()),
    make_stage< fly_operator >(p_fly(), p_in(), p_lap()),
    make_stage< out_operator >(p_out(), p_in(), p_flx(), p_fly())
 );

.. note:: 

 It is not possible to make a multi-stage
 computation with stages of different execution orders.

The data-dependence analysis of |GT| will determine the producer
consumer relations and the extents at which each data field will be
accessed. This information is then passed to the architecture specific
backend for the execution. 

Before the computation can be executed, an aggregator, containing the
references to the actual data to be processed and the grid, specifying
the iteration space, must be provided. The final example is:

.. code-block:: gridtools

 horizontal_diffusion = make_computation< BACKEND >(
    aggregator, grid,
    make_multistage(
        execute< forward >(),
        make_stage< lap_operator >(p_lap(), p_in()),
        make_stage< flx_operator >(p_flx(), p_in(), p_lap()),
        make_stage< fly_operator >(p_fly(), p_in(), p_lap()),
        make_stage< out_operator >(p_out(), p_in(), p_flx(), p_fly())
    )
 );


where ``BACKEND`` specifies the backend that will execute the
computation.

The execution of the stages are assumed to happen one after the other
in the program order. This is quite important, since the data
dependence is performed with this assumption. Some architectures
provide different types of synchronization, and a user may gain a
little more performance if they are more specific in the expression of
the dependencies. For instance, we can assume the the ``flx_operator``
and ``fly_operator`` do not have producer-consumer dependencies the user
can specify that they are independent:

.. code-block:: gridtools

 horizontal_diffusion = make_computation< BACKEND >(
    aggregator, grid,
    make_multistage(
        execute< forward >(),
        make_stage< lap_operator >(p_lap(), p_in()),
        make_independent(
            make_stage< flx_operator >(p_flx(), p_in(), p_lap()),
            make_stage< fly_operator >(p_fly(), p_in(), p_lap())),
        make_stage< out_operator >(p_out(), p_in(), p_flx(), p_fly())
    )
 );

``make_independent`` does not have impact on the data-dependence
analysis but, potentially, only on the execution schedule.

In general ``make_computation`` has the following signature:

.. code-block:: gridtools
 
 make_computation< BACKEND >(aggregator, grid, multi_stage0[, other_multi_stages]);

A computation can then incorporate multiple multi-stage computations
and they may have different execution policies. This is very useful
for implementing computations that require two vertical swipes, one
ascending and one descending, but has to be used with care. Before
explaining the rules for using this feature, we provide a simple
example of the syntax in this vertical advenction example:

.. code-block:: gridtools

 vertical_advection = make_computation< BACKEND >
    ( domain, grid,
      make_multistage( execute< forward >(),
                       make_stage< forward_op >(p_utens_stage(), p_wcon()),
    ),
    make_multistage( execute< backward >(),
                     make_stage < backward_op >(p_utens_stage(), p_u_pos())
    )
 );


This option is particularly useful on multi-core machines with caches,
since the backend there can actively pass information between the two
stages thus improving substantially the performance.


Again the multi-stages in the same computation will be
executed,logically in program order.  Two multi-stage computations can
be concatenated if the outputs of the stages that are used as input of
the following obey the following rule: Let ``u`` be the output of a
stage ``S0`` that is input the stage ``S1``. The extent at which ``u`` is
accessed by ``S1`` must be the point-extent, that is the access of ``u``
is point-wise, so no offsets of ``u`` can be accessed. This is because
the parallel execution of the stages can produce non deterministic
results otherwise. Certain backends do not fuse multiple multi-stage
computations, so this effect could be not visible, but for
portability, it is important that this rule is understood.

There are other details that pertains :ref:`placeholders<placeholders>`,
:term:`grid<Grid>`,  :term:`data field pack<DataFieldPack>` and also other |GT|
constructs that can greatly improve performance of the computations,
especially :ref:`software managed caches<caches>`


.. include:: irregular_grids.hrst 
