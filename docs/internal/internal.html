

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Internal Documentation &mdash; GridTools 0.22.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/css/cscs.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GridTools 0.22.0 documentation" href="../index.html"/>
        <link rel="next" title="Frequently Asked Questions" href="../faq/faq.html"/>
        <link rel="prev" title="Glossary" href="../glossary/glossary.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> GridTools
          

          
            
            <img src="../_static/logo.svg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.22
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/user_manual.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/glossary.html">Glossary</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Internal Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#indexing-algorithm-pointer-offset-computation">Indexing Algorithm (Pointer Offset Computation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#old-indexing-approach">Old Indexing Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#issues-regarding-temporaries">Issues Regarding Temporaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-pointer-change">Base Pointer Change</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-temporaries-with-different-halo">Multiple Temporaries with Different Halo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passing-huge-types-down-to-the-offset-computation">Passing Huge Types Down to the Offset Computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#updated-indexing-algorithm">Updated Indexing Algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-dependence-analysis-in-gridtools">Data Dependence Analysis in GridTools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-very-simple-example">A very simple example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-more-complex-example">A more complex example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#catching-bad-dependencies">Catching bad dependencies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#design-of-grid-topology-for-irregular-grids">Design of Grid Topology for Irregular Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unstructured-mesh">Unstructured Mesh</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#splitters">Splitters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interval-specific-do-methods">Interval Specific Do Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loop-interval-computation">Loop Interval Computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#do-method-overloads">Do Method Overloads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#do-method-lookup-map">Do Method Lookup Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prototype">Prototype</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GridTools</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Internal Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/internal/internal.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="internal-documentation">
<span id="internal"></span><h1>Internal Documentation<a class="headerlink" href="#internal-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="indexing-algorithm-pointer-offset-computation">
<h2>Indexing Algorithm (Pointer Offset Computation)<a class="headerlink" href="#indexing-algorithm-pointer-offset-computation" title="Permalink to this headline">¶</a></h2>
<p>On the <cite>GridTools</cite> frontend side we are using <code class="docutils literal"><span class="pre">storage_info</span></code>, <code class="docutils literal"><span class="pre">data_store</span></code> and <code class="docutils literal"><span class="pre">data_view</span></code> objects when we deal with data.
Once this information is passed to the <code class="docutils literal"><span class="pre">aggregator_type</span></code> and the <code class="docutils literal"><span class="pre">intermediate</span></code> the information how to access the different
fields is extracted. This means we extract the raw pointers to the data from the <code class="docutils literal"><span class="pre">data_store</span></code> objects and the stride
information is from the <code class="docutils literal"><span class="pre">storage_info</span></code> objects. The pointers and the strides information are stored in the <code class="docutils literal"><span class="pre">iterate_domain</span></code>.
In order to save registers and not wasting resources different <code class="docutils literal"><span class="pre">storage_info</span></code> instances with a matching ID parameter are
treated as a single instance. This can be done because the contained stride information has to be the same if the ID is equal.
<a class="reference internal" href="#fig-flow"><span class="std std-numref">Fig. 10</span></a> shows the storage flow from the frontend to the backend. In this example three data
stores are created by the user, and two temporaries are created in the <code class="docutils literal"><span class="pre">intermediate</span></code>. The <code class="docutils literal"><span class="pre">intermediate</span></code> is extracting the needed
information from the <code class="docutils literal"><span class="pre">data_store</span></code> and <code class="docutils literal"><span class="pre">storage_info</span></code> objects and is feeding the backend with raw data pointers and stride information.</p>
<div class="figure" id="id1">
<span id="fig-flow"></span><img alt="../_images/flow.png" src="../_images/flow.png" />
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Transformations applied to storages while passing from frontend to backend.</span></p>
</div>
<div class="section" id="old-indexing-approach">
<h3>Old Indexing Approach<a class="headerlink" href="#old-indexing-approach" title="Permalink to this headline">¶</a></h3>
<p>As seen before the backend contains stride information and raw data pointers. Unfortunately this is not enough.
The backend additionally has to store an offset (called index). The reason for this is that the compute domain is
split up into several blocks. Each block is passed to a GPU streaming multiprocessor that contains several cores.
Each core has to know its position within the block in order to compute at the right point. So additionally to the
stride and pointer information that is shared per block an index is stored per core. <a class="reference internal" href="#fig-block-contents"><span class="std std-numref">Fig. 11</span></a>
shows the contents of two independent blocks. As visible the stride and pointer information is the same but the index is different for each
thread.</p>
<div class="figure" id="id2">
<span id="fig-block-contents"></span><img alt="../_images/block_contents.png" src="../_images/block_contents.png" />
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">Old <cite>GridTools</cite> indexing approach.</span></p>
</div>
<p>The index is computed as follows. If there is no <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> the index will be</p>
<div class="math">
\[\begin{split}\begin{align} i &amp;= (block\_id\_x * block\_size\_x + thread\_id\_x) * stride\_i \\\\ &amp;+ (block\_id\_y * block\_size\_y + thread\_id\_y) * stride\_j \end{align}\end{split}\]</div>
<p>In case of a <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> the index is shifted into the right direction (like visible in <a class="reference internal" href="#fig-block-contents"><span class="std std-numref">Fig. 11</span></a>).</p>
</div>
<div class="section" id="issues-regarding-temporaries">
<h3>Issues Regarding Temporaries<a class="headerlink" href="#issues-regarding-temporaries" title="Permalink to this headline">¶</a></h3>
<p>Temporary storages share the same <code class="docutils literal"><span class="pre">storage_info</span></code> because they all have the same size. The problem with temporaries is that
computations in the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> region have to be redundant because we don’t know when the data will be available. To solve the
problem with redundant computations the temporary storages, that are allocated in the <code class="docutils literal"><span class="pre">intermediate</span></code>, are extended by a certain
number of elements. The size of the CUDA block is known beforehand and also the size of the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> and the number of blocks/threads
is known. With this information an extended temporary storage can be instantiated. For performance reasons we want the first
non-<a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> data point of each block to be in an aligned memory position. Therefore we add a certain number of padding elements between
the blocks. <a class="reference internal" href="#fig-temporary"><span class="std std-numref">Fig. 12</span></a> compares the non-aligned versus the aligned storages. The green dots
are marking the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> points. It can be seen that each block has its own <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> region. The blue squares are padding elements and the yellow
squares are data points. As visible on the right part of the drawing the first data point should be in an aligned memory position.
In order to achieve this padding elements are added between the blocks.</p>
<div class="figure" id="id3">
<span id="fig-temporary"></span><img alt="../_images/temporary.png" src="../_images/temporary.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Alignment issues on temporary storages.</span></p>
</div>
</div>
<div class="section" id="base-pointer-change">
<h3>Base Pointer Change<a class="headerlink" href="#base-pointer-change" title="Permalink to this headline">¶</a></h3>
<p>When the aligned temporary improvement was introduced the logic in the
backend was slightly  changed. As shown before the  backend contains a
pointer to each  of the <code class="docutils literal"><span class="pre">storage</span></code>. In combination with  an index the
cuda thread  can identify its  compute position. When  temporaries are
used one cannot just simply use a base pointer for all the cuda blocks
and just  multiply the current  block index  with the block  size like
shown in  the formula above. The  base pointer has to  be computed per
block. So each block contains a pointer to its own temporary storage.
See <a class="reference internal" href="#fig-temporary-block-contents"><span class="std std-numref">Fig. 13</span></a>.</p>
<div class="figure" id="id4">
<span id="fig-temporary-block-contents"></span><img alt="../_images/temporary_block_contents.png" src="../_images/temporary_block_contents.png" />
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Per-block private base pointers.</span></p>
</div>
<p>There is no difference in resource consumption when using the changed base pointer approach. It was mainly introduced for
convenience and in order to smoothly integrate the aligned temporary block improvement.</p>
</div>
<div class="section" id="multiple-temporaries-with-different-halo">
<h3>Multiple Temporaries with Different Halo<a class="headerlink" href="#multiple-temporaries-with-different-halo" title="Permalink to this headline">¶</a></h3>
<p>Formerly <cite>GridTools</cite> used one <code class="docutils literal"><span class="pre">storage_info</span></code> per temporary storage. This is convenient but consumes more resources than needed.
Therefore it was replaced by the more resource efficient “one <code class="docutils literal"><span class="pre">storage_info</span></code> for all temporaries” solution.
The temporaries are all having the same size. So the stride information can be shared in the backend. The only problem occurs
when different temporaries (with the same size, as mentioned before) are accessing different <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a>. The base pointer is set
correctly only for the temporary that is using the maximum <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>. All the other temporaries are unaligned by $max_halo - used_halo$
points. This happens for instance when computing the horizontal diffusion. The flx and fly temporaries use different <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a>. In this case
the temporary written in the flx stage will be properly aligned because it is accessing the maximum <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> in the aligned direction (x direction). The second temporary written in the fly stage will be unaligned because it does not use the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> points in x-direction. In order to fix this alignment mistake
the missing offset is added when setting the base pointer. The information that is passed to the algorithm that extracts the base pointer knows about
the used <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> of each <code class="docutils literal"><span class="pre">storage</span></code> and also the maximum <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> in the alinged direction. A value of $max_halo - used_halo$ is added to each base pointer.</p>
</div>
<div class="section" id="passing-huge-types-down-to-the-offset-computation">
<h3>Passing Huge Types Down to the Offset Computation<a class="headerlink" href="#passing-huge-types-down-to-the-offset-computation" title="Permalink to this headline">¶</a></h3>
<p>In order to fix the alignment when using different <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a> we have to pass a lot of type information from the <code class="docutils literal"><span class="pre">intermediate</span></code> down to the backend. This is exhaustive for the compiler and the performance suffers. This could lead to problems, especially when trying to compile computations with many stages and
a high number of fields.</p>
</div>
<div class="section" id="updated-indexing-algorithm">
<h3>Updated Indexing Algorithm<a class="headerlink" href="#updated-indexing-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The new indexing approach tries to avoid the strategy of setting the base pointer to the first point of the block. The new approach is to set the
pointer to the first non-<a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> point of the block. The method that is setting the index of each cuda thread has to be modified. <a class="reference internal" href="#fig-new-temporary-block-contents"><span class="std std-numref">Fig. 14</span></a> shows the new indexing. As shown, the first non <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> point is used as base pointer. The index
is also modified in order to point to the correct data location.</p>
<div class="figure" id="id5">
<span id="fig-new-temporary-block-contents"></span><img alt="../_images/new_temporary_block_contents.png" src="../_images/new_temporary_block_contents.png" />
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Per-block private base pointers to first non-<a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a> point of the block.</span></p>
</div>
</div>
</div>
<div class="section" id="data-dependence-analysis-in-gridtools">
<h2>Data Dependence Analysis in GridTools<a class="headerlink" href="#data-dependence-analysis-in-gridtools" title="Permalink to this headline">¶</a></h2>
<p>(copied from the wiki)</p>
<p>A multistage stencil is a sequence of stages.
Each stage is (basically) made of a stencil operator and a list of placeholders.
Each placeholders is associated to the arguments in the param_list of the stencil operator positionally,
that is, as it would happen if the placeholders were passed to the stencil operator according to the param_list.
The param_list lists accessors, and each accessor have an extent. Each accessor has also an intent,
which represents the use the stencil operator is going to make of the data, either read-only or read-write.</p>
<p>So, given a stage we can associate to each placeholder an extent and an intent, simply by scanning the accessors in the param_list of the stage.</p>
<p>Consider the last stage in a multistage computation. This will have one (or more) output accessors in the param_list of the stencil operator,
so one (or more) placeholders in the list. This output will be computed by accessing the inputs within the extents that are specified in the corresponding accessors.
Now, let’s move to the stage just before that.
Some of its inputs may be used by the last stage as inputs.
This means that those outputs must be computed in a set of points that will be consumed by the next stage.</p>
<div class="section" id="a-very-simple-example">
<h3>A very simple example<a class="headerlink" href="#a-very-simple-example" title="Permalink to this headline">¶</a></h3>
<p>Let us consider an example (in 1D for simplicity). Suppose we have the following concatenation of stages,
where we write at the left the outputs and on the right, with an associated extent, are the inputs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">&lt;-</span> <span class="n">f0</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">&lt;-</span> <span class="n">f1</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">d</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>We call the arguments placeholders, to be closer to the gridtools algorithm. We have 5 placeholders and we start with an initial map such as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Now we visit our sequence of stages from the last to the first.
The last computes <code class="docutils literal"><span class="pre">e</span></code> and then needs <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">d</span></code>, and <code class="docutils literal"><span class="pre">c</span></code> in different extents. We update the map as follow:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Next we examine <code class="docutils literal"><span class="pre">f1</span></code>. It writes <code class="docutils literal"><span class="pre">d</span></code>, and since <code class="docutils literal"><span class="pre">d</span></code> is needed in an interval <code class="docutils literal"><span class="pre">&lt;-2,2&gt;</span></code> by <code class="docutils literal"><span class="pre">f2</span></code>,
we need to update it’s inputs that need now to be read at an extent that is <code class="docutils literal"><span class="pre">&lt;-2,2&gt;</span> <span class="pre">+</span> <span class="pre">&lt;x,y&gt;</span></code>, where <code class="docutils literal"><span class="pre">&lt;x,y&gt;</span></code> is the extent of an input and the <code class="docutils literal"><span class="pre">+</span></code> operation corresponds to the following operation: <code class="docutils literal"><span class="pre">&lt;x,y&gt;</span> <span class="pre">+</span> <span class="pre">&lt;u,v&gt;</span> <span class="pre">=</span> <span class="pre">&lt;x+u,</span> <span class="pre">y+v&gt;</span></code>. If the extent needed for the inputs are smaller than the one contained in the map already, we do not update the map, since the needed values are already there. We do it by using the <code class="docutils literal"><span class="pre">mee</span></code> function that returns the minimum enclosing extent of two extents. So now we update the map as follow:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Now to the last stage to examine: <code class="docutils literal"><span class="pre">f0</span></code>. It writes <code class="docutils literal"><span class="pre">a</span></code> and needs <code class="docutils literal"><span class="pre">b&lt;-1,2&gt;</span></code> and <code class="docutils literal"><span class="pre">c&lt;0,1&gt;</span></code>. According the the map, <code class="docutils literal"><span class="pre">a</span></code> is needed in <code class="docutils literal"><span class="pre">&lt;-1,2&gt;</span></code> so</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The fields <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">d</span></code> are written and the read. They are eligible to be temporary fields. <code class="docutils literal"><span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">c</span></code> are inputs,
and they are needed in <code class="docutils literal"><span class="pre">&lt;-4,3&gt;</span></code> and <code class="docutils literal"><span class="pre">&lt;-3,4&gt;</span></code> respectively. So the number of “halos” around them should be appropriate to avoid access violations.
The field <code class="docutils literal"><span class="pre">e</span></code> is the output and it’s written in a single point.</p>
<p>If we compute <code class="docutils literal"><span class="pre">f2</span></code> in a point, we need to compute <code class="docutils literal"><span class="pre">f1</span></code> in <code class="docutils literal"><span class="pre">&lt;-2,2&gt;</span></code>, since this will produce the values needed by <code class="docutils literal"><span class="pre">f2</span></code>.
We then need to compute <code class="docutils literal"><span class="pre">f0</span></code> in <code class="docutils literal"><span class="pre">&lt;-1,2&gt;</span></code> to produce the values needed for <code class="docutils literal"><span class="pre">a</span></code>.</p>
</div>
<div class="section" id="a-more-complex-example">
<h3>A more complex example<a class="headerlink" href="#a-more-complex-example" title="Permalink to this headline">¶</a></h3>
<p>The next example is very similar to the previous one, but now the second stage uses <code class="docutils literal"><span class="pre">a</span></code> instead of <code class="docutils literal"><span class="pre">c</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">&lt;-</span> <span class="n">f0</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">&lt;-</span> <span class="n">f1</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">a</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">d</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>The map, then, after examining <code class="docutils literal"><span class="pre">f2</span></code> is as before</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>When we examine <code class="docutils literal"><span class="pre">f1</span></code>, however, the extents become:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;+&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>When we move to <code class="docutils literal"><span class="pre">f0</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;+&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>So, now, to compute <code class="docutils literal"><span class="pre">f2</span></code> in a point we need to compute <code class="docutils literal"><span class="pre">f1</span></code> in <code class="docutils literal"><span class="pre">&lt;-2,2&gt;</span></code> and <code class="docutils literal"><span class="pre">f0</span></code> in <code class="docutils literal"><span class="pre">&lt;-3,4&gt;</span></code>. Note that, when <code class="docutils literal"><span class="pre">f2</span></code> access <code class="docutils literal"><span class="pre">a</span></code> in <code class="docutils literal"><span class="pre">&lt;-1,</span> <span class="pre">2&gt;</span></code>,
those values have been computed in abundance to allow the computation of <code class="docutils literal"><span class="pre">f1</span></code>.</p>
</div>
<div class="section" id="catching-bad-dependencies">
<h3>Catching bad dependencies<a class="headerlink" href="#catching-bad-dependencies" title="Permalink to this headline">¶</a></h3>
<p>Let’s consider another variation on the same example. Now <code class="docutils literal"><span class="pre">f1</span></code> writes into <code class="docutils literal"><span class="pre">c</span></code>, and <code class="docutils literal"><span class="pre">d</span></code> becomes an input.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">&lt;-</span> <span class="n">f0</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">&lt;-</span> <span class="n">f1</span><span class="p">(</span><span class="n">b</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">a</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">d</span><span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>As before the map after examining <code class="docutils literal"><span class="pre">f2</span></code> is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>When we analyze <code class="docutils literal"><span class="pre">f1</span></code> we have</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;+&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>And then <code class="docutils literal"><span class="pre">f0</span></code></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="n">b</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;+&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">c</span> <span class="o">-&gt;</span> <span class="n">mee</span><span class="p">(</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;+&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>
<span class="n">d</span> <span class="o">-&gt;</span> <span class="o">&lt;-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">e</span> <span class="o">-&gt;</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>But now we have a problem, if we apply the previous strateg. <code class="docutils literal"><span class="pre">f1</span></code> is computed to compute <code class="docutils literal"><span class="pre">c</span></code> in <code class="docutils literal"><span class="pre">&lt;-2,4&gt;</span></code>,
the extent associated by the map. A next element of the output would then read the modified values of <code class="docutils literal"><span class="pre">c</span></code> and
this is probably wrong. We need to catch this as a problem.
We cannot write into a field that is accessed in an extent different than <code class="docutils literal"><span class="pre">&lt;0,0&gt;</span></code> in a previous stage.
We need a check for this, but it is not yet implemented.</p>
</div>
</div>
<div class="section" id="design-of-grid-topology-for-irregular-grids">
<h2>Design of Grid Topology for Irregular Grids<a class="headerlink" href="#design-of-grid-topology-for-irregular-grids" title="Permalink to this headline">¶</a></h2>
<p>The <cite>GridTopology</cite> concept provides:</p>
<ol class="arabic simple">
<li>Connectivity information to neighbours in the same and different <cite>LocationType</cite>’s.</li>
<li>Storage maker functionality</li>
</ol>
<p>The icosahedral <cite>grid</cite> class requires a class, as a template parameter, that implements a <cite>GridTopology</cite></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Axis</span><span class="p">,</span> <span class="k">typename</span> <span class="n">GridTopology</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">grid</span>
</pre></div>
</div>
<p>and can be constructed additionally with a runtime instance of the <cite>GridTopology</cite>, depending on whether
the concrete implementation of that <cite>GridTopology</cite> requires runtime connectivity information.</p>
<p>Currently there are two concrete implementations of the <cite>GridTopology</cite>:</p>
<p>1. The <cite>icosahedral_topology</cite> provides connectivity information at compile time, for icosahedral/octahedral grid layouts where all
the connectivity information can be derived at compiled time from the parallelogram structures based on simple stride rules.</p>
<p>An example of such structured index layout of the icosahedral grid parallelograms is shown in <a class="reference internal" href="#fig-ico-indices"><span class="std std-numref">Fig. 15</span></a>,
where the parallelogram can be indexed with three coordinates <cite>i</cite> and <cite>j</cite> and a color that identifies downward/upward triangles.
This particular data layout assumes an order in the dimensions like i-c-j (being <cite>i</cite> the stride - 1 dimension).
As an example, the cell with index 14, can be accessed with <cite>{i, c, j}</cite> coordinates <cite>{2, 0, 1}</cite>.
A similar scheme of indexing for <cite>edges</cite>, and <cite>vertices</cite> is developed.
All neighbour indexes of any cell/edge/vertex as well as connectivity to different <cite>LocationType</cite> can be express with simple
offset rules.</p>
<p>For example, the neighbor indices of any cell can be computed with the following rules:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">{{</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">},</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">}}</span> <span class="k">for</span> <span class="n">downward</span> <span class="n">triangle</span> <span class="p">(</span><span class="n">color</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{{</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">},</span> <span class="p">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">},</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">upward</span> <span class="n">triangle</span>
</pre></div>
</div>
<p>Similar rules are derived for connectivities among different location types.</p>
<div class="figure" id="ico-indices">
<span id="fig-ico-indices"></span><a class="reference internal image-reference" href="../_images/ico_indices.png"><img alt="../_images/ico_indices.png" src="../_images/ico_indices.png" style="width: 588.8000000000001px; height: 341.40000000000003px;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Structured index layout for icosahedral grid</span></p>
</div>
<p>Since all offset rules are based on the structured of the icosahedral parallelograms, and do not depend
on a particular runtime instance of the grid topology, they are derived at compile time.
These offsets rules can be extracted using the connectivity class API</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">SrcLocation</span><span class="p">,</span> <span class="k">typename</span> <span class="n">DestLocation</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">Color</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">connectivity</span>
</pre></div>
</div>
<p>For the icosahedral grid, the connectivity tables give access to the following 9 type of queries, depending on the <cite>from</cite> and <cite>to</cite> location types. See <a class="reference internal" href="#fig-location-type-opr"><span class="std std-numref">Fig. 16</span></a>.</p>
<div class="figure" id="id6">
<span id="fig-location-type-opr"></span><a class="reference internal image-reference" href="../_images/location_type_opr.png"><img alt="../_images/location_type_opr.png" src="../_images/location_type_opr.png" style="width: 654.6px; height: 467.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">All possible connectivity queries in an icosahedral grid.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Depending on the location type, there are different number of neighbour indices. For example <cite>from&lt;cell&gt;::to&lt;edge&gt;</cite> will return a tuple of three
edge indices. The order of those neighbours, is part of the API and is defined based on physical meaning of PDE operators.</p>
</div>
<p>2. The <cite>unstructured_mesh</cite> implements a <cite>GridTopology</cite> for grid layouts without a clear structure, and therefore runtime lookup tables
need to be used in order to define connectivities between the different <cite>LocationTypes</cite>.</p>
<p>Since the connectivity information is stored as lookup tables, the <cite>unstructured_mesh</cite> needs to accept in the ctr an Atlas mesh object,
that contains all the necessary lookup tables.
All 9 lookup tables are then stored in two type of (atlas data structure) tables: MultiBlockConnectivity and IrregularConnectivity.
The main difference is that the connectivity described with a MultiBlockConnectivity shows a uniform number of neighbours for each entry in the table,
while in the IrregularConnectivity, each entry can have a different number of neighbours.</p>
<div class="section" id="unstructured-mesh">
<h3>Unstructured Mesh<a class="headerlink" href="#unstructured-mesh" title="Permalink to this headline">¶</a></h3>
<p>The <cite>grid</cite> concept has a <cite>GridTopology</cite> type, that can be of two classes (as described above).
Additionally for the types of <cite>GridTopology</cite> that require a runtime information with the connectivity tables,
the <cite>grid</cite> also has an <cite>unstructured mesh</cite> instance of type</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">unstructured_mesh_t</span> <span class="o">=</span>
  <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">mpl</span><span class="o">::</span><span class="n">if_c</span><span class="o">&lt;</span><span class="n">is_unstructured_mesh</span><span class="o">&lt;</span><span class="n">GridTopology</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">GridTopology</span><span class="p">,</span> <span class="n">empty</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</pre></div>
</div>
<p>In case of having a <cite>GridTopology</cite> of <cite>icosahedral_topology</cite> the instance that gets instantiated is an empty class.</p>
<p>Later this <cite>unstructured_mesh</cite> will be passed to the <cite>iterate_domain</cite> that requires the connectivity information.</p>
</div>
</div>
<div class="section" id="splitters">
<h2>Splitters<a class="headerlink" href="#splitters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>This document introduces a prototype code used for the development of a new
stencil library. The prototype is based on an interval concept, which allows
the library user to split an axis of the stencil application domain into
arbitrary intervals. Using these intervals it shall be possible to define
interval specific stencil update functions. The prototype uses splitters in
order to sub-divide an axis. Splitters are ordered positions defined at
compile-time. Note that splitters only define an order but not yet an absolute
position. At runtime the splitters are placed at an absolute position, in
between two axis positions. Due to this staggered placement it is easier to
define loop direction independent intervals. Given the splitters we define
levels, which specify a position at an offset relative to a splitter. The
offset is a small positive or negative integral value limited by a predefined
maximum, e.g. 3. The zero offset is undefined as the splitters are not placed
in between two axis positions. Given two levels we define closed intervals,
which specify a loop direction independent range on the axis. See Figure 1 for
an example interval definition. Note that intervals are always defined in axis
direction, meaning the “from level” is placed before the “to level” in axis
direction.</p>
<div class="figure" id="id7">
<img alt="../_images/splitters_001.png" src="../_images/splitters_001.png" />
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">Splitters, levels and intervals</span></p>
</div>
<p>Figure 1 shows an axis divided by three splitters and an interval spanning the
range [5, 15]. Note that there are <code class="docutils literal"><span class="pre">N</span> <span class="pre">*</span> <span class="pre">(N-1)</span> <span class="pre">/</span> <span class="pre">2</span></code> intervals with N being the
total number of levels. In order to simplify the implementation the prototype
internally represents all levels using a unique integer index. Given a level
(splitter and offset) we can compute an index as splitter times number of offsets
per splitter plus offset index. The offset index is defined by a mapping of the offset
values in a positive and continuous range, i.e. the offsets [-2, -1, 1, 2] are
mapped to the offset indexes [0, 1, 2, 3]. Given an index we can compute a level
by dividing the index by the number of offsets per splitter. The result corresponds
to the level splitter while the remainder corresponds to the offset
index which can be mapped back to a level offset.</p>
<p>Note that the FunctorDoMethods.cpp for test purposes converts an integer range
into levels and back into indexes resulting in the following output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Index</span><span class="p">:</span> <span class="mi">0</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">1</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">2</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">3</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">4</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">5</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">6</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">7</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">8</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">9</span>        <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">10</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">11</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">12</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">13</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">14</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">15</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">16</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">17</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">18</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Index</span><span class="p">:</span> <span class="mi">19</span>       <span class="n">Level</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="interval-specific-do-methods">
<h3>Interval Specific Do Methods<a class="headerlink" href="#interval-specific-do-methods" title="Permalink to this headline">¶</a></h3>
<p>The stencil library user will define its update functions using functor objects
with interval specific Do methods. The Do method overloads allow defining an
interval specific update function for certain sub domains:</p>
<div class="figure" id="id8">
<img alt="../_images/splitters_002.png" src="../_images/splitters_002.png" />
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Functors with interval specific Do method overloads</span></p>
</div>
<p>Note that the functors in the listing define Do method overloads for boundary
levels as well as for larger axis sub domains. In order to avoid
inconsistencies we define the following rules: - The Do method intervals shall
not overlap - The Do method intervals shall be continuous, i.e. gaps are not
allowed As the Do method overloads are continuous we can use them in order to
compute the loop bounds. Essentially we want to loop from the first Do method
interval “from level” to the last Do method interval “to level”.</p>
</div>
<div class="section" id="loop-interval-computation">
<h3>Loop Interval Computation<a class="headerlink" href="#loop-interval-computation" title="Permalink to this headline">¶</a></h3>
<p>Given one or more functors the loop interval computation prepares the stencil
library loop execution. Figure 2 illustrates the loop interval computation
algorithm, which computes a list of maximal size loop intervals such that there
is a unique set of Do method overloads per loop interval. Using these loop
intervals the actual loop execution is a simple iteration over all intervals,
executing a nested loop over all functors for each interval. Thanks to the loop
interval definition we can work with the same set of Do method overloads on the
full loop interval.</p>
<div class="figure" id="id9">
<img alt="../_images/splitters_003.png" src="../_images/splitters_003.png" />
<p class="caption"><span class="caption-number">Fig. 19 </span><span class="caption-text">Loop interval computation algorithm (Do method overloads in black; computed loop intervals in red)</span></p>
</div>
<p>Note that the algorithm assumes that it is possible to query all Do method
overloads of a functor. The loop interval computation performs the following
steps: 1. Compute a Do method overload list for each functor 2. Compute a loop
interval list using the functor Do method lists 3. Compute a vector of functor
Do method overload pairs for every loop interval</p>
</div>
<div class="section" id="do-method-overloads">
<h3>Do Method Overloads<a class="headerlink" href="#do-method-overloads" title="Permalink to this headline">¶</a></h3>
<p>In order to compute a list of all functor Do method overloads, we iterate over
all intervals and store the ones which have a corresponding functor Do method
overload. Additionally we can check if the functor follows our rules, i.e. the
intervals do not overlap. The Do method overload algorithm works on the
following inputs: - Functor – Functor object - Axis – Maximal interval used for
the Do method overload search The following pseudo code  implements the Do
method overload algorithm:</p>
<div class="figure" id="id10">
<img alt="../_images/splitters_004.png" src="../_images/splitters_004.png" />
<p class="caption"><span class="caption-number">Fig. 20 </span><span class="caption-text">Functor Do method overload algorithm</span></p>
</div>
<p>Searching all possible Do method intervals has complexity O(N2). Unfortunately
we had to abandon this idea due to long compilation times. Therefore we
introduced a hack which allows speeding up the search. It is based on the fact
that the has_do implementation finds all Do methods of a functor which are
callable taking overload resolution into account. Therefore we added a
conversion constructor on the interval class which converts a from level into
an interval. Due to this implicit conversion we can search for any interval
starting at a given from level, using the existing has_do implementation. The
only drawback is a nasty error message in case a functor defines multiple Do
methods which start at the same from level. Currently we are not aware of a way
to catch the error inside the library. In addition to the algorithm presented
above the prototype introduces a number of checks. For instance Do methods are
not allowed to start or end at the maximum or minimum offset values around a
splitter. This boundary of unoccupied levels is used for the loop interval
computation, i.e. the loop interval computation has to introduce new levels
right before and after the Do methods. The other checks make sure the code
complies with our rules that the Do method overloads shall be continuous. The
following input-output pairs illustrate the algorithm:</p>
<blockquote>
<div><ul class="simple">
<li>Functor1, <code class="docutils literal"><span class="pre">Axis([0,-3],[4,+3])</span> <span class="pre">-&gt;</span> <span class="pre">Interval([0,1],[2,-1])</span></code></li>
<li>Functor2, <code class="docutils literal"><span class="pre">Axis([0,-3],[4,-2])</span> <span class="pre">-&gt;</span> <span class="pre">Interval([0,1],[1,-1]),</span> <span class="pre">Interval([1,1],[4,-2])</span></code></li>
<li>Functor2, <code class="docutils literal"><span class="pre">Axis([4,-1],[</span> <span class="pre">4,-1])</span> <span class="pre">-&gt;</span> <span class="pre">Interval([4,-1],[</span> <span class="pre">4,-1])</span></code></li>
</ul>
</div></blockquote>
<p>## Loop Intervals The loop interval computation overlays all functor Do method
intervals and splits them up into loop intervals. Every loop interval is a sub
interval of exactly one functor Do method interval. For an illustration have a
look at the red loop intervals in Figure 2. The loop interval computation works
on the following inputs: - DoMethods – Vector containing a Do method vector for
every functor - Axis – Maximal interval used for the Do method overload search
The following pseudo code implements the loop interval computation algorithm:</p>
<div class="figure" id="id11">
<img alt="../_images/splitters_005.png" src="../_images/splitters_005.png" />
<p class="caption"><span class="caption-number">Fig. 21 </span><span class="caption-text">Loop interval algorithm</span></p>
</div>
<p>The above algorithm uses a set instead of a sorted collection in order to store
the relevant levels. Once the set is complete we convert it to a sorted
collection via ordered iteration over all levels of the axis. Note that we work
with the index level representation which allows us to easily go to the next or
previous level using addition respectively subtraction. These operations are ok
as we are sure our Do method from and to levels are not splitter boundary
levels. It is important to introduce a sentinel level after the last Do method
interval in order to properly compute the loop interval for the last Do method
interval of a functor. Apart from that the loop interval computation is very
smooth and there are no special cases to consider.</p>
<div class="figure" id="id12">
<img alt="../_images/splitters_006.png" src="../_images/splitters_006.png" />
<p class="caption"><span class="caption-number">Fig. 22 </span><span class="caption-text">Loop interval computation  (note the read sentinel levels after the last functor do method)</span></p>
</div>
</div>
<div class="section" id="do-method-lookup-map">
<h3>Do Method Lookup Map<a class="headerlink" href="#do-method-lookup-map" title="Permalink to this headline">¶</a></h3>
<p>The Do method lookup map computation creates a map which
associates to every loop interval the matching Do method interval of a functor.
We compute such a map for every functor, which later on helps us to compute
on-the-fly the matching Do method overloads given a loop interval. The Do
method lookup map computation works on the following inputs: - DoMethods – Do
method vector containing all Do methods of a functor - LoopIntervals – List
containing all loop intervals The following pseudo code implements the Do
method lookup map computation:</p>
<div class="figure" id="id13">
<img alt="../_images/splitters_007.png" src="../_images/splitters_007.png" />
<p class="caption"><span class="caption-number">Fig. 23 </span><span class="caption-text">Do method lookup map algorithm</span></p>
</div>
<p>The algorithm iterates over loop intervals and Do method intervals at the same
time, creating a mapping between loop intervals and Do method intervals.
Usually the Do method intervals span a larger domain than the loop intervals.
Therefore the mapping is not 1:1.</p>
</div>
<div class="section" id="prototype">
<h3>Prototype<a class="headerlink" href="#prototype" title="Permalink to this headline">¶</a></h3>
<p>The interval prototype code implements the algorithms discussed in
chapter 3. The main logic is implemented by the following three files:</p>
<blockquote>
<div><ul class="simple">
<li>FunctorDoMethods.h</li>
<li>LoopIntervals.h</li>
<li>FunctorDoMethodLookupMaps.h</li>
</ul>
</div></blockquote>
<p>For every file there is a separate
test program, while the <code class="docutils literal"><span class="pre">main.cpp</span></code> runs the full algorithm. Using boost
for_each the test code iterates over all loop intervals and calls the matching
functor do method overloads:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Run Functor0, Functor1 and Functor2:
        -&gt; Loop (0,1) - (1,-1)
                -&gt; Functor1:Do(Interval&lt;Level&lt;0,1&gt;, Level&lt;2,-1&gt; &gt;) called
                -&gt; Functor2:Do(Interval&lt;Level&lt;0,1&gt;, Level&lt;1,-1&gt; &gt;) called
        -&gt; Loop (1,1) - (2,-1)
                -&gt; Functor1:Do(Interval&lt;Level&lt;0,1&gt;, Level&lt;2,-1&gt; &gt;) called
                -&gt; Functor2:Do(Interval&lt;Level&lt;1,1&gt;, Level&lt;3,-1&gt; &gt;) called
        -&gt; Loop (2,1) - (3,-2)
                -&gt; Functor2:Do(Interval&lt;Level&lt;1,1&gt;, Level&lt;3,-1&gt; &gt;) called
        -&gt; Loop (3,-1) - (3,-1)
                -&gt; Functor0:Do(Interval&lt;Level&lt;3,-1&gt;, Level&lt;3,-1&gt; &gt;) called
                -&gt; Functor2:Do(Interval&lt;Level&lt;1,1&gt;, Level&lt;3,-1&gt; &gt;) called
Done!
</pre></div>
</div>
<p>Note that the prototype works with vectors storing the main information: -
<code class="docutils literal"><span class="pre">Functors</span></code> – Vector storing all functors - <code class="docutils literal"><span class="pre">FunctorDoMethods</span></code> – Vector storing
a vector of Do methods for every functor - <code class="docutils literal"><span class="pre">FunctorDoMethodLookupMaps</span></code> – Vector
storing a do method lookup map for every functor - LoopIntervals – Vector
storing all loop intervals Note that the <code class="docutils literal"><span class="pre">Functors</span></code>, <code class="docutils literal"><span class="pre">FunctorDoMethods</span></code> and
<code class="docutils literal"><span class="pre">FunctorDoMethodLookupMaps</span></code> vectors are ordered identically, i.e. if we want to
combine all information for a specific functor we can do this by accessing the
same vector indexes.</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../faq/faq.html" class="btn btn-neutral float-right" title="Frequently Asked Questions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../glossary/glossary.html" class="btn btn-neutral" title="Glossary" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ETH Zurich.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.22.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>