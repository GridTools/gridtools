

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started &mdash; GridTools 0.22.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/css/cscs.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GridTools 0.22.0 documentation" href="../index.html"/>
        <link rel="next" title="User Manual" href="../user_manual/user_manual.html"/>
        <link rel="prev" title="Introduction" href="../introduction/introduction.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> GridTools
          

          
            
            <img src="../_static/logo.svg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.22
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#coordinate-system">Coordinate System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#storages">Storages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#backend">Backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-storage-type">The Storage Type</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stencils">Stencils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-naive-2d-laplacian">Example: Naive 2D Laplacian</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#first-gridtools-stencil">First GridTools Stencil</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#update-logic-gridtools-2d-laplacian">Update-logic: GridTools 2D Laplacian</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-the-stencil">Calling the Stencil</a></li>
<li class="toctree-l3"><a class="reference internal" href="#full-gridtools-laplacian">Full GridTools Laplacian</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#assembling-stencils-smoothing-filter">Assembling Stencils: Smoothing Filter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#apply-method-overload"><cite>apply</cite>-method overload</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gt-temporaries"><cite>GridTools</cite> Temporaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functor-calls">Functor Calls</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/user_manual.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/internal.html">Internal Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GridTools</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Getting Started</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/getting_started/getting_started.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<span id="id1"></span><h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes how to use <cite>GridTools</cite> to solve a (simple) PDE.
We will use a fourth-order horizontal smoothing filter
to explain the necessary steps to assemble a
stencil from scratch. We will not go into details in this chapter but
refer to later chapters for more details.</p>
<p>Our example PDE is given by</p>
<div class="math">
\[\begin{split}\frac{\partial \phi}{\partial t} =\begin{cases}
- \alpha \nabla^4 \phi &amp; z \leq z_\text{0}\\
0 &amp; z &gt; z_0
\end{cases}\end{split}\]</div>
<p>where <span class="math">\(\nabla^4\)</span> is the squared two dimensional horizontal
Laplacian and we apply the filter only up to some maximal <span class="math">\(z_0\)</span> (to make
the example more interesting). The filter is calculated in two steps:
first we calculate the Laplacian of <span class="math">\(\phi\)</span></p>
<div class="math">
\[L = \Delta \phi = \left( \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right) \phi\]</div>
<p>then we calculate the Laplacian of <span class="math">\(L\)</span> as <span class="math">\(-\alpha \nabla^4 \phi = -\alpha  \Delta L\)</span>.</p>
<p>In the following we will walk through the following steps:</p>
<ul class="simple">
<li>The <cite>GridTools</cite> coordinate system and its notation.</li>
<li>Storages: how does <cite>GridTools</cite> manage the input and output fields.</li>
<li>The first stencil: calculating <span class="math">\(L\)</span>, the second order Laplacian of <span class="math">\(\phi\)</span>.</li>
<li>The final stencil: function calls, apply-method overloads and temporaries</li>
</ul>
<div class="section" id="coordinate-system">
<h2>Coordinate System<a class="headerlink" href="#coordinate-system" title="Permalink to this headline">¶</a></h2>
<p>For a finite difference discretization we restrict the field
<span class="math">\(\phi \in \mathbb{R}^3\)</span> to a discrete grid. We use the notation
<span class="math">\(i = x_i\)</span> and <span class="math">\(j = y_j\)</span> for the horizontal dimension and <span class="math">\(k = z_k\)</span> for
the vertical dimension, where <span class="math">\(x_i, y_j, z_k\)</span> are the <span class="math">\(x,y,z\)</span>
coordinates restricted on the grid. The <em>computation domain</em> is defined
by all grid points in our domain of interest</p>
<div class="math">
\[\Lambda = (i,j,k) \quad \text{with}\quad i \in \{ 0\dots N_i-1\}, j \in \{0\dots N_j-1\}, k\in\{0 \dots N_k-1\}\]</div>
<p><cite>GridTools</cite> supports any number of dimension, however the iteration is always restricted to three dimensions, and <cite>GridTools</cite> will
treat one dimension, here the <span class="math">\(k\)</span>, dimension differently: the <span class="math">\(ij\)</span>-plane is executed in parallel while the
computation in <span class="math">\(k\)</span> can be sequential. The consequence is that there must not be a dependency in <span class="math">\(ij\)</span> within
a stencil while there can be a dependency in <span class="math">\(k\)</span>. For now (this chapter) it is sufficient to just remember that
the <span class="math">\(ij\)</span>-plane and the <span class="math">\(k\)</span> dimension are treated differently by <cite>GridTools</cite>.</p>
<p>The calculation domain is surrounded by a <em>boundary region</em> as depicted
in <a class="reference internal" href="#fig-getting-started-coordinates"><span class="std std-numref">Fig. 1</span></a>. Computation happens
only within the calculation domain but values may be read from grid
points in the boundary region.</p>
<div class="figure" id="id2">
<span id="fig-getting-started-coordinates"></span><a class="reference internal image-reference" href="../_images/coordinates.png"><img alt="../_images/coordinates.png" src="../_images/coordinates.png" style="width: 558.0px; height: 303.59999999999997px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Coordinate system</span></p>
</div>
</div>
<div class="section" id="storages">
<h2>Storages<a class="headerlink" href="#storages" title="Permalink to this headline">¶</a></h2>
<p>In this section we will set up the fields for our example: we need a
storage for the <span class="math">\(\phi\)</span>-field (<code class="docutils literal"><span class="pre">phi_in</span></code>) and a storage for the output
(<code class="docutils literal"><span class="pre">phi_out</span></code>).</p>
<p>Storages in <cite>GridTools</cite> are n-dimensional array-like objects with the
following capabilities:</p>
<ul class="simple">
<li>access an element with <span class="math">\((i,j,k)\)</span> syntax</li>
<li>synchronization between CPU memory and a device (e.g. a CUDA capable GPU)</li>
</ul>
<div class="section" id="backend">
<h3>Backend<a class="headerlink" href="#backend" title="Permalink to this headline">¶</a></h3>
<p>Since the storages (and other things later) depend on the architecture
(e.g. CPU or GPU) our first step is to define the <em>target</em> type which
typically looks like</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
</pre></div>
</div>
<p>for the CUDA <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> or</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">mc</span><span class="p">;</span>
</pre></div>
</div>
<p>for the CPU <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>. Second we define the backend as</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>which will be used later.</p>
</div>
<div class="section" id="the-storage-type">
<h3>The Storage Type<a class="headerlink" href="#the-storage-type" title="Permalink to this headline">¶</a></h3>
<p>For efficient memory accesses the index ordering might depend on the target architecture, therefore the
memory layout will be implicitly decided by target via the storage traits as follows.</p>
<p>For each storage type we need to define the data type of the data we want to
store in the field, e.g. <code class="docutils literal"><span class="pre">double</span></code>, and a <code class="docutils literal"><span class="pre">storage_info</span></code> type which will hold
information about size, alignment, strides etc. When creating the <code class="docutils literal"><span class="pre">storage_info</span></code> via the storage
traits we need to provide a unique identifier and the number of dimensions for the storage (typically 3).</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">storage_info_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>At run-time a <code class="docutils literal"><span class="pre">storage_info</span></code> is
initialized with the sizes of the field. Then a field can be
instantiated with the <code class="docutils literal"><span class="pre">info</span></code> object.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">uint_t</span> <span class="n">Ni</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">uint_t</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">uint_t</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">info</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nj</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>

<span class="n">data_store_t</span> <span class="nf">phi</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">lap</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;lap&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The first argument, the <code class="docutils literal"><span class="pre">info</span></code>
object, is mandatory, while the other arguments are optional: a name and an initial value for
the field.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For each <code class="docutils literal"><span class="pre">storage_info</span></code> type it is recommended to use only one instantiation. The mapping between a storage and the
run-time information in the <code class="docutils literal"><span class="pre">storage_info</span></code> has to be done at compile time via the index. Thus <cite>GridTools</cite> cannot
distinguish the storages by the run-time sizes passed to the <code class="docutils literal"><span class="pre">storage_info</span></code>. Using <code class="docutils literal"><span class="pre">data_store</span></code> s with same
<code class="docutils literal"><span class="pre">storage_info</span></code> type but different run-time sizes in the same computation is undefined behaviour.</p>
</div>
<p>We can now</p>
<ul class="simple">
<li>retrieve the name of the field,</li>
<li>create a view and read and write values in the field using the parenthesis syntax,</li>
<li>synchronize data between device and host (in CUDA mode).</li>
</ul>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">phi</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">phi_view</span> <span class="o">=</span> <span class="nl">make_host_view</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>
<span class="n">phi_view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;phi_view(1, 2, 3) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">phi_view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="n">phi</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="stencils">
<h2>Stencils<a class="headerlink" href="#stencils" title="Permalink to this headline">¶</a></h2>
<p>A <em>stencil</em> is a kernel that updates array elements according to a fixed
access pattern.</p>
<div class="section" id="example-naive-2d-laplacian">
<h3>Example: Naive 2D Laplacian<a class="headerlink" href="#example-naive-2d-laplacian" title="Permalink to this headline">¶</a></h3>
<p>The simplest discretization of the 2D Laplacian is the finite difference
five-point stencil as depicted in <a class="reference internal" href="#fig-getting-started-2dlap"><span class="std std-numref">Fig. 2</span></a>.</p>
<div class="figure" id="id3">
<span id="fig-getting-started-2dlap"></span><a class="reference internal image-reference" href="../_images/Laplacian2D.png"><img alt="../_images/Laplacian2D.png" src="../_images/Laplacian2D.png" style="width: 469.79999999999995px; height: 328.8px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Access pattern of a 2D Laplacian</span></p>
</div>
<p>For the calculation of
the Laplacian at a given grid point we need the value at the grid point
itself and its four direct neighbors along the Cartesian axis.</p>
<p>A naive C++ implementation of the 2D Laplacian stencil looks as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">laplacian</span><span class="p">(</span><span class="n">storage_view_t</span> <span class="o">&amp;</span><span class="n">lap</span><span class="p">,</span> <span class="n">storage_view_t</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">boundary_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">Ni</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">Nj</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">boundary_size</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">lap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>                  <span class="c1">//</span>
                               <span class="o">+</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//</span>
                               <span class="o">+</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Apart from the initialization the stencil implementation
consists of 2 main components:</p>
<ul class="simple">
<li>Loop-logic: defines the stencil application domain and loop order</li>
<li>Update-logic: defines the update formula (here: the 2D Laplacian)</li>
</ul>
<p>Special care had to be taken at the boundary of the domain. Since the
Laplacian needs the neighboring points, we cannot calculate the Laplacian
on the boundary layer and have to exclude it from the loop.</p>
</div>
</div>
<div class="section" id="first-gridtools-stencil">
<h2>First GridTools Stencil<a class="headerlink" href="#first-gridtools-stencil" title="Permalink to this headline">¶</a></h2>
<p>In <cite>GridTools</cite> the loop logic and the storage order are implemented (and optimized) by the library while the update function to
be applied to each gridpoint is implemented by the user. The loop logic (for a given architecture) is combined with the
user-defined update function at compile-time by template meta-programming.</p>
<div class="section" id="update-logic-gridtools-2d-laplacian">
<h3>Update-logic: GridTools 2D Laplacian<a class="headerlink" href="#update-logic-gridtools-2d-laplacian" title="Permalink to this headline">¶</a></h3>
<p>The update-logic is implemented with state-less functors. A
<cite>GridTools</cite> functor is a <code class="docutils literal"><span class="pre">struct</span></code> or <code class="docutils literal"><span class="pre">class</span></code> providing a <em>static</em> method
called <code class="docutils literal"><span class="pre">apply</span></code>. The update-logic is implemented in these <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Methods</span></a>.
As the functors are state-less (no member variables, static methods
only) they can be passed by type, i.e. at compile-time, and therefore
allow for compile-time optimizations.</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">expressions</span><span class="p">;</span>

<span class="cp">#ifdef __CUDACC__</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">mc</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">storage_info_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">j</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">k</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">lap_function</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">in</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">lap</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">in</span><span class="p">,</span> <span class="n">lap</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="o">-</span><span class="mf">4.</span> <span class="o">*</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In addition to the <code class="docutils literal"><span class="pre">apply</span></code>-method, the functor contains <code class="docutils literal"><span class="pre">accessor</span></code> s. These
two <code class="docutils literal"><span class="pre">accessor</span></code> s are parameters of the functor, i.e. they are mapped to
fields passed to the functor. They contain compile-time information if
they are only used as input parameters, e.g. the <code class="docutils literal"><span class="pre">in</span></code> accessor in the
example, or if we want to write into the associated field (<code class="docutils literal"><span class="pre">inout</span></code>). Additionally,
the <code class="docutils literal"><span class="pre">extent</span></code> defines which grid points are needed by the stencil relative
to the current point. The format for the extent is</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">extent</span><span class="o">&lt;</span><span class="n">i_minus</span><span class="p">,</span> <span class="n">i_plus</span><span class="p">,</span> <span class="n">j_minus</span><span class="p">,</span> <span class="n">j_plus</span><span class="p">,</span> <span class="n">k_minus</span><span class="p">,</span> <span class="n">k_plus</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">i_minus</span></code> and <code class="docutils literal"><span class="pre">i_plus</span></code> define an interval on the <span class="math">\(i\)</span>-axis relative to
the current position; <code class="docutils literal"><span class="pre">i_minus</span></code> is the negative offset, i.e. zero or a
negative number, while <code class="docutils literal"><span class="pre">i_plus</span></code> is the positive offset. Analogously for
<span class="math">\(j\)</span> and <span class="math">\(k\)</span>. In the Laplacian example, the first two numbers
in the extent of the <code class="docutils literal"><span class="pre">in</span></code> accessor define that we want to access the
field at <span class="math">\(i-1\)</span>, <span class="math">\(i\)</span> and  <span class="math">\(i+1\)</span>. The accessor type and the extent is needed for a
dependency analysis in the compile-time optimizations for more complex
stencils. (For example, the computation
domain needs to be extended when we calculate the Laplacian of the Laplacian later. This is done automatically by the
library.)</p>
<p>The first template argument is an index defining the order of the
parameters, i.e. the order in which the fields are passed to the
functor. The <code class="docutils literal"><span class="pre">param_list</span></code> is a <cite>GridTools</cite> keyword which has to be defined for each stencil,
and should contain th elist of accessors.</p>
<p>A <code class="docutils literal"><span class="pre">apply</span></code>-method needs as first parameter a context
object, usually called <code class="docutils literal"><span class="pre">eval</span></code>, which is created and passed to the method by the library on
invocation. This object contains, among other things, the index of the
active grid point (<a class="reference internal" href="../glossary/glossary.html#term-iteration-point"><span class="xref std std-term">Iteration Point</span></a>) and the mapping of data-pointers to the <code class="docutils literal"><span class="pre">accessor</span></code> s. The
second argument is optional and specifies the interval on the <span class="math">\(k\)</span>-axis where this implementation
of the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> should be executed. This allows to apply a different update-logic on
<a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a> by overloading the <a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a>. We will define <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a>
later. If the second parameter is not specified, a default interval is assumed.</p>
<p>The body of the <code class="docutils literal"><span class="pre">apply</span></code>-method looks quite similar to the one in the
naive implementation, except that each
field access has to be wrapped by a call to the context object <code class="docutils literal"><span class="pre">eval</span></code>.
This is necessary to map the compile-time parameter, the <code class="docutils literal"><span class="pre">accessor</span></code>, to
the run-time data in the <code class="docutils literal"><span class="pre">data_store</span></code>.</p>
</div>
<div class="section" id="calling-the-stencil">
<h3>Calling the Stencil<a class="headerlink" href="#calling-the-stencil" title="Permalink to this headline">¶</a></h3>
<p>In the naive implementation, the call to the
<code class="docutils literal"><span class="pre">laplacian</span></code> is as simple as</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">boundary_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">laplacian</span><span class="p">(</span> <span class="n">lap</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">boundary_size</span> <span class="p">);</span>
</pre></div>
</div>
<p>since it contains already all the information: the update-logic <em>and</em>
the loop-logic.</p>
<p>The <cite>GridTools</cite> stencil, does not contain any
information about the loop-logic, i.e. about the domain where we want to apply the stencil operation,
since we need to specify it in a platform-independent syntax, a <em>domain specific embedded language</em>
(DSEL), such that the <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a> can decide on the specific implementation.</p>
<p>For our example this looks as follows</p>
<div class="highlight-gridtools"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uint_t</span> <span class="n">Ni</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">uint_t</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">uint_t</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="n">storage_info_t</span> <span class="nf">info</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nj</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>

<span class="n">data_store_t</span> <span class="nf">phi</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">lap</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;lap&quot;</span><span class="p">);</span>

<span class="k">using</span> <span class="n">arg_phi</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_lap</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">halo_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">halo_descriptor</span> <span class="nf">boundary_i</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="p">);</span>
<span class="k">halo_descriptor</span> <span class="nf">boundary_j</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nj</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">my_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">laplacian</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>          <span class="c1">//</span>
    <span class="n">my_grid</span><span class="p">,</span>                                           <span class="c1">//</span>
    <span class="nl">make_multistage</span><span class="p">(</span>                                   <span class="c1">//</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>                           <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">(),</span> <span class="n">arg_lap</span><span class="p">())</span> <span class="c1">//</span>
        <span class="p">));</span>                                            <span class="c1">//</span>

<span class="n">laplacian</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arg_lap</span><span class="p">{}</span> <span class="o">=</span> <span class="n">lap</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In line 10 and 11 we define placeholders for the fields.</p>
<p>In lines 13-16 we setup the physical dimension of the problem.
First we define which points on the <span class="math">\(i\)</span> and the <span class="math">\(j\)</span>-axis belong
to the computational domain and which points belong to the boundary (or
a padding region). For now it is enough to know that these lines define
a region with a boundary of size 1 surrounding the <span class="math">\(ij\)</span>-plane. In the
next lines the layers in <span class="math">\(k\)</span> are defined. In this case we have only one
interval. We will discuss the details later.</p>
<p>In lines 18-23 we create the stencil object.
We pass the grid (the information about the loop bounds) and a so-called multistage. The multistage
contains a single stage, our Laplacian functor.</p>
<p>In more complex codes we can combine multiple <span class="math">\(k\)</span>-independent stages in
a multi_stage. If we have a <span class="math">\(k\)</span>-dependency we have to split the computation
into multiple multi_stages.</p>
<p>The statement <code class="docutils literal"><span class="pre">execute&lt;parallel&gt;</span></code> defines that all <cite>ij</cite>-layers can be calculated independently.
Other execution modes are <code class="docutils literal"><span class="pre">forward</span></code> and <code class="docutils literal"><span class="pre">backward</span></code>. For performance reason <code class="docutils literal"><span class="pre">parallel</span></code> should be used
whenever possible.</p>
<p>In the last line the stencil is
executed. The <a class="reference internal" href="../glossary/glossary.html#term-data-store"><span class="xref std std-term">Data Stores</span></a> <code class="docutils literal"><span class="pre">phi</span></code> and <code class="docutils literal"><span class="pre">lap</span></code> are bound to its placeholders.</p>
</div>
<div class="section" id="full-gridtools-laplacian">
<h3>Full GridTools Laplacian<a class="headerlink" href="#full-gridtools-laplacian" title="Permalink to this headline">¶</a></h3>
<p>The full working example looks as follows:</p>
<div class="highlight-gridtools"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;gridtools/stencil_composition/backend.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gridtools/stencil_composition/stencil_composition.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;gridtools/storage/storage_facility.hpp&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;gridtools/stencil_composition/accessor.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">gridtools</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">gridtools</span><span class="o">::</span><span class="n">expressions</span><span class="p">;</span>

<span class="cp">#ifdef __CUDACC__</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">cuda</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">using</span> <span class="n">target_t</span> <span class="o">=</span> <span class="n">target</span><span class="o">::</span><span class="n">mc</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">using</span> <span class="n">backend_t</span> <span class="o">=</span> <span class="n">backend</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">using</span> <span class="n">storage_info_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">storage_info_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">halo</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">data_store_t</span> <span class="o">=</span> <span class="k">storage_traits</span><span class="o">&lt;</span><span class="n">target_t</span><span class="o">&gt;::</span><span class="n">data_store_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">storage_info_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">j</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">static</span> <span class="n">gridtools</span><span class="o">::</span><span class="k">dimension</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">k</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">lap_function</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">in</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">lap</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">in</span><span class="p">,</span> <span class="n">lap</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="o">-</span><span class="mf">4.</span> <span class="o">*</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">Ni</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

    <span class="n">storage_info_t</span> <span class="n">info</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nj</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>

    <span class="n">data_store_t</span> <span class="n">phi</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">);</span>
    <span class="n">data_store_t</span> <span class="n">lap</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;lap&quot;</span><span class="p">);</span>

    <span class="k">using</span> <span class="n">arg_phi</span> <span class="o">=</span> <span class="n">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">arg_lap</span> <span class="o">=</span> <span class="n">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">halo_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">halo_descriptor</span> <span class="n">boundary_i</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="p">);</span>
    <span class="n">halo_descriptor</span> <span class="n">boundary_j</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nj</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">my_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">laplacian</span> <span class="o">=</span> <span class="n">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>          <span class="c1">//</span>
        <span class="n">my_grid</span><span class="p">,</span>                                           <span class="c1">//</span>
        <span class="n">make_multistage</span><span class="p">(</span>                                   <span class="c1">//</span>
            <span class="n">execute</span><span class="o">::</span><span class="n">parallel</span><span class="p">(),</span>                           <span class="c1">//</span>
            <span class="n">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">(),</span> <span class="n">arg_lap</span><span class="p">())</span> <span class="c1">//</span>
            <span class="p">));</span>                                            <span class="c1">//</span>

    <span class="n">laplacian</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arg_lap</span><span class="p">{}</span> <span class="o">=</span> <span class="n">lap</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// end marker</span>
</pre></div>
</td></tr></table></div>
<p>There are some points which we did not discuss so far. For a first look at <cite>GridTools</cite> these can be considered fixed patterns and
we won’t discuss them now in detail. In brief:</p>
<ul class="simple">
<li>In order to use the <span class="math">\((i,j,k)\)</span> syntax we need to define the symbols to point to the respective dimensions.</li>
<li>A common pattern is to use the preprocessor flag <code class="docutils literal"><span class="pre">__CUDACC__</span></code> to distinguish between CPU and GPU code. We use this to set the <a class="reference internal" href="../glossary/glossary.html#term-backend"><span class="xref std std-term">Backend</span></a>.</li>
</ul>
<p>The code example can be compiled using the following simple CMake script (requires an installation of GridTools, see <a class="reference internal" href="../introduction/introduction.html#installation"><span class="std std-ref">Installation and Use</span></a>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cmake_minimum_required</span><span class="p">(</span><span class="n">VERSION</span> <span class="mf">3.12</span><span class="o">.</span><span class="mi">4</span><span class="p">)</span>

<span class="n">project</span><span class="p">(</span><span class="n">GridTools</span><span class="o">-</span><span class="n">laplacian</span> <span class="n">LANGUAGES</span> <span class="n">CXX</span><span class="p">)</span>

<span class="n">find_package</span><span class="p">(</span><span class="n">GridTools</span> <span class="mf">0.22</span><span class="o">.</span><span class="mi">0</span> <span class="n">REQUIRED</span><span class="p">)</span>

<span class="n">add_executable</span><span class="p">(</span><span class="n">gt_laplacian</span> <span class="n">test_gt_laplacian</span><span class="o">.</span><span class="n">cpp</span><span class="p">)</span>
<span class="n">target_link_libraries</span><span class="p">(</span><span class="n">gt_laplacian</span> <span class="n">GridTools</span><span class="p">::</span><span class="n">gridtools</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="assembling-stencils-smoothing-filter">
<h2>Assembling Stencils: Smoothing Filter<a class="headerlink" href="#assembling-stencils-smoothing-filter" title="Permalink to this headline">¶</a></h2>
<p>In the preceding section we saw how a first simple <cite>GridTools</cite> stencil
is defined and executed. In this section we will use this stencil to
compute our example PDE. A naive implementation could look as in</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">naive_smoothing</span><span class="p">(</span><span class="n">storage_view_t</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">storage_view_t</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kmax</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">lap_boundary</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">full_boundary</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">Ni</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">Nj</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">total_length</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="c1">// Instantiate temporary fields</span>
    <span class="n">storage_info_t</span> <span class="n">info</span><span class="p">(</span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nj</span><span class="p">,</span> <span class="n">Nk</span><span class="p">);</span>
    <span class="n">data_store_t</span> <span class="n">lap_storage</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lap</span> <span class="o">=</span> <span class="n">make_host_view</span><span class="p">(</span><span class="n">lap_storage</span><span class="p">);</span>
    <span class="n">data_store_t</span> <span class="n">laplap_storage</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">laplap</span> <span class="o">=</span> <span class="n">make_host_view</span><span class="p">(</span><span class="n">laplap_storage</span><span class="p">);</span>

    <span class="c1">// laplacian of phi</span>
    <span class="n">laplacian</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">lap_boundary</span><span class="p">);</span>
    <span class="c1">// laplacian of lap</span>
    <span class="n">laplacian</span><span class="p">(</span><span class="n">laplap</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span> <span class="n">full_boundary</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">full_boundary</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmax</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">laplap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">in</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the <cite>GridTools</cite> implementation we will learn three things in this
section: how to define special regions in the <span class="math">\(k\)</span>-direction; how to use
<cite>GridTools</cite> temporaries and how to call functors from functors.</p>
<div class="section" id="apply-method-overload">
<h3><cite>apply</cite>-method overload<a class="headerlink" href="#apply-method-overload" title="Permalink to this headline">¶</a></h3>
<p>Our first <cite>GridTools</cite> implementation will be very close to the naive
implementation: we will call two times the Laplacian functor from the
previous section and store the result in two extra fields. Then we will
call a third functor to compute the final result. This functor shows how
we can specialize the computation in the <span class="math">\(k\)</span>-direction:</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">smoothing_function_1</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">phi</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">laplap</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">out</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">phi</span><span class="p">,</span> <span class="n">laplap</span><span class="p">,</span> <span class="n">out</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">lower_domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="c1">//</span>
                             <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">eval</span><span class="p">(</span><span class="n">laplap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">upper_domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We use two different
<a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a>, the <code class="docutils literal"><span class="pre">lower_domain</span></code> and the <code class="docutils literal"><span class="pre">upper_domain</span></code>, and provide an overload of the
<a class="reference internal" href="../glossary/glossary.html#term-apply-method"><span class="xref std std-term">Apply-Method</span></a> for each interval.</p>
<p>The <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a> are defined as</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">axis_t</span> <span class="o">=</span> <span class="n">axis</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">lower_domain</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">upper_domain</span> <span class="o">=</span> <span class="n">axis_t</span><span class="o">::</span><span class="n">get_interval</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The first line defines an axis with 2 <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a>. From this axis retrieve the <a class="reference internal" href="../glossary/glossary.html#term-vertical-interval"><span class="xref std std-term">Vertical Intervals</span></a>
and give them a name.</p>
<p>Then we can assemble the computation</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">data_store_t</span> <span class="nf">phi</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">phi_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">lap</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">laplap</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="k">using</span> <span class="n">arg_phi</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_phi_new</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_lap</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_laplap</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">halo_descriptor</span> <span class="nf">boundary_i</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="p">);</span>
<span class="k">halo_descriptor</span> <span class="nf">boundary_j</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nj</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">my_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">,</span> <span class="n">axis_t</span><span class="p">{</span><span class="n">kmax</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">kmax</span><span class="p">});</span>

<span class="k">auto</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>              <span class="c1">//</span>
    <span class="n">my_grid</span><span class="p">,</span>                                               <span class="c1">//</span>
    <span class="nl">make_multistage</span><span class="p">(</span>                                       <span class="c1">//</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>                               <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">(),</span> <span class="n">arg_lap</span><span class="p">()),</span>    <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_lap</span><span class="p">(),</span> <span class="n">arg_laplap</span><span class="p">()),</span> <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">smoothing_function_1</span><span class="o">&gt;</span><span class="p">(</span>                  <span class="c1">//</span>
            <span class="n">arg_phi</span><span class="p">(),</span>                                     <span class="c1">//</span>
            <span class="n">arg_laplap</span><span class="p">(),</span>                                  <span class="c1">//</span>
            <span class="n">arg_phi_new</span><span class="p">())</span>                                 <span class="c1">//</span>
        <span class="p">));</span>                                                <span class="c1">//</span>

<span class="n">smoothing</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arg_lap</span><span class="p">{}</span> <span class="o">=</span> <span class="n">lap</span><span class="p">,</span> <span class="n">arg_laplap</span><span class="p">{}</span> <span class="o">=</span> <span class="n">laplap</span><span class="p">,</span> <span class="n">arg_phi_new</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi_new</span><span class="p">);</span>
</pre></div>
</div>
<p>In this version we needed to explicitly allocate the temporary fields
<code class="docutils literal"><span class="pre">lap</span></code> and <code class="docutils literal"><span class="pre">laplap</span></code>. In the next section we will learn about
<cite>GridTools</cite> temporaries.</p>
</div>
<div class="section" id="gt-temporaries">
<h3><cite>GridTools</cite> Temporaries<a class="headerlink" href="#gt-temporaries" title="Permalink to this headline">¶</a></h3>
<p><cite>GridTools</cite> <em>temporary storages</em> are storages with the lifetime of the
<code class="docutils literal"><span class="pre">computation</span></code>, i.e. they can be used by different stages assembled in one
<code class="docutils literal"><span class="pre">make_computation</span></code> call. This is exactly what we need for the <code class="docutils literal"><span class="pre">lap</span></code> and <code class="docutils literal"><span class="pre">laplap</span></code>
fields.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that temporaries are not allocated explicitly and we cannot
access them from outside of the computation. Therefore, sometimes it might be
necessary to replace a temporary by a normal storage for debugging.</p>
</div>
<p>To use temporary storages we don’t need to change the functors or the
<code class="docutils literal"><span class="pre">make_computation</span></code>. We just have to replace the type the <code class="docutils literal"><span class="pre">arg</span></code> by a <code class="docutils literal"><span class="pre">tmp_arg</span></code>. We don’t need the explicit
instantiations any more and don’t have to bind the <code class="docutils literal"><span class="pre">tmp_arg</span></code> to storages. The new code looks as follows</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">data_store_t</span> <span class="nf">phi</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">phi_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="k">using</span> <span class="n">arg_phi</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_phi_new</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_lap</span> <span class="o">=</span> <span class="k">tmp_arg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_laplap</span> <span class="o">=</span> <span class="k">tmp_arg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">halo_descriptor</span> <span class="nf">boundary_i</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="p">);</span>
<span class="k">halo_descriptor</span> <span class="nf">boundary_j</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nj</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">my_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">,</span> <span class="n">axis_t</span><span class="p">{</span><span class="n">kmax</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">kmax</span><span class="p">});</span>

<span class="k">auto</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>              <span class="c1">//</span>
    <span class="n">my_grid</span><span class="p">,</span>                                               <span class="c1">//</span>
    <span class="nl">make_multistage</span><span class="p">(</span>                                       <span class="c1">//</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>                               <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">(),</span> <span class="n">arg_lap</span><span class="p">()),</span>    <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_lap</span><span class="p">(),</span> <span class="n">arg_laplap</span><span class="p">()),</span> <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">smoothing_function_1</span><span class="o">&gt;</span><span class="p">(</span>                  <span class="c1">//</span>
            <span class="n">arg_phi</span><span class="p">(),</span>                                     <span class="c1">//</span>
            <span class="n">arg_laplap</span><span class="p">(),</span>                                  <span class="c1">//</span>
            <span class="n">arg_phi_new</span><span class="p">())</span>                                 <span class="c1">//</span>
        <span class="p">));</span>                                                <span class="c1">//</span>

<span class="n">smoothing</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arg_phi_new</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi_new</span><span class="p">);</span>
</pre></div>
</div>
<p>The temporary
storages are allocated in the call to <code class="docutils literal"><span class="pre">make_computation</span></code> and freed in the destructor of the computation.
Besides
the simplifications in the code (no explicit storage needed), the
concept of temporaries allows <cite>GridTools</cite> to apply optimization. While normal storages
have a fixed size, temporaries can have block-private <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halos</span></a> which are used for redundant computation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It might be semantically incorrect to replace a temporary with a normal storage, as normal storages don’t have the <a class="reference internal" href="../glossary/glossary.html#term-halo"><span class="xref std std-term">Halo</span></a>
region for redundant computation. In such case several threads (OpenMP or CUDA) will write the same location multiple
times. As long as all threads write the same data (which is a requirement for correctness of <cite>GridTools</cite>), this should be
no problem for correctness on current hardware (might change in the future) but might have side-effects on performance.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This change from normal storages to temporaries did not require any code changes to the functor.</p>
</div>
</div>
<div class="section" id="functor-calls">
<h3>Functor Calls<a class="headerlink" href="#functor-calls" title="Permalink to this headline">¶</a></h3>
<p>The next feature we want to use is the <em>stencil function call</em>. In the first example we computed the Laplacian
and the Laplacian of the Laplacian explicitly and stored the intermediate values in the temporaries. Stencil function
calls will allow us do the computation on the fly and will allow us to get rid of the temporaries.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that this is
not necessarily a performance optimization. It might well be that the version with temporaries is actually the
faster one.</p>
</div>
<p>In the following we will remove only one of the temporaries. Instead of calling the Laplacian twice from the
<code class="docutils literal"><span class="pre">make_computation</span></code>, we will move one of the calls into the smoothing functor. The new smoothing functor looks as
follows</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">smoothing_function_3</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">phi</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">lap</span> <span class="o">=</span> <span class="k">in_accessor</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="k">extent</span><span class="o">&lt;-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">out</span> <span class="o">=</span> <span class="k">inout_accessor</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">param_list</span> <span class="o">=</span> <span class="n">make_param_list</span><span class="o">&lt;</span><span class="n">phi</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span> <span class="n">out</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="k">static</span> <span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">lower_domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span>                <span class="c1">//</span>
                                                      <span class="k">call</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span> <span class="c1">//</span>
                                                      <span class="o">::</span><span class="k">with</span><span class="p">(</span><span class="n">eval</span><span class="p">,</span> <span class="n">lap</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Evaluation</span><span class="o">&gt;</span>
    <span class="cp">GT_FUNCTION</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Evaluation</span> <span class="o">&amp;</span><span class="n">eval</span><span class="p">,</span> <span class="n">upper_domain</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">eval</span><span class="p">(</span><span class="n">out</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In <code class="docutils literal"><span class="pre">call</span></code> we specify the functor which we want to apply.  In <code class="docutils literal"><span class="pre">with</span></code> the <code class="docutils literal"><span class="pre">eval</span></code> is forwarded, followed by all the
input arguments for the functor. The functor in the call is required to have exactly one <code class="docutils literal"><span class="pre">inout_accessor</span></code> which will
be the return value of the call. Note that <code class="docutils literal"><span class="pre">smoothing_function_3</span></code> still needs to specify the extents explicitly;
for functor calls they cannot be inferred automatically.</p>
<p>One of the <code class="docutils literal"><span class="pre">make_stage&lt;lap_function&gt;</span></code> was now moved inside of the functor, therefore the new call to <code class="docutils literal"><span class="pre">make_computation</span></code> is just</p>
<div class="highlight-gridtools"><div class="highlight"><pre><span></span><span class="n">data_store_t</span> <span class="nf">phi</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">data_store_t</span> <span class="nf">phi_new</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="k">using</span> <span class="n">arg_phi</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_phi_new</span> <span class="o">=</span> <span class="k">arg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">arg_lap</span> <span class="o">=</span> <span class="k">tmp_arg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">data_store_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">halo_descriptor</span> <span class="nf">boundary_i</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ni</span><span class="p">);</span>
<span class="k">halo_descriptor</span> <span class="nf">boundary_j</span><span class="p">(</span><span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">halo_size</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">-</span> <span class="n">halo_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nj</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">my_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">boundary_i</span><span class="p">,</span> <span class="n">boundary_j</span><span class="p">,</span> <span class="n">axis_t</span><span class="p">{</span><span class="n">kmax</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">kmax</span><span class="p">});</span>

<span class="k">auto</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="nl">make_computation</span><span class="o">&lt;</span><span class="n">backend_t</span><span class="o">&gt;</span><span class="p">(</span>           <span class="c1">//</span>
    <span class="n">my_grid</span><span class="p">,</span>                                            <span class="c1">//</span>
    <span class="nl">make_multistage</span><span class="p">(</span>                                    <span class="c1">//</span>
        <span class="k">execute</span><span class="o">::</span><span class="k">parallel</span><span class="p">(),</span>                            <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">lap_function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">(),</span> <span class="n">arg_lap</span><span class="p">()),</span> <span class="c1">//</span>
        <span class="nl">make_stage</span><span class="o">&lt;</span><span class="n">smoothing_function_3</span><span class="o">&gt;</span><span class="p">(</span>               <span class="c1">//</span>
            <span class="n">arg_phi</span><span class="p">(),</span>                                  <span class="c1">//</span>
            <span class="n">arg_lap</span><span class="p">(),</span>                                  <span class="c1">//</span>
            <span class="n">arg_phi_new</span><span class="p">())</span>                              <span class="c1">//</span>
        <span class="p">));</span>                                             <span class="c1">//</span>

<span class="n">smoothing</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">arg_phi</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arg_phi_new</span><span class="p">{}</span> <span class="o">=</span> <span class="n">phi_new</span><span class="p">);</span>
</pre></div>
</div>
<p>The attentive reader may have noticed that our first versions did more
work than needed: we calculated the Laplacian of the Laplacian of phi
(<span class="math">\(\Delta \Delta \phi\)</span>) for all <span class="math">\(k\)</span>-levels, however we used it only for
<span class="math">\(k&lt;k_\text{max}\)</span>. In this version we do a bit better: we still calculate
the Laplacian (<span class="math">\(L = \Delta \phi\)</span>) for all levels but we only calculate
<span class="math">\(\Delta L\)</span> for the levels where we need it.</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../user_manual/user_manual.html" class="btn btn-neutral float-right" title="User Manual" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../introduction/introduction.html" class="btn btn-neutral" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ETH Zurich.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.22.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>